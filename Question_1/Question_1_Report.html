<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>


<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Baby Name Analysis" />




<meta name="author" content="Matt Kruger - 25113186" />

<meta name="date" content="2025-06-18" />

<meta name="description" content="Baby Name Analysis">

<script id="pandoc-meta" type="application/json">
{"author":"Matt Kruger - 25113186","bibliography":"Tex/ref.bib","csl":"Template/harvard-stellenbosch-university.csl","date":"2025-06-18","newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"csl":"Template/harvard-stellenbosch-university.csl","css":["Template/default-fonts-Texevier.css","Template/default-page-Texevier.css","Template/default-Texevier.css"],"self_contained":true,"template":["Template/paged-Texevier.html"],"toc":true}},"title":"Baby Name Analysis"}
</script>

<title>Baby Name Analysis</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,AAEAAAARAQAABAAQR0RFRgcXBvMAAAIAAAAAdEdQT1NiVGkmAAAW1AAACOJHU1VCQ0AqzgAACrgAAAOGT1MvMlfppHMAAAGgAAAAYGNtYXCTnlPJAAAIDAAAAqxjdnQgB7U7jAAAAygAAADCZnBnbXZkgHwAAB+4AAANFmdhc3AAAAAQAAABHAAAAAhnbHlmZdGfbwAALNAAANCwaGVhZAmq1O8AAAFoAAAANmhoZWEGHwLaAAABRAAAACRobXR4FgwohgAADkAAAAQ0bG9jYSyhYLkAAAXwAAACHG1heHAC9w6zAAABJAAAACBuYW1lKYVGYwAAA+wAAAICcG9zdKXFCSgAABJ0AAAEYHByZXCVCZ7KAAACdAAAALEAAQAB//8ADwABAAABDQCoAAoAoQAFAAIAQABRAIsAAAEMDRYAAwABAAEAAAL6/xIA7AWY/Mz9IgVqAAEAAAAAAAAAAAAAAAAAAAENAAEAAAADAADCKcnSXw889QADA+gAAAAA0+YTgwAAAADUdX1i/Mz+2gVqBEwAAAAHAAIAAAAAAAAABAJcAZAABQAAAooCWAAAAEsCigJYAAABXgAyAREAAAAABQAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAUGZFZADAAAAiFQL6/xIA7AO0ARogAAGXAAAAAAHIAsgAAAAgAAMAAQAAACIAAAAAAAwAAgADAPcA/AACAP0A/QABAP4BAgACAAIADQAEAAQAAQARABEAAQAZABkAAQAlACUAAQAzADMAAQA7ADsAAQA+AD4AAQBLAEsAAQBTAFQAAQBhAGEAAQBwAHAAAQB4AHgAAQD3AQIAAwBLuADIUlixAQGOWbABuQgACABjcLEAB0K1XEg0IAQAKrEAB0JACk8IOwgnCBUHBAgqsQAHQkAKWQZFBjEGHgUECCqxAAtCvRQADwAKAAWAAAQACSqxAA9CvQBAAEAAQABAAAQACSqxAwBEsSQBiFFYsECIWLEDZESxJgGIUVi6CIAAAQRAiGNUWLEDAERZWVlZQApRCD0IKQgXBwQMKrgB/4WwBI2xAgBEswVkBgBERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgAWAAYABgCyAAAAcgAAP8aA7T+5gLa/+4B1P/0/xIDtP7mAFgAWAAYABgCyAAAAroByAAA/xoDtP7mAtr/7gK6AdT/9P8SA7T+5gBYAFgAGAAYAQj/ZAK6AcgAAP8aA7T+5gEI/1oCugHU//T/GgO0/uYAWABYABgAGALCARYCugHIAAD/GgO0/uYCwgEOAroB1P/0/xIDtP7mAAAAAAAIAGYAAwABBAkAAACKARIAAwABBAkAAQAeAPQAAwABBAkAAgAOAOYAAwABBAkAAwBAAKYAAwABBAkABAAuAHgAAwABBAkABQAaAF4AAwABBAkABgAqADQAAwABBAkADgA0AAAAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAE8AbABkAFMAdABhAG4AZABhAHIAZABUAFQALQBSAGUAZwB1AGwAYQByAFYAZQByAHMAaQBvAG4AIAAzAC4AMAAwADAATwBsAGQAIABTAHQAYQBuAGQAYQByAGQAIABUAFQAIABSAGUAZwB1AGwAYQByADMALgAwADAAMAA7AFAAZgBFAGQAOwBPAGwAZABTAHQAYQBuAGQAYQByAGQAVABUAC0AUgBlAGcAdQBsAGEAcgBSAGUAZwB1AGwAYQByAE8AbABkACAAUwB0AGEAbgBkAGEAcgBkACAAVABUAEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADEAMQAgAFQAaABlACAATwBsAGQAIABTAHQAYQBuAGQAYQByAGQAIABQAHIAbwBqAGUAYwB0ACAAQQB1AHQAaABvAHIAcwAgACgAYQBtAGsAcgB5AHUAawBvAHYAQABnAG0AYQBpAGwALgBjAG8AbQApAAAAAABtAG0AbQBtAM0BRwHGAmAC2wN8BBME0QVQBckGfwbYB0cH1Qh+CS0J8wqcCxgL5QxVDJcM8w1VDc0OKQ6MDwgPWQ/dEEkQvhFwEcISLRKfEyQTjxQBFIYVSBWvFiQWxBdeGCIYfxjgGVsZ3xp3GvIbVhvgHGcczR1NHZ8eIh7dH3sgLiDpIaAiVCL/I3UjyiR0JPUlbiW+JkAmqScoJ6soNykMKX4p8SovKpkq9CtoK9IsZCy9LTsteC3SLm8u4i+QL9EwPTCYMQcxczHTMkYyxDMuM5cz+TSGNPs1rjXvNlc27zdyOBA4qTj8OXI58zp4Oy476zw3PMI9Tj5APo4+4D81P8NAcEDVQXJCC0KEQwdDoUPhRChErUUxRYVGG0aLRvBHWUfJR9FH2UfhR+lH8Uf5SAFICUgRSBlIW0iQSQJJh0nHSnpK60tSS71ML0xVTSFNqk58TzJPWE99T59P21AMUFdQnFDlUWdRiVITUqFS5VMVU11Tg1OiU/tUVVSHVLVU0lTvVQpVJVVAVVtVjVW/VdxV+VZKVqRXAlc4V3VXplemV6ZXplgKWHtZb1oZWwBbplu4W/hcB1wqXHhco1y6XNNdE11pXYpeC16tXsle5F+kYGJgpWFCYdlimmMIY1BjdGOwY9Jj6GQGZEVkZ2SJZMtk62VRZXpltWXTZfFmKWZFZnhmr2bRZzBnVWeTZ7Vn1WgXaFgAAAACAAAAAwAAABQAAwABAAAAFAAEApgAAABCAEAABQACAAAADQAvADkAfgD/ATEBUwK8AsYC2gLcAwEDBAMJAyMgCSALIBQgGiAeICIgJiAzIDogRCCsISIhkSGTIhIiFf//AAAAAAANACAAMAA6AKABMQFSArsCxgLaAtwDAAMDAwgDIyAJIAsgEyAYIBwgIiAmIDIgOSBEIKwhIiGRIZMiEiIV//8AAf/1AAAAUAAAAAD/IwAAAAD+Qf4x/jD9+P33AAD92uDK4MkAAOC3AADgjeCM4MPgkeBk4Czfzt9X31bey97GAAEAAAAAAD4AAABaAOIAAAGeAaAAAAAAAAAAAAAAAZgAAAAAAAABlAAAAZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwCzALkAtQDXAOcA6wC6AMIAwwCsANwAsQDGALYAvACwALsA4gDgAOEAtwDqAAQADAANAA8AEQAWABcAGAAZAB4AHwAgACIAIwAlAC0ALwAwADEAMgAzADgAOQA6ADsAPQDAAK0AwQD0AL0BCQA+AEYARwBJAEsAUABRAFIAUwBZAFsAXABeAF8AYQBpAGsAbABtAG8AcAB1AHYAdwB4AHsAvgDyAL8A5ADSALQA1QDZANYA2gDzAO0BCADuAH4AyADlAMcA7wEKAPEA4wCgAKEBBQDmAOwArgEGAJ8AfwDJAKoAqQCrALgACAAFAAYACgAHAAkACwAOABUAEgATABQAHQAaABsAHAAQACQAKQAmACcAKwAoAN4AKgA3ADQANQA2ADwALgBuAEIAPwBAAEQAQQBDAEUASABPAEwATQBOAFgAVQBWAFcASgBgAGUAYgBjAGcAZADfAGYAdABxAHIAcwB5AGoAegAsAGgBBAEDAPcA/ADFAMQAzQDOAMwAAQAAAAoAcgEcAANERkxUAFRjeXJsAEBsYXRuABQAHAABQ0FUIAAKAAD//wAGAAMABwALAA8AEAAUAAD//wAFAAIABgAKAA4AEwAEAAAAAP//AAUAAQAFAAkADQASAAQAAAAA//8ABQAAAAQACAAMABEAFWNjbXAAomNjbXAAomNjbXAAomNjbXAAomRub20AnGRub20AnGRub20AnGRub20AnGZyYWMAkmZyYWMAkmZyYWMAkmZyYWMAkmxpZ2EAjGxpZ2EAjGxpZ2EAjGxpZ2EAjGxvY2wAhm51bXIAgG51bXIAgG51bXIAgG51bXIAgAAAAAEAAwAAAAEAAgAAAAEACAAAAAMABQAGAAcAAAABAAQAAAACAAAAAQAMAeYBrgFqAVIBRAEwAVIA6ADAAJIAZAAaAAEAAAABAAgAAgAiAA4AfgB/AH4AfwCKAIsAjACNAI4AjwCQAJEAkgCTAAEADgAEACUAPgBhAJQAlQCWAJcAmACZAJoAmwCcAJ0ABAAAAAEACAABAB4AAgAUAAoAAQAEAF0AAgCuAAEABAAhAAIArgABAAIAIABcAAEAAAABAAgAAgAUAAcAVABaAP4A/wEAAQEBAgABAAcAUwBZAPcA+AD5APoA+wAEAAAAAQAIAAEAGgABAAgAAgAMAAYAfQACAFwAfAACAFMAAQABAFAABgAAAAIAJgAKAAMAAQASAAEALgAAAAEAAAALAAIAAQCKAJMAAAADAAEAHAABABIAAAABAAAACwACAAEAlACdAAAAAQABAKgAAQAAAAEACAABAAb/7AABAAEAvAABAAAAAQAIAAEAFAAKAAEAAAABAAgAAQAGABQAAgABAIAAiQAAAAYAAAACACQACgADAAAAAgAUAC4AAQAUAAEAAAAKAAEAAQAgAAMAAAACABoAFAABABoAAQAAAAoAAQABAK4AAQABAFwABgAAAAIAHAAKAAMAAQAkAAEAagAAAAEAAAAJAAMAAAABAFgAAQASAAEAAAAJAAIAAQD+AQIAAAAGAAAABABgAEYAKgAOAAMAAQASAAEALgAAAAEAAAAJAAIAAQAEAD0AAAADAAEAEgABABIAAAABAAAACQACAAEA9wD7AAAAAwAAAAEANgACABQALAABAAAACQABAAEA/QADAAAAAQAcAAEAEgABAAAACQACAAEA9wD8AAAAAQACAFMAWQAAAfQAXQAAAAABGAAAARgAAAL8AC4C/AAuAvwALgL8AC4C/AAuAvwALgL8AC4D7AAaArIAPgKeAEYCngBGAwwAPgMAAD4CsgA+ArIAPgKyAD4CsgA+ArIAPgKkAD4C0ABGAxQAPgGKAD4BigA+AYoAMgGKADYBigA+AhwALAL0AD4CngA+Ap4APgNGAD4DAgA+AwIAPgK8AEYCvABGArwARgK8AEYCvABGArwARgK8AEYEGABGAqgAPgKoAD4CvABGAswAPgJsAFgCygBIAwwANAMMADQDDAA0AwwANAMMADQDBAAsBCwAJgLuAC4C2AAqAtgAKgKMAEQB7gAuAe4ALgHuAC4B7gAuAe4ALgHuAC4B7gAuArwALgIAABYBtAAwAbQAMAIKADAB9AAwAcwAMAHMADABzAAwAcwAMAHMADABSgAcAhwANAIgABwBDgAmAQ4AJgEOACYBGgAHARoACwEO//QBQP/aAUD/2gIIABwBDgAcAXQAHAMaACYCHAAmAhwAJgHwADAB8AAwAfAAMAHwADAB8AAwAfAAMAHwADAC/gAwAgYAHAH0ABoB9gAwAZoAJgGyADQCDgAcAV4AHAIWACACFgAgAhYAIAIWACACFgAgAhIAEgMIABICCAAiAhIAEgISABICEgASAbgAKAISABwCEgAcAXwAPgF8AEYCRAAwAkQAeAJEAEoCRABIAkQAOAJEAFYCRABQAkQAWgJEADwCRABOAXwAHgF8AFQBfAA0AXwARAF8ACwBfAA2AXwANgF8ADwBfAAoAXwAMgF8AB4BfABUAXwANAF8AEQBfAAsAXwANgF8ADYBfAA8AXwAKAF8ADIBfAAeAXwAVAF8ADQBfABEAXwALAF8ADYBfAA2AXwAPAF8ACgBfAAyAFL/gAM0AFQDNABUAzQARAH2AEgBwgA4ARgATgH0AIgBGABOARgASANIAE4BGABOARgATgKsAFEBGABOAdYAQAHWACIBigBWAPAAVgEYAEgBwgA4AggAAAGkAGgBpABUAXwAeAF8AEYBcgBiAXIAMAPoADwCbAA8AXIAPAFyADwB4ABsAeAAcgFKAGwBSgBbAdIASAHSAEYB0gBIARgARgEYAEgBGABIARgAAACkAAAAAAAA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) format('truetype');
}
body {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;}blockquote {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;}code {font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;}pre, code {font-size: .95em;}</style>
<style type="text/css">@page {size: 6in 9in; }@page :blank {}.shorttitle1 {string-set: h1-text content(text);}.shorttitle2 {string-set: h2-text content(text);}.running-h1-title {position: running(runningH1Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h1-title:before {content: string(h1-text);}@page chapter:left {@top-left {content: counter(page);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}.running-h2-title {position: running(runningH2Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h2-title:before {content: string(h2-text);}@page chapter:right {@top-right {content: counter(page);}@top-left {content: element(runningH2Title);white-space: nowrap !important;}}@page chapter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page);}}@page :first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: none !important;}background-image: var(--front-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.front-cover {break-after: recto;}.front-page {counter-reset: page 1;}@page frontmatter:left {@top-left {content: counter(page, lower-roman);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:left {@top-right {content: counter(page, lower-roman);}@top-left {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page, lower-roman);}}.back-cover {break-before: verso;}.pagedjs_page:nth-last-of-type(1) {background-image: var(--back-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.level1 {break-before: avoid;page: chapter;}.front-matter-container .level1 {page: frontmatter;}.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {break-before: avoid;break-after: avoid;}.footenotes {break-before: always;break-after: always;}.figure {break-inside: avoid;}.main .level1:first-child h1 {counter-reset: page 1;}caption {break-inside: avoid;break-after: avoid;}</style>
<style type="text/css">:root {--background: whitesmoke;--pagedjs-width: 6in;--pagedjs-height: 9in;--color-paper: white;--color-mbox: rgba(0, 0, 0, 0.2);--running-title-width: 2.5in;--screen-pages-spacing: 5mm;}html {line-height: 1.3;}.abstract {border-width: 0.5px 0;border-style: solid;margin-top: 0px;margin-bottom: 2px;font-size: 12px;}a[href^="http"]:not([class="uri"])::after {content: " (" attr(href) ")";font-size: 90%;hyphens: none;word-break: break-all;}.references a[href^=http]:not([class=uri])::after {content: none;}.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page) ")";}.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page, lower-roman) ")";}.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: unset;}h1 {font-weight: bold;font-size: 23px;}h2 {font-weight: bold;font-size: 20px;}p {font-size: 12px;}.sourceCode {font-size: 10px;}.toc ul, .lot ul, .lof ul {list-style: none;padding-left: 0;overflow-x: hidden;}.toc li li {padding-left: 1em;}.toc a, .lot a, .lof a {text-decoration: none;background: white;padding-right: .33em;font-size: 11px;}.toc a::after, .lot a::after, .lof a::after {content: target-counter(attr(href), page);float: right;background: white;}.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {content: target-counter(attr(href), page, lower-roman);}.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {float: left;width: 0;white-space: nowrap;content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";}.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {content: var(--chapter-name-before, "Chapter ");}.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {content: var(--chapter-name-after, "");}.subtitle span {font-size: .9em;}img {max-width: 100%;}pre {padding: 1em;white-space: pre-wrap;}pre[class] {background: #f9f9f9;}abbr {text-decoration: none;}@media screen {div.sourceCode {overflow: visible !important;}a.sourceLine::before {text-decoration: unset !important;}}pre.numberSource a.sourceLine {left: 0 !important;text-indent: -5em}pre.numberSource {margin-left: 0 !important;}table {margin: auto;border-top: 1px solid #666;border-bottom: 1px solid #666;}table thead th {border-bottom: 1px solid #ddd;}thead, tfoot, tr:nth-child(even) {background: #eee;}.kable_wrapper > tbody > tr > td {vertical-align: top;}.footnotes {font-size: 90%;}.footnotes hr::before {content: "Footnotes:";}.footnotes hr {border: none;}.footnote-break {width: 1in;}body {hyphens: auto;}code {hyphens: none;}@media screen {body {background-color: var(--background);margin: var(--screen-pages-spacing) auto 0 auto;}.pagedjs_pages {display: flex;max-width: calc(var(--pagedjs-width) * 2);flex: 0;flex-wrap: wrap;margin: 0 auto;}.pagedjs_page {background-color: var(--color-paper);box-shadow: 0 0 0 1px var(--color-mbox);flex-shrink: 0;flex-grow: 0;margin: auto auto var(--screen-pages-spacing) auto;}}@media screen and (min-width: 12.32in) {.pagedjs_page {margin: auto 0 var(--screen-pages-spacing) 0;}.pagedjs_first_page {margin-left: var(--pagedjs-width);}}@media screen and (max-width:1180px) {body {width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));}}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Baby Name Analysis</h1>
<h5 class="author">Matt Kruger - 25113186</h5>
<h5 class="date">2025-06-18</h5>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#persistence-of-names" id="toc-persistence-of-names">Persistence of Names</a></li>
<li><a href="#influence-of-popular-figures-on-naming-conventions" id="toc-influence-of-popular-figures-on-naming-conventions">Influence of Popular Figures on Naming Conventions</a></li>
</ul>
</div>
</div>

<div class="main">
<div class="page-break-after"></div>
<div id="introduction" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>In this research paper I will conduct analysis on baby names in the United States. I analyse the persistence of names over the last century, as well as how famous figures in pop-culture influence naming conventions of the time.</p>
</div>
<div id="persistence-of-names" class="section level1 unnumbered">
<h1>Persistence of Names</h1>
<ul>
<li><p>I analyse name persistence by looking at the correlation between the ranking of the most popular names in a given period and the rankings of the most popular names three years later.</p></li>
<li><p>I investigate name persistence for the entirety of the United States, as well as for just New York, given that the toy design agency is based there.</p></li>
</ul>
<!-- The following is a code chunk. It must have its own unique name (after the r), or no name. After the comma follows commands for R which are self-explanatory. By default, the code and messages will not be printed in your pdf, just the output: -->
<p><img role="img" src="data:image/png;base64,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qu7duxuL5z0tR8AJ3AOPjY294YYb5s+fn52d/Yc//MH40qZNm2qu104N7TdwT0T79u2NxV27dnm+7rBhwwYNGjR58uSZM2c65+0I3LcCAAAA54d+sgAAALVZWFjYokWLrrjiCmfN7t2733jjDU/W/eSTT4zFf/3rX+3atfNkRZfOGVUfjL7mXHnllcbif//73wEDBni4rtVqbd++fbt27bp06dKhQ4c2bdpcd911gTLSvb8duMVi2bJly549ezZv3rx27dp777337rvvrniVyMjIWbNm/fbbb7t373ZWpqSkxMbG+v9+nfztRHjukksuMRYXLFgwatQoT1YsKir6+uuvJa1YsULS4MGDr7rqKgXyWwEAAIDzQ3ICAACgluvXr9+ECRNmzZrlrHnsscfi4uIqXXHlypXG4tChQz3c4/z5841Fl1Ge/Erfvn2Nxffff//VV1/1cOj8//3vf0lJSUlJScuXL5fUvXv3LVu21EiUNcDfDjwvL69Xr17OYmhoaKVJAkkmk+nOO+986qmnnDUFBQV+sl+XO+Pl9R/ytxPhubZt20ZGRubl5TmKCxYsyM3N9STydevWGYtjx451LATuWwEAAIDzw7BOAAAAtd8777xTr149Y43LyEtuOW87OoSGhnqyr8OHD8+dO9dYk5OT48mKPhEdHT1y5Ehn0Waz/eUvf/FkxaKiIpf5PJ577rlqDq4m+duBx8TE9OzZ01lcsWLFiRMnPFnRpVmjRo38ZL8ukzmXl6LztxPhObPZPHHiRGfRarW+9dZbnqw4depUY9GZ9QzctwIAAADnh+QEAABA7RcREbFw4cJzXatLly7G4vr16ytdJTc3d9CgQS6VWVlZ57prb3rhhReMxQ8++OCLL76oeBW73T5x4sTjx487a+rUqTNs2LAaia/G+NuBP/roo8bivffeW+lsJbm5uTNnzjQG07RpUz/Zb0REhLGYnp5e3tb87UR4btKkScbi1KlTt2/fXvEqX3zxhXOSCUk33XSTMa8TuG8FAAAAzgPJCQAAgAvCwIEDncOneGj48OHG4n333Zebm1tB+4MHDyYkJOzbt8+lPjs7+5z262UdO3b84x//aKy5/fbbX3rpJYvF4ra91Wr9y1/+8uGHHxorP/nkk5CQkBqMsgb424GPHj3aOIbPV199NXHixPKCkVRQUHD99dcbx1OaNm1aUNA5/8Cpof02aNDAWDSOq+bC306E55o0afLEE08Yay699FLHwEpuffXVV7fffrux5s033zQWA/etAAAAwHkgOQEAAHCheP/99+vUqeN5+wceeMBYPHLkSLdu3dasWWOz2Yz1Nptt165dEydObNOmjctU2A4nT548v4C95u233+7QoYOxZtq0aa1bt/7oo49SUlIcN0ZtNtvJkyc/++yzVq1audxRHTly5E033eTViKuJXx14eHj4+++/b6z597//3axZs9mzZ6ekpDiHRSoqKjp8+PD777/ftGnTn376ydm4QYMGjzzyiP/s1yU5MXfu3Ouvv3727NmLFi1avHhxYWGh8VW/OhHn5IUXXjB2sSoqKhoyZMjQoUPXrFnj7DKVm5v722+/XX/99TfeeKNx3TfffLNNmzYuGwzctwIAAADnigmxAQAALhTR0dFffPHFkCFDPGzfokWLadOmTZ8+3Vlz8ODB/v37h4aG9u7du02bNhaLJSkpaf369Var1bjis88+u3fv3k8//dS5lt1ud5kf2K+EhoauXbu2V69exuRKcnLyfffdV+m6V1555bx582oyuhrkbwc+bty4FStW/Oc//3HWpKWl/eEPf6h0xZCQkDVr1riMpOTb/TZp0sRsNhsvjWXLli1btsyxvGXLlu7duztf8rcT4bng4OA1a9ZccsklSUlJzspvv/3222+/rXjFu+66y21SJ3DfCgAAAJwrek4AAABcQAYPHmyccrZSzz//fNn2RUVFa9asmTNnzrx589auXWu8/dqhQ4ctW7Y888wz1113nXGVlJSUqoTtBXXr1t2+ffsdd9xxTmuNHz9+1apVLlMfBxZ/O/APP/zQk9vQRk2aNNm1a5fL4/Y+36/ZbDYm9lyUHf3M306E5xyR33zzzZ6v8vTTT8+ePbu8hGXgvhUAAAA4JyQnAAAALiwfffRRZGSkh42DgoLmz58/b9682NjYils2adJk3rx5O3bscDwP3r9/f+Or5zEdt/eFhYV9+umniYmJl19+eaWN+/Xrt3HjxlmzZtWCm6F+deBms3nmzJm//fZbnz59Km0cGRk5Y8aMw4cPt23b1g/3O2XKlAcffNDtS24njvarE3FOIiIilixZsnLlyosvvrjilv369du3b9/zzz9fcVeqwH0rAAAA4Dn+egMAALiwxMTEfPbZZ54/5mwymcaMGTNixIj1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atGTFUeiZfNyWrLXByKdJlfqdqtrYh+mPuFXcH4DABCD1cOJm2++OVwtUVFR8dxzzzU1NbW2tm7fvn3nzp2dnZ0nTpx47rnnKisrRWTv3r3/9E//NJDHcjgcs2bNCm9//PHH8Q57//33wxszZsxI/s4LCwsjnZ327dsX77D29vZIZUaC7k8AAABAAhaunNAvppzTVbAVj0s8yhX+DPhNHW8knAj45e9r/77+zXXr1q1bt+7IkSNHlMqJKhvMDjgFeLNltHK+YmsS4UR5RqPoDRs2rOsW7ncNALAmS4cTe/fu/f3vfy8iM2fO3L9//5VXXhmZWR1WXFx85ZVX7tu37/zzzxeRVatW7dq1ayCPGAknXnzxxZgHBIPBP//5z+HtPoUTIjJv3rzwxrPPPhvvmLfffju8MWHChOR7RgEAAACqkHrO9ER7ZDi2+dQuH9luKeREI+xmmPKedESxeesYbKJtnYJ+2fDiprWr16xZs2bNmgMHDujaOvEu2SKmKMUTO45JINarjPqEn9k6uddee21Nt48++iiTDw0A6BNLhxPhZMLpdL7yyis5OTnxDsvOzl6zZk14iu9TTz01kEc866yzwjOut2/fvmnTpp4HrFixIjyKedKkSWqnpmR84QtfCG9s3rx53bp1PQ9oamp69NFHw9tLlizp050DAAAAEVqZvttMg2WKJwwX0tI8Hraz9NPidIiIVBTIvHFmr2bwcDkkXylK8XdPgQxoclytnCCcsIgpytgJX0B21xkP0PRP+DTxAwDEYulw4rXXXhORa6+9ttcGR16vd9myZSKyZs2agTyiy+UK34+I/OhHP/rrX/8amYzt9/uXL1/+pz/9Kbx766239vz0//qv/1q8ePHixYvvuOOOmIu85pprwtu/+MUvVq5cqY683r179y233BJOPsaNG3fWWWcN5AsBAADAqSxk6DZT12bSQnow70JaIDW+MF6euFJ+skB+v0SKaeuUSurYic7ucOJEQJdhnka1lUVMq9Lt9uzsdNIn/mB0dwhN/AAAMbh7P8Q827ZtE5HzzjsvmYNnz57961//eufOnQN80Llz577zzjvvvfeeiPznf/7nb3/727POOqujo2Pz5s2hUFeh4rJly4YNG9bzc4PBYDAYFJHIkQZXXHHF/v37N2zYICLLly9fvnz5tGnTiouLt2/fXlfXdaGB1+u99957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wCbyssSjvAtoTGejMHUgNtOwAQAAACisHk4sXbr0tddeE5FNmzZFbnz11Vc3bNgQ3j7//PPHjx8vIn6/f/bs2RReAQAAAIk4RIpyo7uN6eyq3B7t+SA5hBMAAAAAoiwdTlRXV69evVpEhg8f/pvf/CZy+0MPPRTeWLNmzYYNG3bu3Ll8+XIROXz48KuvvmrKUgEAAADbKFY6OzWltXJCCSeonAAAAACgsHQ48fzzz4tIVlbWtm3bLrroovCNLS0t69evF5HKysovfvGL4Ruvu+666dOni8iqVavMWSsAAABgFxmrnPDR1gkAAABAbJYOJ8K9m6666qqioqLIjf/7v/8b3rj55pvVGUdf/epXReSNN97I7BoBAAAAuzGncsKdxgcCAAAAYDeWDieqq6tF5LzzzlNvDJdTiEikbCJsxIgRInLgwIFMrQ4AAACwJ1NmTlA5AQAAAEBh6XCis7NTRFwuV+SWUCj0P//zP+HtKVOmqAe3tLSISF5eXgYXCAAAANhQsRJONPlES9sDEU4AAAAAiMPS4cS4ceNE5OOPP47csnfv3ra2NhGZP39+dna2enB4EMWECRMyukQAAADAdtS2Tv6gLkJILfWecwgnAAAAAERZOpy4+OKLReTJJ58MBoPhW5588snwxo033qgeefz48aeeekpE5s2bl9k1AgAAAHZTlKPbTV9nJwZiAwAAAIjD0uHE1VdfLSKHDx9evHjx1q1bly9ffv/994c/FAkhNE374IMPPvOZz4R3ly5daspSAQAAANtQ2zpJOmdi09YJAAAAQBxusxeQyNSpUxctWrRq1arVq1evXr06cvt9991XWFgY3p42bdrWrVvD24sXL540aZIJCwUAAABsJDOVEyFNOtTKCUu/9QAAAACQYZaunBCRF154wVAMceONN95zzz2R3ciQiSuvvPLZZ5/N6OIAAAAAO8pM5YTa00monAAAAACgY/XLlzwezzPPPPPQQw9t2bLF4XBMnz69srJSPeD888/Pz8+/5ZZbIp2dAAAAACTizdbtpqlywjBnm3ACAAAAgMLq4UTY8OHDhw8fHvNDt956a4YXAwAAANibyynebGnu6NpNU+WEIZzIscdbDwDmcrvd5513XmR36NChJi4GNnXOOef4/V2vQaeffrqpawEAJMI7BAAAAODUU5QbDSfSVDnho3ICQJ9lZWUtXrw4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333t2rUhhBtvvHGbbbbJZY8BAKCwFMXCgMjMTp0zcsK0TgAAQBvy/UdMJ5544jvvvHP55ZeHEB577LHHHnssddeoUaOiLU877bTzzjuvu/sHAACFbmBFWPvvAROdMnIiuiB2USz0yveLDgAAoPvl9ciJpMsuu2zOnDm77rpraw0GDRr00EMP/fKXv4zFYq21AQAAWtalIyfKS4IP6QAAQDOF8SOm/fbb75133vnnP//51FNP/eMf/3j//ffr6+u33377CRMmHHzwwXvvvXdRUQGkLAAAkI8GRtbE7pw1JyILYpvTCQAAaElhhBMhhFgstvPOO++888657ggAAPQs0ZET6zp75IRwAgAAaIkBBwAAsHUb2KXTOgknAACAFuTpyInVq1e/9tpr//znP/v06bPnnnvutddexcXFue4UAAD0RNFpnarrQk19KMvuMsHICQAAoC15F06sXbv21FNPffDBB6M39uvX75ZbbvnqV79qyWsAAOhk0WmdQgjrq8N2fbPaYLU1JwAAgDbkVzixZMmSvffee+3atU1u37hx4ymnnHL//ff/6U9/svY1AAB0pujIiRDCus3ZhhONRk7k1xUHkOdqamruvvvuVHXq1Kl77bVXDvtDIbrnnntqa2uT5X333ffAAw/MbX8AaE0eXSokEokjjzwylUyMGzfu6KOP3rRp05///Odly5aFEO69995f//rXX//613PaTQAA6FkGNA4nsl92wrROQEc1NDTMnTs3VR0/fnwOO0OBeu2116qqqpLloUOH5rYzAKSRR6MQXn311XfeeSeEMGjQoDfffPMf//jHj370o1tvvXXp0qW33XZbss25557b0NCQ024CAEDPMrDxtE7rOjWcsCA2AADQkjwKJ/74xz8mCw8//PDYsWNTt8disTPPPPOMM84IIVRXV7/55pu56R8AAPRITdacWLc52w0aOQEAALQlj8KJ559/PoQwZMiQAw44oPm9//3f/50szJs3r1u7BQAAPVtpcegdiRCyn9bJgtgAAEBb8iicWLx4cQihtaWuRo8enSy8++673dcnAADYGkTXxM5y5EQ8EWqi4UQerXIHAADkjzwKJ1atWhVCGDJkSIv3lpd/Mth8yZIl3dcnAADYGkTDiSxHTkTndApGTgAAAC3Lo3CitrY2hFBS0upPq4qLi1PNAACAThNddiLLkRPROZ2C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VK672X02btw4ePDgZHnGjBl/+MMfctufnkc4AQAAtF/zNbGFEwAAhemdd9654YYbfvnLXzY0NDS5q7a2dt68efPmzZs1a1YIYcyYMddff/306dOLiraKKXnq6uqShfr6+tz2pEfaKvYhAACgkwknAAAK34YNG774xS/uscceP//5z5snE829++67M2bMGDdu3OLFi7uhe/RsRk4AAADt1zycKHdxAQBQSF599dUpU6Zs2LCh+V1jxozZbbfdevfuvWHDhhdffLFJm7fffnvnnXd+8cUX99tvv+7qLD2Q6wcAAKD9hho5AXS+WCyWmt07hFBeXp7DzlCgBg0aVFFRkSz36dMnt52BfPbyyy/vv//+8Xg8dUufPn0uv/zy4447bqeddmoya9O6deueffbZb3/72wsWLEjeEo/H999//3fffXfnnXfu1n7TgwgnAACA9hvWt+ktwgkgaxUVFZdeemmq2rdvs0MNtOWiiy5KJBLJcu/evXPbGchby5YtO+CAA6LJxAUXXHDNNdeUlZW12H7gwIH/5//8n89//vO/+c1vTjvttOQD4/H45z//+fnz528l60/Q6ew3AABA+/UtC316NbpFOAEAUAji8fi0adOiK0w89dRTN9xwQ2vJREosFjvllFNeeOGF1C0LFix46KGHuqqj9HTCCQAAoEO2bzyzk3ACAKAQ/PGPf3z11VdT1fvuu2/KlCmZP3zy5MnXXHNNqvqtb32rE/vGVkU4AQAAdMhQ4QQAQIGJx+P/9V//lap+6UtfOvbYY9u7kf/6r/8qLi5OlhctWvThhx92Wv/YmggnAACADhkWCSeKYqG0OHddAQAgIy+99NKKFStS1VtvvbUDG6moqLjkkktS1Uxmdnrvvfd+9KMfHXvssdtvv31FRcXQoUM///nPX3311W+99VZqnZjWJBKJXv/229/+NnXj3Llzv/Wtb02YMKFv374DBgw4+OCDL7vssrlz57a5wZTVq1ffcccd06dPHz58eEVFxQ477PCVr3xl1qxZ69aty3ALnfUy6+vrU6/xz3/+cwihrq7u9ttv33///SsqKnbZZZfzzz//+eefjy4T0gNYEBsAAOiQPbbbUt5pmxDLXU8AAMjMbbfdliqfcMIJgwcP7th2TjnllGefffbkk08+4ogjRo8enablggULTjrppPnz50dvrK6ufvjhhx9++OHvfve7Y8aM+eMf/7jPPvuk2UhdXV2ykPx2funSpV/4whfmzZsXbTN79uzZs2f/4Ac/GDdu3COPPLLDDjuk2eDmzZsvuuiiJtnMkiVL7r777rvvvvv000+/4oorzjjjjDRb6PSXmXqNiURi06ZNkyZNevvtt5O3vP/++zfddNNNN9303HPPHXTQQZn3Ks8ZOQEAAHTI1F3CxBEhhNC7NJzx6Vz3BgCANiQSid///vep6n/+5392eFO77777M888c+aZZ44ZM6aoqOUvmROJxFVXXTVu3LgmX9k38e67706cOPE73/lOhiMeFixYMHr06CbJRNSbb7650047LViwoLUGy5cv32OPPdKPGrn88sv322+/TPrT6S9zxYoVBx98cCqZSBk1atSBBx6YSZcKhZETAABAh5QWhxumh2UbQv+y0Lcs170BAKANS5cura2tTVUnTZrUpU93ySWXXH/99anqPvvsc955533qU58aOHDgpk2b3nzzzVtuueXZZ59N3nvttddWVVXdeOON6bf5/PPPn3322clX0a9fv//4j//YZ599SktL58yZ87vf/S41HVM8Hj/mmGM++OCD5sFJVVXVpEmTlixZkrrla1/72n/8x3/stNNO1dXV8+bN+8EPfrBo0aIQwtKlS3PyMs8777zkC/zKV75y7rnnDhs2bOHChb/85S+PO+64WKxHjVYWTgAAAB0VC2F4/1x3AgCAjLz//vupcnl5+aBBg7ruuf7+97+nvrLv3bv3Qw89NHXq1GiDvfba68QTT5wzZ87RRx+9du3aEMJPf/rT448//pBDDkmz2eS0VMXFxbNmzTr55JNT63KfeuqpN95446WXXpp60sWLF8+ePbv51s4777xUMjFs2LC///3vu+22W+resWPHfvWrX73pppuiy4Z388tMJhO/+MUvUkNbRo8effTRR2fSn8JiWicAAAAAgJ4vOlwg+o18p6urqzvhhBOS5aKiotdee63JV/YpkydPnj9/fipjOP744xsaGtrc/rx580455ZTUo5JKSkp++MMffvGLX0zdcu+99zZ54OLFi2fNmpUs9+rV69VXX23+PsRisfPPP//2229vsxtd9zKnTJly+umnt9mBQiecAAAAAADo+VauXJkqb7/99l33RE899dSKFSuS5R/+8Ie77rprmsYjRoy46qqrkuUVK1a8/PLL6Td+9tlnT5gwocW7YrHYd7/73VS1+SIQd9xxR6p87bXXDhs2rLVnOeOMM/bYY4/0Pem6l/n//X//Xw+bwalFwgkAAAAAgJ4v+mv9TL77fuyxx0pKSoqLi2NtWbNmTfSBN998c6p86qmntvlEJ510UqqcGtnQmjPPPDPNvTvvvHOqnEoOUqLjIb72ta+l2U4sFvvhD3+Yvidd9zInTpzY5tZ6AGtOAAAAAAD0fP37b1ktLDqKojWJRCKTSZaaP+rBBx9MlouKimpra5ctW5b+IXV1dany008/nb5x+gmpoq+xsrIyete6detSccXo0aPbXHLj4IMPTnNvl77MwYMHp99UzyCcAAAAAPJCdXX1DTfckKoee+yxkydPzmF/KES33HJLdXV1snzYYYcdddRRue0P5JVRo0alygsXLuyiZ1m3bl2qHI/HR44c2a6HL1q0qKGhocl6EimlpaUVFRVpHl5UtGWuoCbJyuLFi1Pl/fffv82eDBo0qKioKB6Pt3hv173M7bbbrqRkq/jefqt4kQAAAED+i8fjS5cuTVWrqqpy2BkK1LJly1J7zvr163PbGcg30XBi48aNmzZt6tOnT5r222+/fXQmoiZ+//vft3j78uXLO9zDpOrq6tY6NmTIkA5vdtWqValy+vUhkmKx2B577LFgwYIW7+26l7nttttmueVCIZwAAAAAAOj5dtlll2j17bff3nfffdO0nzBhwt13393avf/7v/8bnacoJTV6qcNaG6wQQigtLe3wZjdv3pwqpx9+kZJmeqWue5nZvMbCYkFsAAAAAICer7S0dMqUKanqXXfd1RXPEp2qaMaMGYn269evX1d0rLy8PFXetGlTJg+pr69v7a68fZkFRDgBAAAAALBVuOCCC1Lln/3sZ9HBBJ0lOtrg5Zdf7vTtd9h2222XKi9atCiTh6RZmSNvX2YBEU4AAAAAAGwVjjrqqF69eiXLtbW1V1xxRac/RTQDWLJkSYZjFLrBDjvskCo/99xzbbavra1dvXp1a/fm7cssIMIJAAAAAICtQllZ2fXXX5+q/vCHP3z66ac79ylKSkrGjx+fqj7++ONtPmTx4sU77bTT9OnTL7nkkt/85jed25+UgQMHjhgxIllesmTJxx9/nL7966+/nubevH2ZBUQ4AQAAAACwtTjnnHP22GOPVHXq1KlPPfVUu7bQ0NBwww03tLgadtJFF10ULadZuSHp8ssv//DDDx988MHrrruuS6dI+u///u9U+Sc/+Un6xtdcc036Bnn7MguFcAIAAAAAYGtRUlLyxBNPlJaWpm45/PDDL7zwwqqqqjYfG4/Hn3jiiZ122in6vXxzM2bMSG3/gw8++O53v5um8fPPP//rX/86Vb3wwgvb7EaHff3rX0+Vr7vuugULFrTW8rnnnrvvvvvSby1vX2ahEE4AAAAAAGxFRowY8corr6QWnwgh/OQnPxk4cOBFF130+uuv19bWNmkfj8c/+OCDm266aeTIkZ/5zGeWLFmSuquoqOjOO+/cZpttou379+9/2223parXXXfdOeec03yzIYSXXnppypQpqepZZ5210047ZfXa0tpmm22is1rtu+++zzzzTPNmjz/+eLRXrcnbl1kohBMAAAAAAFuXvfba66233tp5551Tt9TV1d1www2f+tSnysrKdtttty984QunnXbaCSecMHHixNLS0tGjR59//vnLli2LbuTTn/704sWLTznllObb/9rXvjZt2rRU9dZbb912222vvfbal19+ecmSJe+9994jjzwybdq0/fffPzU91O67797mVEvZu/DCC4844ohkubq6+rDDDjvmmGMef/zxDz/88IMPPnjkkUeOPPLIo446qqGhIZOt5e3LLAglue4AAAAAAADdbfTo0e+8887MmTOvvvrqJnctWrRo0aJFaR47cuTI22+//ZhjjonFYi02KCoquv/++0899dTf/e53yVs2bNjwne98p7UN7rHHHi+++GJ5eXk7X0S7FRUVPfzww9OnT08tYf3oo48++uijzVueddZZTzzxxLvvvpt+a/n5MguCkRMAAAAAAFuj0tLSq666atWqVddcc82QIUMyecihhx7617/+9cMPP/zc5z7XWjKRVFJS8tvf/vbpp58eMWJEmmbFxcVXXXXVG2+8MWDAgPb1vqPKysoeeeSRm2++ObrwRhM333zzz372s+jMV63J25eZ/4ycAAAAAADYeg0ePPjb3/72JZdc8t57782ZM+fpp59+++2333rrrTVr1hQXF48cOXK33XY78MADDz744P32269fv37t2vhhhx320UcfvfXWW3/+859feumll156aeXKlaWlpXvuuee+++577LHHTpkypU+fPl300lpTVFR07rnnnn766Q899NCf/vSn559//l//+tegQYMOPfTQo4466itf+UrPeJl5TjgBAAAAALC1i8ViY8aMGTNmzFe+8pVO3/LYsWPHjh3b4YcnEomuaFxeXn788ccff/zxrTV48803M9xUyO5llpSUZN7tHsO0TgAAAAAAQLcSTgAAAAAAAN1KOAEAAAAAAHQr4QQAAAAAANCthBMAAAAAAEC3Ek4AAAAAAADdSjgBAAAAAAB0K+EEAAAAAADQrYQTAAAAAABAtxJOAAAAAAAA3Uo4AQAAAAAAdCvhBAAAAAAA0K2EEwAAAAAAQLcSTgAAAAAAAN2qJNcdoMu9//77n/3sZ3Pdi06WSCQSiUSqWlQkZstWPB4P3snOEN05Y7FYLBbLbX/Ic8l/PbsK6Tnr0S7JHcaBhTYlz0FJdpjspY7VjtJZSiQSGzZsSFVnzpzZq1evHPYnP9nf0tuwYUPqs9MHH3xwxx135LY/mSi4v2nPPolEP3sDXUo40fPF4/E1a9bkuhcAAADQPpWVlbnuAoWtqqqqqqoq170AoGUxYWAP9q9//eudd97JdS+6xOzZsxcuXJgsDxgw4Itf/GJu+9MD1NfXhxCKi4t72O8dut9f/vKX5cuXJ8s77LDDkUcemdv+kOf865GJDz744Omnn05Vv/SlL/Xt2zd33SHfxePxeDwei8WKi4tz3Rfy2t13311dXZ0sjx8/ftKkSbntT6Hzr9dZqqqqfvWrX6WqBx988IQJE3LYn/xkf0vv5z//eV1dXbI8fvz4Qw89NLf9yURh/U2rq6vvvvvuVPWQQw4ZM2ZMDvvTdSZPntynT59c9wJ6MiMnerLhw4cPHz48173oEi+88MKCBQuS5VGjRk2dOjW3/YGUu+++O7VzDh482M4JZK+hoSF1YAkhTJ48eejQoTnsD9AzXHXVVevWrUuWJ0+e7EMLeWLDhg2XX355qnrKKafYOWmv73//+xs3bkyWDz/8cLtQp1u3bt33vve9VPXEE0/0JgMdUxgz2QEAAAAAAD2GcAIAAAAAAOhWwgkAAAAAAKBbCScAAAAAAIBuJZwAAAAAAAC6lXACAAAAAADoVsIJAAAAAACgWwknAAAAAACAbiWcAAAAAAAAulVJrjsAHbHTTjtNnjw5Wd5uu+1y2xmI2nPPPUtKPjm07rrrrrntDNAzbLPNNqmzXgihtLQ0h50BeoyJEydWVlYmyyNHjsxtZyClpKQketYbMmRIDjtDgZo4ceLmzZuTZce3rtDk/3Tw4ME57AxQ0GKJRCLXfQAAAAAAALYipnUCAAAAAAC6lXACAAAAAADoVsIJAAAAAACgWwknAAAAAACAbiWcAAAAAAAAupVwAgAAAAAA6FbCCQAAAAAAoFsJJwAAAAAAgG5VkusO0PMlEomLL774vffeu+qqq8adnH0LAAAgAElEQVSOHdtm44ULF/7tb397/fXXV61a1b9//7Fjxx522GETJ04sLi7u0qcOIaxcufLJJ5+cM2fOkiVLiouL99xzz09/+tOHHHJI79692/vUFIRu2zkTicS777777LPPLliw4KOPPorH4yNGjBg3btxhhx226667xmKxNI994oknbrnlljZfy3XXXbfrrru22Qzoat12YMn+4OCsBwWkS48ty5YtO+ecc9rVn2uvvXb33XdvcqMPLVuh9l5wZfmJOstLRSe+PJHNxVHI7u+YzWPj8fjrr7/+97//fcGCBWvWrBkwYMCkSZMmT578qU99qgNfVnSDHL7PzXvSrgNFxx4CFCjhBF3uySefXLhwYQghkUikb7l27dof/OAH7777buqWVatWPfPMM88880y/fv2+/e1vjx8/voueOpFI3Hnnnffee2/0xrlz586dO/fWW2+99NJLJ0+e3K6npiB0z865YsWKq6+++v3334/e+P7777///vsPPvjgTjvt9D//8z/bbbddaw+fP39+Q0NDpi8JyLVuO+tlc3Bw1oOC06XHlkQi0d7jSYvd8KFlK5T5nhmyO/FledJ04ssf2VwcZfN3zHIf+Oijj2bOnLly5crULStXrnzkkUceeeSRfv36XXbZZc3z2tzK1fvconYdKDr8EKBAmdaJrrV06dKf/vSnmbT817/+dcYZZ6Q+bpaVlU2cOHHixIm9evUKIWzcuPG73/3uY4891hVPnUgkbrrpptSpt6KiYvLkyePGjUtW4/H4lVde+fTTT2f+1BSE7tk5ly5d+o1vfCP1obB///6TJk2aNGlS3759k7f885//PPPMM5cuXdras7/yyiuZvyggt7rzrNfhg4OzHhScHH6ibs2gQYOa3+hDy9Ym8z0zZLdzZrljO/Hlj2wujrL5O2a5D3z44YfnnntuKpkYPnz4AQccsMceeySrGzduvPjii+fNm5fhm9ANcvU+t9aZzA8UHX4IULiMnKALrV69+qKLLsqkZV1d3SWXXFJbWxtCKC4u/ta3vnXggQcmhxnG4/G//e1vyTPTLbfcMmrUqD333LMTnzqE8OKLLz7xxBPJ8iWXXJJ66pqaml/96ld/+ctfQgg33HDD2LFj0/y8ncLSPTtnXV3dpZdeGo/HQwjDhw//zne+s+OOOybvSiQSixYtuuaaa1avXt3Q0HDppZfecccdpaWlTZ69urp6/fr1IYQ+ffr87ne/a3PsLZBD3XnWy+bg4KwHhaUbji3Dhw9/4IEH0m988+bNZ5111tq1a0MIF1544dChQ5s08KFla9OuC64sP1FnedJ04ssTWV4cZfN3zOaxdXV13/72t5PlPffc8+KLLx4yZEiyWl1dffvttz/55JMhhO9///t33XVXv379OuOtykoO3+fm2nWg6PBDgIJm5ARd5cMPPzznnHOqqqoyafznP/85eTETi8Vuvvnmgw46KHU9U1RUdOSRR1511VXJ6tVXX93maPF2PXVDQ0Mqk585c2b0qcvKys4666xjjz02Wf3FL36RyQbJf922cz777LPJa/jBgwffeOONqQ+Fya3ttttuN998c0VFRQhh7dq1f//735s/+8cff5ws7Lfffi7yIZ9181mvwwcHZz0oLDn8RB2VSCSuvfba5KeaI488csqUKc3b+NCyVWnXnhmy2zmz3LGd+PJHNhdH2fwds9wH/vrXv27atCmEsP3221911VWpZCKEUF5efv7550+aNCmEkEgkHnrooXa/KV0gV+9zc+09UHTsIUChE07Q+RKJxP3333/eeedt3rw5hFBeXt5m+3vuuSdZ/sY3vjFixIjmbcaPH3/ooYeGENavX//yyy931lOHEF599dXkR43Ro0dPnDixeYNTTz01OV74pZdeSn4spnB18875pz/9KVk477zzysrKmj+2T58+Z599drLc4mfZ1FDcT33qU+m7CuRKTs56HT44OOtBocjhJ+rmnn322VdffTWEMGDAgNRHlyZ8aNlKdOCCK5udM/sd24kvf2RzcZTN3zHLfSA1wdE555xTUtJ09pFYLHbqqacmy48//njzjXe/XL3PUR07ULT3IUDPIJygky1duvTiiy+eNWtWCCEWi1122WUHHHBA+oesXLkyFYwfccQRrTX7whe+kCykxhhm/9QhhOQYzBDCcccd12KD4uLiz33uc8nyCy+80OYGyVvdvHNWV1enJvHca6+9Wnvs3nvvnSy8//77zRf7+sc//pEs7Lrrrum7CuRErs56HT44OOtBQcjhJ+rmNm7c+JOf/CRZ/t73vtd8FsokH1q2Bh274Mpm58x+x3biyxNZXhxl83fM5rHxePy4446bOnXqkCFDWptfOjXN3erVq+vq6lp+Yd0lh+9zSgcOFB07tgA9g3CCztTQ0HD22WcvXLgwhLDtttvedtttyRGO6aXGgO+4445p4vHUz2Refvnl5t/hduypE4nESy+9lCynWcpiv/32SxZmz57d5jbJT92/c9bV1R122GFjxowZNGhQ8tclLYrelZwYNCr5K8UQwrBhw9rsLdDNcnjW69jBwVkPCkIOjy0t+vGPf5ycKuezn/3sbrvt1lozH1p6vI7tmSG7nTPLHduJL39kc3GUzd8xy32gqKjomGOOueCCC2bNmtVat2tqaqLtW3uK7pGr9zmlAweKDh9bgJ7Bgth0iRNPPPHEE09sPuaxRZWVlcnCqFGj0jRLDUhMJBKVlZWtrTTV3qeur69PlrfZZpvWmg0fPjxZmD9/fiabJZ91287Zr1+/TBbyWr58ebLQv3//4uLi6F01NTWrV69OPntRUdHcuXNnz5795ptvrlmzZtCgQePHjz/88MPHjRtnWmfIuW4+63X44OCsB4Ulh5+oU954441XXnklhFBcXPz1r3+9tWY+tGxV2rVnhux2zix3bCe+/JHNxVE2f8du2AdSD5kwYUKTC7rul6v3ubn2Hig69hCgB/A/TyebOnXqaaedNnDgwMwfkvooGf3FQXPRAZIbNmxofinVgadet25dsjBo0KA0v3FIPVc8Hq+vr3eyLFA53DnTeOSRR5KF/fffv8ldK1asSBY2btz45S9/ubq6OnXX8uXLly9f/sQTT4waNWrmzJnRZdmA7pSTA0uHDw7OelAo8uRDSzwev/HGG5PlM844o3fv3q219KFlK9GBPTNkt3NmuWM78RWcFi+Osvk7dvU+sGrVqptuuilZnjFjRoaPyrlOf5+jOnCg6NixBegZTOtEZyouLr7gggvae0bZbrvtkoUFCxakGV2+cuXKVDk18WiWT71hw4ZkYdttt03TLDq1bnJ1JgpODnfOND7++OPUsmnHHHNMk3vfe++9ZGHt2rXJi/xhw4YdcMAB48ePT30EXLx48RlnnPHRRx9l/qRAZ8nVgaXDBwdnPSgI+fOh5fnnn0+279Onz1FHHZWmpQ8tW4OO7Zkhu50zyx3bia+wtHZxlM3fsYv2gXg8vmrVqj/+8Y+nn356sv3hhx++zz77tPnAfNAV73NKBw4UHT62AD2DXwSQe6l5aSsrK997770xY8a02Oyvf/1rqhz9NVY2UqfSwYMHp2kWi8WKioqSUzFu3ry5Xb+Lp6B16c5ZV1c3c+bMZHny5Mm77LJLkwZvvfVWqnzcccd96UtfSv1iMR6Pz5s37/rrr6+urm5oaLj44ovvvPPO1C/L4P9n7z7joyrTPo7/Zya9QegJvTcpoShFEVDXuq64roLsLhYsYK+suo8itrWDrK6Kq66yduxlsYuigHQIEHovgRDS68x5XkwyCUJmJpkzNb/vhxf3Cadcmblz2nUXhDLfTywNPjlw1QMimOk3LYZhzJkzx1m+/PLL3Y9Vwk0L3PClcvpYsbnwhRE3D0e+fI/+qAMTJ04sKCiove3kyZPPO++8sBi5zk+fMwA0GD0nEHzR0dGnn366s/zYY4+Vl5cfu86ePXs+/PBD1+Kx8wY3jKt3sJupopxcT1BmHRphwX+V0263T58+fe/evZLi4uJuueWWY9dJS0sbNGhQSkrKtGnTJk2aVHssBavVOnTo0Oeff95ZdYuLi9988836/GYAgsb3E0uDTw5c9YAIZvpNy+rVq3NzcyXFxMSMGTPG/dG5aYEbvlROHys2F75w4f7hyJfv0fQ6YLfba2cmJDVt2tRqtbofeSxE+O9zBiKDw+GIqb/Vq1cHO/DwRnICIWHSpEnOVgb79++/6aabdu7c6fovwzCWLVt28803S3I957gZALFevG/a4FrTTW9iRCR/VM7Kysrp06c7JxCzWCyPPfZYYmLisatdcMEF06dPnzt37siRI4+7n2bNmk2dOtVZ/uijj1zTlwEIcT6eWBp8cuCqB0Q2c29a/vvf/zoLF110Ue1BPI6Lmxa450vl9GVbLnxhwePDkS/fo+l1oKSkJCUlZciQIUOGDHF2GsjNzX3hhRf+8pe/bNiwwctjBYVfP2cgYlTUX7BDDnsM64SQ0KRJk3vuuefBBx+UtGfPnuuvv75Fixa9e/cuLy9fu3ZtUVGRpMsvv3z//v3OiZvcTMdXL64HreO2wanN1YjA47MZIozplbO8vPzuu+/euHGjqm8KO3Xq1ODwTj755JkzZ0qy2+27d+/2ZVcAAiYAV73jnhy46gGRzcRzy+HDh11v2dzPNuE9bloaM18qpy/bcuELfd48HPnyPZpeB5KSkubOneta3LFjx2OPPbZr166ysrI777zz+eefT09Pd3+goPD35wwADUbPCYSKE0888ZFHHnHdSh46dOjHH39cvHhxUVGRxWK59dZbx40b55qgKT4+3pSDpqSkOAtHjhxxs5phGHa73VlmhNxGyMTKmZeXd8MNNzhvCqOiombNmtWzZ09fYouJiWnbtq2zzAyTQBjx91XvuCcHrnpAxDPr3LJgwQJnoXfv3qmpqabExk1LI+dL5Wzwtlz4QpyXD0e+fI/+rgMdO3acOXOmKyExa9Ys77cNmAB8zkDkWbJkieGd/v37BzvY8EbPCYSQvn37vvbaaz/99NMPP/ywZs0ah8PRo0ePUaNGnXrqqc7+ktu2bXOu2aRJE1OO6NrP4cOH3axWu5cWV9/GyZTKuWPHjjvvvNM5z1hCQsLMmTNdU/z5om3btnv27JFUWFjo+94ABIy/r3rHnhy46gGNgSnnls8++8xZOP/8802MjZuWRs6XytmwbbnwhTLvH458+R4DUAeio6Nvu+222267TdL69euLioqOO2ZvsATmcwYij81mC3YIjQXJCYSWmJiYsWPHjh079tj/stvtzombLBaLWcM6OW9kJWVnZxuGUdcYi64Jr6KiojzODYVI5WPlXLRo0cMPP+wsp6WlPfbYYx7fNtrt9vLy8srKSldFPS5Xp9q4uDiPvwWAkNKwE0uDTw5c9YBGwsebltzc3AMHDjjLGRkZ3hyRmxZ4yZfK2YBtufCFrHo9HPnyPQamDnTt2tVVPnjwYOgkJwL2OQNAgzGsE8LG7t27nYWMjAzvZ2pyLyEhwXnzahiGqyPwsZx3upLoq4Xj8lg5//e//7luCvv16zd79myPmYmVK1eOGzfukksumTJlivs1N2/e7CykpaXVL24AIayuE4svJweuegC8uaPOzMx0Fnr06OFNkyBuWmAKXx736tqWC19oqu/DkS/fY2DqgNVqdTWyDp3ZcQP5OQNAg5GcQEh49tln77rrrkmTJrmZeemrr75yFoYPH27WcS0Wy4gRI5xl5wiMx7Vs2TJnYejQoWYdGuHC98o5b9685557zlk+88wzH3jgAW8amLRv395ZyM/PdzPoZ25urnMawNqbAAhxvpxYfDk5cNUDIptZd9RLly51Fk499VRvjstNCzzypXL6si0XvhDUgIcjX75HH+tAdnb2Sy+9dM899zz66KNuIiwrK3NNw2DWPD0+CvDnDAANRnICISEnJyczMzM3N7euS2BJScmnn37qLJuYnJDkuvq+//77x13Bbre7Rt3l6tsI+Vg5v/322//85z/O8oQJE6677jqr1asTb7NmzZKSkpzlr7/+uq7VPvjgA2ehd+/eodN9GIB7vpxYfDw5cNUDIphZd9SLFi1yFvr27evNcblpgUe+VE4fKzYXvpDS4IcjX75HH+vAxx9/vGbNmoULF7qGMzrWr7/+6izExsY2a9bMzS8SGEH5nAGgYUhOICS4Rg599dVXDcP4zf86HI4nn3zS4XBIOvvss1NSUkw8dEZGhnMSp8zMTFczsdrmzp3rHB63b9++rVq1MvHQCAu+VM79+/fPnDnTWZ4wYcKECRO8P67FYpk4caKz/Prrrx86dOjYdbKysj788ENn+eqrr/Z+5wCCy5cTi48nB656QAQz5Y66tLS0uLjYWa5r0tTf4KYFHvlSOX2s2Fz4QocvD0e+fI++bNuyZUvXT5577rlja6Ck3NzcWbNmOcvjx4/3Mg3gP8H6nAGgYUhOICQMGzbMObjhxo0bn3vuudo9dnNzc++7774lS5ZISkxMvOyyy8w9tM1mu+aaa5zlGTNmfPvtt64bjoqKipdffnnevHnOxeuvv97cQyMsNLhyGobxxBNPOMsZGRnjx4+v76HPPPPMli1bOnd100031W4sZrfbv/zyyzvuuMO5OHbs2NqTsAEIcT5e9Xw5OXDVAyKYKXfUOTk5zkJUVFR8fLyXh+amBe75Ujl9rNhc+EKEjw9HvnyPvmxrsVhuuukmZ3nhwoUzZ84sLCys/UstW7ZsypQpzvf1bdq0+cMf/lCv38t0QfycEa6KyvXFhrD5tyUn2J8XzGc5buIXMNHTTz/93XffSXrkkUfc9A1ft27d3/72N2fZarUOHDgwJSUlKytr3759zh9GRUXNmjWrXgPUenlowzAeeugh502tpISEhIyMjLKysuXLlzvb4Ei65pprzj33XO8PjbDg18qZmZl51113OcsWi8WbFjRvv/32b0YC3b9//9SpUysrK52LLVq06NOnT2Fh4erVq10/HDBgwPTp010zsAEIrsBc9Xw5OXDVA8JRwO6oly5dOmPGDEl9+/Z95JFHvI+Qm5bGycuaKd8qp48VmwtfKPD94ciX79HHOvDOO+/MnTvXtdilS5eOHTsWFBSsXbu2tLTU+cOUlJTZs2cHfcKJ4H7OdfH+ROHLJmigvfma8N9gB+G1a4bp0gz/7d7hcLjuUmpPdF+XTz755Mwzz/RfPI0EPScQKvr06XP//fc7uxA6HI7ly5d///33rtvN9u3bP//8836aOs9isdx9990XXHCBc7G4uHjhwoVLly51XXqvu+46blUbs4ZVzm+++cZVNgzD7oVjD92mTZs5c+Z069bNuXjo0KEFCxYsX77c9ZB/8cUXz5gxg4d8IOz4eNXz5eTAVQ+IYL7fUe/Zs8dZ6NKlS70OzU0L3POlcvpYsbnwhQLfH458+R59rAMXX3zxtGnTXJ3Jtm7d+t133y1dutSVmRg1atSLL74Y9MyEgv05A5HE4XBUeEKLf1NEBTsAoEZGRsbrr7/+008//fDDD5s2bSotLU1PT+/Xr9+YMWN69uxpsVj8d2ir1XrFFVecf/758+fPX7Zs2bZt26Kiojp37jxy5MixY8cmJyf779AICw2onJs2bTLl0M2bN3/yySc3bdr0zTffrFmzZu/evbGxsb179x48ePDo0aOpnED48vGq58vJgaseEMF8PLe4Znxt0aJFfQ/NTQvc86Vy+lixufAFnSkPR758jz7WgZEjR5544onLly9fsGBBVlbWwYMH4+Pju3fvPmDAgFGjRoXO7AtB/5wBoL4Y1gkAAAAAAAAAGhmGdaql9rBOS5YsGTp0qP+OBRd6TgAAAAAAAABAI9MmWZ9eEewgvBYbuPfYDEQZMCQnAAAAAAAAAKCRsVqUHBvsINCoMSE2AAAAAAAAAAAIKJITAAAAAAAAAAAgoEhOAAAAAAAAAACAgCI5AQAAAAAAAAAAAorkBAAAAAAAAAAACCiSEwAAAAAAAAAAIKBITgAAAAAAAAAAgIAiOQEAAAAAAAAAAAKK5AQAAAAAAAAAAAgoi2EYwY4BAAAAAAAAAAA0IvScAAAAAAAAAAAAAUVyAgAAAAAAAAAABBTJCQAAAAAAAAAAEFAkJwAAAAAAAAAAQECRnAAAAAAAAAAAAAFFcgIAAAAAAAAAAAQUyQkAAAAAAAAAABBQJCcAAAAAAAAAAEBAkZwAAAAAAAAAAAABRXICAAAAAAAAAAAEFMkJAAAAAAAAAAAQUCQnAAAAAAAAAABAQJGcAAAAAAAAAAAAAUVyAgAAAAAAAAAABBTJCQAAAAAAAAAAEFAkJwAAAAAAAAAAQECRnAAAAAAAAAAAAAFFcgIAAAAAAAAAAAQUyQkAAAAAAAAAABBQJCcAAAAAAAAAAEBAkZwAAAAAAAAAAAABRXICAAAAAAAAAAAEFMkJAAAAAAAAAAAQUCQnAAAAAAAAAABAQJGcAAAAAAAAAAAAAUVyAgAAAAAAAAAABBTJCQAAAAAAAAAAEFAkJwAAAAAAAAAAQECRnAAAAAAAAAAAAAFFcgIAAAAAAAAAAAQUyQkAAAAAAAAAABBQJCcAAAAAAAAAAEBAkZwAAAAAAAAAAAABRXICAAAAAAAAAAAEFMkJAAAAAAAAAAAQUCQnAAAAAAAAAABAQJGcAAAAAAAAAAAAAUVyAgAAAAAAAAAABBTJCQAAAAAAAAAAEFBRwQ4AfrRx48Zffvkl2FH4hd1udzgczrLFYomKoib7xDCMyspKSVFRURaLJdjhhLfKykrDMJxlKic8qqiokGSz2axWmgugTg6Hw263uxY5V8M9520S1yB45LwGOVmtVpvNFsRgIoDzXM2fnu/sdvvGjRtdi23atElNTQ1iPKGJ+uZeVlaW641B8+bNW7VqFdx4vBFe36nrHYJTBD/OnH/++ZyCAL8Kg1MeGmzt2rWzZ88OdhQAAAAAAABAmDn55JNJTgB+RXIi8sXFxfXu3TvYUZiMnhOmczadozWu72r3nKARIjziTw/e+E3Piejo6CAGg9DnrDBcg+ARNy3mCq9Wz6HMbrdv3rzZtdimTZsmTZoEMZ7QRH1zb/Pmza57p2bNmrVs2TK48Xgj7L7T2t3vIq/nhN1uX716dbCjABqF8DjlwRft2rWbM2dOsKMwWWFhYWlpqbNss9nIY/vIMIycnBxJqampPJf6KC8vz3WXFhMTk5KSEtx4EOJycnIMw0hJSYmJiQl2LAhdZWVlBQUFrsVmzZpF2OMfzFVcXFxcXMw1CB4dPnzY1dwnPj4+MTExuPGEu9LS0sLCQp5NfFdUVDR16lTX4uWXXz569OjghROiqG/uTZkypbi42Fk+99xzL7744uDG443w+k4dDsfhw4ddi8nJybGxsUGMx3RFRUWnnnpqsKMAGgWebAEAAAAAAAAAQECRnAAAAAAAAAAAAAFFcgIAAAAAAAAA0HitW7cuppb09HTX7FwezZs3r/a2O3fu9GuokYTkBAAAAAAAAACg8TIMo6KWffv2bdq0ycttn3nmmdrbep/VAMkJAAAAAAAAAABqvPvuu96sduTIkQULFvg7mEhFcgIAAAAAAAAAgBrPPPOMN30gPv/88wAEE6lITgAAAAAAAAAAoNTU1DFjxkjKzs7esmWLx/VnzZolqWfPnn6PLBKRnAAAAAAAAAAAQJKuu+46Z8HjyE45OTlLliyRdNttt/k9rEhEcgIAAAAAAAAAAEk644wznIXZs2e7H9np008/dRYuuOACv4cViUhOAAAAAAAAAAAgSSkpKaeffrqkffv2bdu2zc2aTz31lKThw4e3bNkyQMFFFpITXjEM4/bbbx83bty6detM2eHBgwffeuutW2+99eKLL54wYcKMGTPmz59fXFxsys4BAAAAAAAAAA3jzchOBw4cWL16taSbbropQGFFHJITXvnmm282btxot9u9maLdPcMwXn311SuvvPKNN97YvHlzaWlpUVHR0qVLn3322UsvvdQ5SBkAAAAAAAAAICicPSckzZ49u651PvroI2fh7LPPDkRMkSgq2AGEgT179jzzzDOm7MowjNmzZ3/99dfOxfj4+H79+hUVFWVmZkpyOBwPPvjgrbfeOnr0aFMOBwAAAAAAAADHyq/UvEPBDsJrg5PUPylwh0tKSjrrrLP+97//7dmzZ9u2bZ07dz52naefflrS6aefnpKSErjIIgvJCQ9ycnJMnGx90aJFrszEtGnTRowYYbFYJJWVlb3yyiuff/65pKeeeqpPnz6tWrUy66AAAAAAAAAAUNvBCl2xIdhBeO0fXQKanJA0derU//3vf5LmzZt3++23/+Z/9+zZs2HDBkk33HBDQMOKLAzr5M6OHTumTp1q1lQQdrvd1QNj+vTpI0eOdGYmJMXGxl577bWuWd3nzJljyhEBAAAAAAAAAPU1duxYZ2HWrFnH/u8HH3zgLJx22mmBiynikJw4PsMwPvzwwxtuuKGkpERSXFyc7/tcsWJFUVGRpC5dugwaNOjYFSZNmhQTEyNp8eLFeXl5vh8RAAAAAAAAAFBfiYmJ5557rqTdu3fv2LHjN//rHNNp3LhxiYmJQQguUpCcOI49e/bccccdL7/8siSLxXLvvfcOHz7c991+8803zsIf//jH465gs9nOOeccZ/mXX37x/YgAAAAAAIQRm83Wv5ZmzZoFOyKEn759+7qqUFpaWrDDARDGpkyZ4iy8//77tX++Y8eOrVu31l4BDcOcE79lt9tdtaply5YPPvhgWlrajz/+6ONuDcNYvHixs9y7d++6Vhs6dOiHH34oaeHChWeddZaPBwUAAAAAIIzExsZOmjTJtZiUFNjxxRERJkyYYBiGs5yQkBDcYIBQ1ilOh08OdhBeiw9GG/sxY8Y4C7NmzbrllltcP3/vvfckWa3WUaNGBSGsCEJyok6XXHLJJZdcEhVlzkdUWFhYWVnpLLtp+pGenmNpCZMAACAASURBVO4srFmzxpTjAgAAAAAAAMBv2CxK5d2wWwkJCeeff/7HH3+8Y8eOnTt3dujQwfnzmTNnSrr00ktjY2ODGmDYY1in4xgzZsxrr702ceJEszITko4cOeIspKamWq11fuzJycnOgsPhcCUzAAAAAAAAAAABdu211zoLztFuJG3dunX37t2SrrrqqqCFFSnIjv2WzWar3UnHLPn5+c5Cy5Yt3awWHR3tKpeUlLhyFceVlZXlnK+7LocPH5ZkGEZFRUU9Yg0HDofDVY7IXzDAXD1eKysra3+2aADXhykqJ7zgrDCVlZUWiyXYsSB02e322otUGLjnrDAOh4NrELxHhfGd80+P2z/f1b6dlmS32/lIj0V98164nN/C6zv9zXuDyPs7df06vzkjoXEaPXq0szBr1qwbb7xR0jvvvCMpOjralFmKGzmSEwHiyiI0b97czWoWi8VqtTrP8h6TE9OnT9+0aZObFQYMGCDJbrfn5eXVO+Lw4XA4IvsXDKSCgoJghxBRKioqqJzwRnFxcbBDQDhxtXgA3KisrOQaBO+VlZWVlZUFO4pIwLOJ6UpKSty3yWvMqG/eKC0tLS0tDXYU3grT7zTyHmdcvxHJCUiKj4+/8MIL33///a1bt+7Zsyc9Pf2ZZ56RdPnll9duZY6GYVinAHHd68fExLhf0zVUGQ3YAQAAAAAAACCIrrnmGmfhk08+2bZt2759+yRNnjw5qEFFCHpOBIj3wy+41iQ9CwAAAAAAAABBNGrUKGfhueeeKyoqkpSQkDBo0KCgBhUh6DkRIK5uPuXl5e7XdPWxoGcQAAAAAAAAAARRXFzcn/70J0lr1qy59957JV177bU2my3YcUUCek4ESEpKirNw5MgRN6sZhuGa9NI1vlNdHnjgAfcjwy5evHjVqlU2m61p06b1CTYMFBcXu9I8VqvV9fGiYQzDcI5rmZKSYrWSs/RJYWFhZWWlsxwdHZ2YmBjceBDi8vLyDMNITEwkIQ03ysvLa4/ky7ka7jkH1+YaBI/y8/NdA8nGxsbGx8cHN55w5zxX22w29xMHwiPXs4lTQkKCx7GRGyHqm3vOe2xnOS4uLi4uLrjxeCO8vlOHw1F7FrTI+zt1PZ15Pw4KIt7VV1/97rvvqnpKkkmTJgU7oghBciJAmjRp4iwcPnzYzWoVFRWussfkRLdu3dyvkJWVJclisURFRdoXXfulTET+ggHmum+z2Wwkfn1U+96Fygkv2Ww2qgrccDVccIqKiiI5ATec1YNrEOrFarVSYXzkap7CJ+mj34xvTOU8Luqb98KlCoXXd/qbSVIj73HG9euQnIDLKaec4io3bdr0hBNOCGIwkYQn2wBxpb6zs7PdTCZRUFDgLERFRUVY2hkAAAAAAAAAwk5sbOz48eOd5euvv57mYmaJqMRmKEtISEhISCguLjYMIz8/39WR4jf27t3rLPTv3z+A0QEAAAAAAABAI9W3b183Dcolvfnmm2+++aabFdxvjuMiyRMgFotlxIgRzvLGjRvrWm3ZsmXOwtChQwMRFgAAAAAAAAAAAUfPicAZMWLE119/Len9998/bu7Bbrd/9tlnzjLJCQAAAABAY1NcXHz77be7Fi+77LLRo0cHLxyEpb///e8lJSXO8jnnnHPxxRcHNx4AQF3oORE4GRkZzjmuMzMzly5deuwKc+fOLSsrk9S3b99WrVoFOj4AAAAAAILNqCXYsSBcUYUAICyQnDDTs88+O27cuHHjxt16663H/q/NZrvmmmuc5RkzZnz77beuy2RFRcXLL788b9485+L1118fmIABAAAAAAAAAAg8hnUyk91ut9vtkhwOx3FXOO200xYtWrRkyRJJM2fOfPHFFzMyMsrKypYvX+7a5Jprrmnbtm3AYgYAAAAAAAAAIMDoORFQFovl7rvvvuCCC5yLxcXFCxcuXLp0qSszcd1115177rnBCxAAgOOrNLStVN/kas4+Hazw77HyK7Wi0L+HAAAAAAAAwUXPiUCzWq1XXHHF+eefP3/+/GXLlm3bti0qKqpz584jR44cO3ZscnJysAMEAOC3VhRq6DLZq8fs7RSnM1K92tCQLF4fpcyhLw7rjQP6JEdtYrR1WD22BQAAAAAA4YXkhFduueWWW265xeNqN95444033ujNDlu0aDFx4sSJEyf6HBoiVFmlft6h/NKan5zXWza6OgEIjnaxNZkJSVtLJC+SE9tKNWalxrfSpa3UL8lzpuGp3bp7a1V5e6l+ydOIJg0MGAAAAAAAhDiSE0BIene15iw+6idn9SQ5ASBYWkQryaZCe9Xi1lK3a1d7K1s7SvXoTj26U30TNb+/2sa6W//iljXJCUlvZJOcAAAAAAAgYvGuEwhJEwZqEPOiB4HdOKp5OAAni9QlvmZxp3fJiTcP1JTzKpUW42H9rvE6KaVm8bMcefPn6OBvFgAAAACAMERyAghJNqum/06t6z8HSeYBzVvjh4Aai09z1GWxHtihPWX127DMofXF/okJ8I9KQx8f0mM7vV3/7g6a21s/D9L+EXqjj+f11xRpTVHN4oRWsnoxg8SlrRRl0e+b680+WjvU80hQByvUc4me3aNyh+edAwDqUuJQBbleAAAABBbJCSBUNYnTlUPrt8nS3br1Yz3zkz5Z55+YIt+L+7SzVPduU4dFuijTc4vstUW6f7vGrlTTnzRqhVetvIGg212me7ep4yL9Ya3u2aYD5V5tdUkrTWyt4SlqHePVPNWtovVQZ/VJrFq8tLVXR7msjfaP0Mf9NL6VEm2e1394hzaX6PpN6v2r3jhALwoAaKAZe2KGLtOS/GDHAQAAgMaEOSeAUGVIo7tqdNeqxRhPf60/btP9X6rCIUlP/qCEGJ3Wzb8RRpwdpfoip6rsMOQwPDf0XnBE07dXlUsdWlekdv6LDzDJ4nw9sKOqXGno1f2a1sH8o7SO0d0ddVdHrSnUF4c1IMmrrVLqc2Oyo1TP7a0qby3RbVv0hxZepTQAALWtLol69kC0w9Cw5bqurR7qXL+zMQAAANAw9JwAQpVFio2q+ef+LbnD0NsrqzITkgxp9k8qqfB/lGFjb5nnUV/+ve+org9Xp3ve7eimRy1+f6TegQGBd34Lta41/cOcfX7scGCR+idpWgevOlvU10M7jvq7vrcTmYnG5bsj9JUBTFBp6Na9Sc6/JkP65x69fsDTNgAAAIAZSE4AEcFq0cPnqEvzqsXUeD35e8VHBzWmELKrTKes1B8zVeY2P3FVuqZ3UrtYSeoYpzNSPe+5d6Ja1vqYfyA5gXAQbdHlbarKNov6JSrPHtSAGuqhLrq5nWKsktQ1XpPTgh0QAmhhnsauVJ9fNWefSplxBPDBspLotaU1HSUGJesaL9pnAAAAAL4jOQFEipRYPXme0lPUOlnPjlPX5p43aRz2lGnsSm0t0ac5GrfW3Tus9rG6r5O2DdMn/fR4V9m8aOltkU5tql4JuiZdb/TRTEbSQpi4Kk2d4vRAZ+0Ypg9OUGp4Dt/RMlpPd9PGEzWpjR7qrGh/9M5AqHp8lyRlFevqLHVapIP0FQQa6qSEiq+7Hhmc6JBktejFHoridAoAAICACM+3EUB9GZLdoaiQycbtOqK0FPPjaZagp8+X1aJW3g3u3gjkVmrsKm0uqVr84rAuytQn/dyNMBNl0Xn1yey80eeoV6J5pR7W/7VA3eLD9V0wAm95gQYlm7/bLvHaOswvQy0FXsc4vdor2EEgsLKK9fGhmsXeCUd1YgNQXyfEVX7bu+S1vMQD5Rrsh4sOAAAAcFwh864W8J8duZoyT6e9oOs/0M4QGHbn+y2a/J6e/dkvO2+TTGaitqZROrtZzaLNosvamPxCtl6NtXeU6qzVGrJMqwpNDQIR6ptcDV6ms1ZreYH5O4+MzAQap++PyFKrBt/RPnihAJHCZtH1bfVA52DHAQAAgMaE5AQiXYVdt36i9dmStGa/rn5P320JWjAOQ3MW674vVVqh99foiw1BiyS07S9XdrlXa+ZWeljBIj3dTbe1lySrRXN766KWvobXYKUOXZSpwxXaWqJhy/Xa/qBF0tgcKNemEtnDbeJcQ7prqyTNP6zByzR+nYdJU4DG45p0bTxRU9sq3qq+iTqbgQwBAAAAIAyRnECki7bp1lE1LYRLKvTWSjlMeklpSBsP6vMN+mSdVu71vP78LM1dXrP45AJlHTQnkghyoFxjVmrMKh3wlJ8osKvPEo1fp21uR1KySI931V0d9FovjW9lYqT1duMmLa1u/17q0K1bPCdX4CNDun+7OixSj8XqvEibSjxvEjreP6hfa3WYyKtUrBcX7W2lKg7P2a2Beukar2e7a+dwvd6bbkBAoP0xUycu0x/WaspGvZUd7GgAAAAQthj1HI3AyE66ZKDeWilJKbGa8TtZzXiPse2wZv2kFXuqFs/upYHpHjY5s6e+3aIlO6sWm8SZEEZkyS7X2FXaUCxJo1fq24FKi6lz5Ud3an+53s7WB4d0U1vd01FN6jilWaSHu/gl4HoZ0USvH6iakdsivdmHmSf8q9yhyVl6/UDVoiF1Dqu/uW+PHoXOmzr8drau3qgJrfR8Dz8FBYSWFtFq4fVsE3vLlB7rz2iARmNFgbaVSgWSZDeC3PgDAAAA4YueE2gcRlW/1fv76Wpt0jR/2w7XZCYkr3pjWC2693Slp0jSgHS99Cf1DN4YQ6Gn3KHTV2ldUdXihmKdvkrldYxjs6tMT+6q2fCFfSoP+UF7LmujnwdVvR9/sLPOSPW8yZx9unlz1b9/7vG8fvhyGPosRzO266c80/Y5P7cmMyHpqjRFhVX76me769uBOilFksa3Uobb2WSK7JqcpfHrlF+pF/bqPTplAUcrsKvbYmUs1ZO7tM+7kQOBCGM39I+d3o6c6YYh7a21E3J+AAAAaDCSE2gc+rbWR5fpntN0UgfT9jmm21FdJQzvXo0nx+rhs3XxAD31e6XG17XWV7n6/Rpd6mnAoggTY9XN7WpG57BI09orpo6z1H/2V3VBcLq7g1p63Xg2iDKStHSwHuqsv3lXEz8+pFm7q/7Ni+jXzSUOXZml+7brlBX663rlmTHg1e+b656ONYune5ENCjVjmuqXQXr/BD3oaYbSN7L17301i5OztL0xnT0Aj94/qBKHVhbq9i1q94u+yg12QEDAvXNQd21Vp0W6ZbP2lDV8P0cqj5oDyU0nVwAAAMA9khNoNJrG63emDnRikW48uWaEKO8n2+3cTNeNUNTx//ochqZv1+9W6dMcvZmtizNlfn+A3Xn650LTJt4w1RVpeqWXLJJF+ncv/bVNnWve01Hz+qprvCR1jNNN7QIWo6+aRevujuYMLRZJEm36v+pEwusH1H+pvj/idgPvPNBZf2ktSVaLBpvUaSrALNK4FlVV3Y0r2+jMZjWLCVbPs7YAjUrtflTxVo1ICV4odagw9NI+zdiuazfq5s360bxuZIAkh6GHdkhSiUMzd6vnEh1paDsAh6Ep6bqghU5KUftYtafnBAAAABqK8c4BH3RtrmuHq1Oq+qUp2oRUX6Fdf12vDw5Jks2i69vq/k5mz/O5JUe3faLcEsVG6aqTzN23KSa1kc2iUocurzszIckiXdhS5zXXc3vVMU5xZFrD31VpenJXVW+hnaVaUajRTX3dp0V6qadGNdUVbbxNCK0oVLxVvRJ8PXSAWS36Ty8NWKoD5TqnuV7tFR59iQJgV5mWF+gPLYIdB4JqX7m+rdVV4sIWSrQFL5o62KSpG1VR3XLg+b36KUNDwjOrihD0UY4yi2oWL2qpplE63KBdNY/Wc/Vv8LOmSGkx9ZgkBgAAAI0B7/PQKGSX6+vchjcQc+eSATqpgxKiFW3Ce44vDldlJiS90kv/6FLnDM8NlHlAN36k3BJJemOFNmSbunfT/Lm1Jqd5taZzJKhxkfvasUW02sVW/Yv4d82rimreWYxN1U1tzdltjFWT0+rRVeX2Leq9RPdt90OnpWMYUrlhWv6xdYzm9tZT3fRpv8ivLd7ILNJlG9RlkSau1+GKYEeDoGoTo6WDdXM7tY6RpD+3DnZAx2O1KK1WC/Qyhx7eEbxoEHHKHGpTPf6SRbrLvIFOvbEoX6NW6MzV5gzbCAAAgIhBcgKR79McdV+iM1ap3S96ZX+wo3HrTy11Y/XwRH9drzNXq8Bu6gG+3KjC6jGGHYb+8Z0qzD0ATPZKL+0aXvXvnb7BjsbPhiTrqnQl2tQkSq/2Cs7IV1nFVc2rZ2zXq/4/Xby4V2M3N1lXaloS8vRU3dLO7O5W4emTHJ3wq/6zX5WGiux6bm+wA0JQWaRByXq6m3YP1/z+Oi2AM9CUODyv45Je/e64a7we76oXe/ojIjRS41tp2zA910Md4nRxK/UMYAfB74/ojFU6UqnlBTpnjYq49wQAAEA1khMIb7YDRcn3fa+DhXWt8MEhXbhW+ZWSVGQ/qj97nT7K1Mq9gWg1fTxPdNXYVEm6Mk1f9leyueNO3DBSPVpWlaOsGtNVFl5jIlRYpKvStHKI3u4TtAGsn6/1Cvv6TdpQ7MdjrS/WLZu1odR2xpYm/9xnC8VJYMLZaU2PGjzkmd31e0eMEFRsN+HKHGXR75rJFqhLX5FdJ6/QHVu8neYpPVaSoi36fqBub88AODBZnFVT0rX5JP2ze+AOurdM56xWYXVC4uc8TVwfuKMDAAAgxJGcQBiLzjzYdNrXUav2664vVHqcMTvyK3VVVs3wzUOS9XBnTzv9ZYeeWqCbPtJ/l5scrneiLXqnj/7dU3N6Ktb0P9Aoq6aNkc2qni015yJNGlLXvNyAWcodem6Psrx+y98t/qiJnQPJkD48VLNoN7S6zrynr8ocunRd1evycsNy2zbbk7v8dazGKcGmG9oetbi5JHjRwAwXZqrNzzpztf62VV/lel7fd15mFOpiN3Tpei0v0BO7dFGmir1oLf56LzlGq/xUtWOGYfhNtCWgea/0WP2jS81i0yj9LbAjSgEAACCU8V4S4Sr2++1NZiywFJRL0qZDeujbY98ipETp4xOUVN354Lzmnmat3l+gh76pKn+2XuXB6XbePFpXpPltYJZuzTXrfP3rQnVp7qcjAE5HKjVnn3r/qus26e/bgh2NFyzS8iFVnTZ6JWjxIF3cyl/H+iVfa2t15OoUa1zl3Twr8N51bZVg04Ak/be3Np+kfonBDgg+MKQVhcou15eH9ehOvXHA70fMr9RZq30a3u2OLfq4Ot/5wSGNWaVKT9mOBBvDsiEC3dhOD3eRpJbR+m6ghqUEOyAAAACEDJITCFdGStxR2YiF25V18NjVRjTR5/2ryn9t4/aZ35Du/0oF1VMy7M3XWytNCjbE9EuTjb99+N0jO3V1lraWSNJ7B/Vrgcn7X1+syzao3NSxelKj9HZfXZWmpYM1IMnMPf/G6KZaNEg9EiTJZtF/elQ2MW3iCVRpHq3lg7ViiC5trSje+Ia5fWXKLq9ZzPDnn6ekPWU6ZaW+ytVVWZp/uCF7KHdozdEjSY5vRT1E43VXBz3aRT9kaKCf/3gBAAAQXnhBiXBVPqhN0V+r0w7JsXryPPU+fiPnU5poQYa2D1PnOLd7tEhTR6hFrba13272dUwHoBGbePRf5F1bzdz5j3nqs0T/2a8rs0yeIGZ4il7sqURzp3s5nsHJWj5Yf2lWdnvL4mHJnGr8omcC7dAjxMqjx1jLSPbjsbKKNXx51ahulYYuytSK+o/wFmPV5/3l6hE1JV03tzMzSCDs3NlBvQM4CzcAAADCAg01EcZKzuth250fvf6Q7bHfq10TN2ue4u4/a+nXRi/9SW+v1OYcndheF5wgK++1TDZnn1pG67zmNCA1k6FQfAPbP0n9k6pe8MVY1T9RFYaizQjUbuhAdRvquQfUMU4PepxOJiQl2vR020KHYUgMcgG40zdRz3TXigKtKNS6Yg3w5yBdLaOPSk8W2jX/cEP6akRb9EJPdU/Q90f0TPdQPEsDQGiKi4u75557XIutWvltnE1Erttuu83hqOph3axZkGa0AwB4geQEwplFhZMHRdmNpm4zE/WTGq9rh5u2t6PlVcpuqFkAJyEMNSUO3blFRyqVHqur0jQ5jTk/TbDgiKZt1Qs91D/0hkr4c2s9UKIJrXV3B3V033WpPmwW/XCkZvHJXZqcpk7m7T/AeGUJeNQxrmaGc7PSnHVpFq0v+mv4cu0vl9Wi2d00ta3nrY7LIt3RXre1o6kDANSD1Wqt/TY5Li5sb/IQPKmpqYZR1TU5IYF+WwAQuhjWCWEu2mokxpi4vxJTx6+vbX2xTlqui9d5ng8zgr2drSOVkrS3TPdv1weHPG0AtzYWa9xanbpSi/J1h6mDJrlRaRyVGHDv2nTtH6EXepiZmZA0/7D+uaeq3CxaXw8I48wEgPrya2bCqVOcPuunVjF6v2/DMxMuIZKZyK3U07v1+K6jZu8AAAAAgCAiOQHUqDR0xipdmaUiu5m7tRt6YpcyliqrWN/k6vYtPu1te6nGr9O2UpOCC6zn99aU4636S+vghRIRJm3Qh9UJni8PN3DW1no5VKGRKzR2lfaWeV5ZUrJNCX6YvGFbqeKsktQ7QT9naKR5XacAwGlQsraepD+0CHYcJil16PRVunWz7tyi01ap2NT7HASAIWWXq6IRN3ABAABARCI5AdS4f7sW5unlfRqy7Ldzb/pie6n+vk1l1X0yZu3WK/sbsp9Sh2ZsV+8lejtbt2w2LbyAKXGoXaxs1Q1IJ7RWUwaW883DXY5anLbV5Kmhf6PUoQvWakm+HIbezPbnkTy5Nl17hmv5EK0aqp700gbgH4l+yK0GS7RFV6VVDSy5tkjP7vW0AUJJbqWGL1frn9XsJ12UqaUFwQ7Ib17ep/8e0OGKYMcBAACAQCE5gfBmSHl2c4ZL+DZXD+2oKm8o1h8z5TDpRW/XeD1Qa7beaIuMBu35/DW6b7tKHZL00SF94f9m8uaKt+q9vto5TDM6q12srk0PdkDhb0xT/b55VXlsql7p5cfZCwzpyiwtzKtanHvAb0fyTrNoZSQFYnQXAIgANos6xunJruoaL0mP7lR+ZbBjgtfu2KLF+ZJUaNe8g1W3gu79e58yi/wdl8kM6b7t+vN6tfxZo1bo7aA2g2jMHt2pDw5pZ6l/m7wAAAA4kZxAGDOkRw4kjNmUstu7EWbceyP7qFvwezqYOUj0re00LEWSusXrhwxdkdaQndzY7qjFmzap3B8zZGzN0bM/++9xJD1W/9dR24dpSLK/DtGoPNpV/ZP0WT99PUAZ/pwQO7tcP+fVLK4s1PpiPx4uMhTYtcq8PlgAGrOVhbpuk/J8yCgszNPlG7SlRJJyKjRzt1mhwb+2lujVWj1um0VX3VK6satMUzbqhF/1x0wtD59uFmsK5byldxj6MU87zbi9R30dqtDfturCteq4SK0W6h1SRJAkVRj6y3r1/1WnrappqwQAgClITiBcGdIDBxKfPpiwvcw6dqW3I+C7Maennu5W1RC7W7z+2sb3GGvYLHqll25tr1VDNNzTI2Vdzmuuc6ubyXeO0xNdFW3uX3Clw/LaMl31nt5Zpc/Xm7rr37JZ/NjGv1HpnaCVQ3ROc79/nq1jtGiQTqquvfd1Uu/GOp7SrwX6/RoPM9MY0pvZ6rlY569lbHcADVfm0Gv7NXy5MpbquT0+9Vq7rb2aVI+meGYzndPc7doIGZ3iNLd3zRiGyTZFebrkP76zanaK9w9q8DJ9GSZ9bT/NOWrxPKpoMNTOZh2qUPPo4IWCUBJt0S/5WlOkb3N16ko9vMO0MQYAACA5gXA1Y3/i7IPxzvKmEp22StnlPu3QIt3cTosGqX+S7u/k+cGvvnol6Mmuvk4OPLObmkZpeidlnqjzW5j5PtpSVtl02tfWV5ep0iFJz/6sQ+E2HEBjFbA0T+sYfTdQf2qpia11X6dAHTWUOAw9sUsjluvTHN1c97wvW0o0ZqUuXad95dpZqod3BjBEeG15gYcME+DRgXL9p0GTSHmv0tCNm7Uov2rx+b0N79mYGqU72uuUJvphoP7Xn/6LYcNq0fhWWju0aiDHp7p6WH9/uebsq1nsHKcxqX4Mz0SF9pr75C7x6tVY20AE17Kje3wO4kSBaiOqmyjZDd2zTR8eCmo0AIAIQnIC4WpQQqWt1kvZ9FhzJq4clKwVgzW+lQm78odu8do1XPd1UrzZf7tGbFRl51oPr0XlemqBycdA+Iu36q0+erlnY+z4YkjjMnXHFlUakvTSvjqHw46x6tdaDQ8f36VNJYGIEN4wpK9ydcYqDV6ml/38WhmRrdiu89fqsg26fYvsfmtAmmjTX1vXLK4t8mk8jWkd9EOGRjX1PS4EWpRFH/eTMVoXtvSw5oHymm4Wkv7WIWzmZ3q4iw6N1Of9NbWtrmjTGO80QsHBcrmesLrEKzXK7doIcwV2zdnnbc57RJOa8oUtNc7TuQgAAC+RnEC4+n1K2XPtCpzTQvyumT7tZ05yQpLVYuZsE6ZLMunXPFbRZQPUvPpxtlOq/jzI3dqbc/TMT7p3vr+iQaiyWhTTKC8dFmn00W/0btqskuPN+9I+Vv/XsWYx1hJ+s5JGKkMavVK/W6WvcyXpyV1VqSagvhyGJmfp13xJenKXLsr0Y0eca9NryhlJVcP1NEwUYyo2AgOStGKIPumnk1LUNlaTTB2n1N/irTq7mZ7trns6el4Z/vBUN+WfrF8G6dnuur19sKOBPxXaNXqlrs7SZu/a0AysntyuU5z+3SgbKgEA/IS2EAhjFzYpqzT0SX7cBydExwXjbemKQn15WBlJ+l2zIBzddEZSjOOWU6z3fqmJgzRpsKLrSIMs261//aJN1V159+YrvaHTaABh5eZ2+iZXn+VIUp9Evd2nzj5Mt7bTK/u1sVgTW+vxrkqLCWSYqJNFGpKsBUeqFneU6t2DmhCqXeUQyqwWvdBThyr0Va4kCmfoxgAAIABJREFUfXhIP+bpLP/cDPRJ1FnN1CZGU9I1NCW03ge9f1B9E49qp49QYKmeqGxfmWIbZXsC+CLBpmEpHuZd/zFPJzcJrdMR6sVh6K/rq6YY+TlP3eM9bzIsRSWjdOcWTWytprxGAgCYh9tVhLeLm5b9t3NhUDITku7Zqr9t1ZmrtTjf88phwRjRUW9cqskn1pmZkGSz1mQmJP1vQwACA0KBRXqll9JjdXW6fh2kExLrXDPGqn/31A8DNbc3mYnQcnO7o6YU+ipM5olFqNlXrlErqjITkh7p4q/MhNPn/fVKL50YYpmJbaX6ywYNWKrHdtIJKRRZpPTYYAeBSPT0bo1aoTu3NHwKHATd9O36oPp5zvvRAuOseqa7TqJZGgDAVKS8EfaC9aD+S76+qH6rdWWWlg2OlLZpaZ7uN/unKS1F+6oTMl9k6bKhIT0SFmCeltFaPUTNoz2veXITz+sg8NrH6tLWem2/zm2uO9vrFAbfD20OQ7dvUb8kDUxS34QQGlPu8xytrJ42dnKapnXw7+FC8BJrSJOzVGyXpGlb9e5BvddXHeOCHRYahwK7soq1vlhd4jSSq21gPbZT07ZK0hO7FGXRw138coIqLy//9NNPXYsjRozo0aOHH47TSB2q0LN7axY/O6wNxRE4Bf38+fPLy8ud5X79+g0ePDi48QAA6kJyAmig/9tWU84s0gM79GDn4EUTSFaLzu6ll5dIUtfmOqeX7A5Z/TYVBhBivMlMIJTd11G3t1e/uju+IHRsLtHTu6vK0Ra93VfjWgQ1oGpXpqlDnD7NUUaSJjXKmXvn7NW3uTWLByvUjHMjAmLoMi0tqCpfnU5yIqDeya7KTDj9Y6c6xGlKet0bNFRlZeV3333nWuzUqRPJCRO1iNaiQTp/jTYUS9K5zSJzdL4ff/yxuLjYWU5ISCA5AQAhi+QE0BCVhk5M1i/5VW0GLWpkAxqc1VO5xTqnl7q3bIyvZACEsy5eDKyMELGisKZcYahTKDXMPyNVZ6QGO4jjKbBrUYE1w89tBvokqlt8zTSqc3oqmVYKCIikWjVtfVHw4miUzm+hM5tpfnXf8aHJGs+8TeGpe7wWDdKEdSq065/deZ4DAARTyHSPB8KKsxfz1pP0WFfd1l5LB+sfXYIdUyC1TtLNp6iHh8xEoV0ljkCFhOM5XKHbtiir2NtBgbeW6Gevh50FAH9bWSs5EW1R30hs2mm6B3fod+vjrt6VvLfCj/f5JzfRqiG6vb2sFl2ZFqJ5GkSk3rXOAxuKgxdHoxRn1Qcn6PRUSRqWoq8GKJW2jmGrSZQ+6adP+vllyMT8Sj2wQ+U8CQIAvEByAmi41jG6o72e6KpBycEOJSTN3qO2P+uWzTw6BoEhvZ2tIcv01C71WqJRKzxvklupc9do7Cq9le3/+ADAC+WGEqtbSfdNDKE5J0JWVrGe3iVJH+TFDspMnLXb0wY+SLDp8a76JUNPdHW32vdH9N0Rr3aYWcT8uvCs9sj4eXblVQYvlEYp3qqPTtBt7TW/v5qQmQhzNotfvkRDunqj7t2mkSu0o9T8/QMAIgwPeUBEyakIdgTV7IZe3KvcSs3crd5LNGFdsANqTLaWaPhyjV+nbdXPA308Da9f7tBFmdpQrDKHJqzTgzt4QwQg+J7sqvyTlXWi3uqjezoGO5qQZ0g3b1ZF9em7xGGx1+dUXq+VXU5MUdO63219nqOzV+v3a7Qo38OhH9qhAUv1/F53qzUGvGr3aGyqHuuqT/pp00kqPoX340GQYNMTXZXCJ486zNmrt7MlaWmBTlpeM0kMAADHRXICiBCL8zV+ndJ+rhkAOtBKK5V5QJ+u1z8X6vZP5+8u316rpUw3BnkPoFYx2ld+1E/GNvWwyR1bj5ra9P7tymQcZwAhwGpRjwRd0koXtQx2KCGvyK7SWmNo9IhzXN/Wqw3thv6zX90Xa7HbFEJ9vXtQf1irUoeK7Dp7tVYVHn+1/eU6a7X+vk12Q7dsrnO1xsCQzlqtMSv1I0Ms1u2ERN3RXuc1V7d42RgpHwgxG4t10+aaxQPlevdg8KIBAIQDkhNA2Msu14jlGrZcb2erwpBfx3BwJ3O/pr6vx7/Xu6v1665/76p5QWK16Kq0IEXVKCXZ9PUATWytFtFVPxntKTlxbbo615pp9vkeOsFTZwsAQEhJsunbgXqnr9rFGJIea1/qcSAsQ3onWyf8qss2aFup/r7NtGCK7Lppkyqre2McqdSf18txvM4ZD+7Q19XZ8TKHLl6nQrtpYYSXL3K0KF/fH9GoFfrdKq2llQCAcNM1Xnd1kLU6cTiuhR7uHNSAAAAhj+QEEPZaROtwrUEAXtmvI0EZE6DjUbNhvnRo+6xuVZMWnt1MHeKOvxH8pHu85vbWgRFaNUSv9FLrGA/r907QokEaniJJ0zroSpJJAELNmv0qLAt2EKHOIv2ppZb3K/lXu4IxyV7dDczeUzM11Ne5+t67+SE8SrTpi/41Iz61jdW7fWteV9X2SJejulcmWpV7dOClDn2eo2s36pbNimCGdO/2msWvclXGXLIAwo3Nons76fN+SrZpaLLm9qaHEwDAA5ITQNizWnRzu5rFIrvmHghGHM0TlRTrWkrdevDGdso8UT8M1PROwYgHktWi/km6rI1XK7eK0bcD9Ux32jcBCD2LduqWj3XnZyoJmbmVQoAhbT/eXKOJNl3U1KtEjkV66Ohz/oztJgTmNCBJX/RXok2d4/RjxlHzGNeWbNPbfapmO7+hrX4ZpPY1dxN6dKdaLNS5a/TCXr2yv2ZGjcjzc56W1RqZ/YIWGpwcvGjQyBTba/o5mehAuV92i9B3ZjMtHKSP+ynBFuxQAAAhj+QEEAn+2lrNoiVpZBO911dT0oMRhEXqnCpJ8dHq3Uqtk5w/G9VUQ3i6DhNxVt3Q9vgtWwGgXt4/qF1m9XP4Yavu+UIVdmUe0N8+VxlTButIpZ7Zrb5LNHiZSnxrXz+qqc5IlSSbRVel6dVepgRYZViK/tdfP2YcNXLgsQYl69nuev8EPdNdsUc/nTSPVlH1KE95lVpgUseOEDSyiRZmaGx1N9T7OwUxFjQ6z+9V8o86abmmbtS/9x1/BLb6qjB07hqNWhG8+fAavZygZvP7JaqNp67bAABIivK8CoCQl2DTv7qrc7yGBjcNcNupSohWyyRebwNAY7a3TH/MlKQu8RrdVDe1Vf+khu5r1xFN/7LmVdnKvXriB91zmilxhqmvcnXBWhVXv7J/N1t/9a6HXF0e7KxWMZre6ajhlcxychOvVptcx3CC5zWXRXK9Kf04R6elHn/NCDCiib4ZoO+P6Mc8H/5kgPpbVqhSh5bka0m+2saaM7zngzuqOgMNWKqnuurqdPF4EEj/3qc7t+qdPpF8zgQARAZ6TgAR4uJWwc5MSOrcTK2TyUwACDuGlEdzfPP8kFdV2Fqil/cpz5f5jds31eSTahZbJOovg32JLQIMSZZRq13zv/b6usMTUzS3t18yE75rE6OTUiTJatGpTTWoEbyyH91U/9cx2EGgkak9pJgpf2WL8/XQjqpysV1TNzHB+3H4b16Zn/I0ZaMOV+jM1frnHjG2Vm0biz2vAwAIJJITAACgkdpaohf3asI6pf+sS9cHO5oIUntS5TirTvQxdz4xQ5MGS1KbZM2+QB2a+ra7sJcapfGtahYX5WuT30ZN+TpX/9przhgvDTatg17rrewR+n6gJvnWRwTAsQrsR72uNWWyk4V5R503prVXv0QTdhsxvj+i/r8qfoGGLdcXh01OHuwo1YVrq2bosRu6YZOe22PqAcLZ0gL1X6ors3wdEREAYCKGdQIAAI3U/Tv02v6q8o9HVGkoKmK6fuWVauVerdyjq4cpPjrAB1+SX1MenvLbWQQa4vITlRCjsd3UqhG0nPfCtel6Zb+aRumyNromXd390+mhwK4rs7SzVG9n66WeQetacUGL4BwXaCRs0uu9taxAywq1okCDzEhO3Npeg5M1aYN2lGpgkqZ3MmGfkSTRpjVFkrQ4X+es1ilN9O9epp3J95ar9ov3ngma2NqcPftDpSGrAtTx/lCF/pipMode3qeVhZrXV53czocEAAgMkhMAAKCRGtO0JjlRYNeygqoBZMLbtsOa8bW25lQtDu+kE9sHOITFg7SsUN8f0Q9HdLopo11bpPEDzdhRhBiaonl9dVYzJdj8eJRpW7SzVJJ+OKL+v+q/fTSOPAEQcRJsmti66v21w5BZDcpPbarVQ3TbFt3UTjGM13C0ocma2Fr/PVC1uKpIzcx7MTM8RUsG6Q9rtbZITaP08QlqGqpvfQzpuk3Kr9QrvRTn50piNzRxfdVFTdLyAk1Yp58HMRUKAARfqF6mAAAA/GzM0eMDfXckIpITLRK1LadmccWewCcnYqwanqLhKbqrgz8PY0iHiyWpeYI/DxOKLNKFLf17iAVHjprNwmrRQHqtAJHOajFz3OeUKM3pad7uIsvDnTXvoEodknR7ezU3tYtjl3j9PEiXbdA1aeoRwlfIx3fqxb2StLtMH55g2oeQV6kmx7zoKnUooVblTrDpxZ5kJgAgJJCcAAAAjVTHOHWOU26lTm2qMU11bvNgB2SK5Fh1a6FNh6oWV4TfUNNFdhlSkps+AQ9+rayD2l+gcrsu7KebTg5ccI3GwCRdk64XqvMT/+iizgx/AQAmibYqwaZSh1pG6+Z25u8/2aZ5fc3frYnePahpW6vKP+Vp+HL9mKHWMb7u9kC52v2iE1NUWRzV2m5NtVX1BUq0aV5fPbZL92yTw9BLPZkHBQBCBckJAMf39G5d1FLtY4MdBwD40w8ZSo+RLcLazmW0rUpORFkVFy2HEaDhnE3yVrauylL3BA1MUkaSbm53zGgPu/K0s3rS7f35x+wAJkiJ0vM99KeWuipLbWM1NT3YAQG1FNn1wSGtL9aGYq0v0tPddGazYMcE1EdajHJGalG+9pcr2Z8D9IWsr3OPWtxUonu364Uevu72i8OqNPRznlQcpdKY36WUt4mqyk9YLfpbBw1N1oI8TWjl64EAAGYhOQHgOF7ep1s36x879V5fndIk2NEAgN9EZgp2VBfF2DSorfq2Udzxb/Z2l6ltbIgOaLCiUIa0sVgbi/VFju48dlSq9BRtyK4q7ysIbHSNy2mpWjNURyrDK72FyFdp6C/raxYzi0hOICwNq89gkmUOvXdQJQ5NTvNbQAH0fA+lx2j6diXYNK6F/tzanEmqPqs1sGW0Ra1sv51F5bRUnWbKbFgAAJOQnADwW4vzNWWTJGWXa+xKzeqmKW09vMBaXqCzVus/vXU2T4YAEHT92qhfGzf/X2TXCb+qW7ympGtCK/9OquxZXqlKKtQm2fWDFYU1/zkg6XivxdNqVta+fBkK0TRLREi0KbFRtupFKGsSpbQY7SuvWtxQHNRogGr7yzVrt+7vZPIc4DkV+uce/XOPDlWoZbT+0lqx4T/HuEW6r5MGJWt0U9P6jpQ7NP9wzWJatJ3MOgCEvvC/pgEwValDf8pUeXUTk0pDn+bIMDxs9Ye1Olihc1ZryDK9tE8lv22hAgAIIW9lK69Sywo0OUttf9GPecELZX22Jr+ru79QaaXzBw5Dq2olJzKOOwlz3zY6rbv+PEh3jtYj53i+SgGIOL1qTfNLcgJB5zD0+C51W6x/7NS//p+9+45vqzofP/7RlmxZlvd2nDg7znQSMggEEsIINIwCLaOM9ltaSgfQAR0USr9tvy2llJYWSksZP8pqaWmBQggrEEISsred6b1t2bIsWZbu74/IkR2SeEm6kvy8/8jrnPhe6bEtX+me55zn1Ax8/JCkGfhiDh0+gEYvf28M8eOr6JK0UFa10mr4+zS+nhfYJKnAKDelQggRA2TlhBDxzKfwajO/qeKBYuYmDXw8YNby2CQ+vwdHD8AEC3+bOnAxh+OfKTd38K0DXJWBRVKfQoioVdNORiKGUTobXIFH+myS3a0wI5HDbt5qYU0r1d2smx3GZ9/diVbDlARQ4N+7efhDevw0OPnNWu46Fw1+eG4q25xs7WCrkzknffNaXMTiojBGKUSY/bGGag/TE5lhZYIFvcztHbopiaxrZ4KFKQnMH0ptHCFCToHbD/JwVaB73xGuzyLVEMqn+MkRPL0j7Y9Uc21WKB88bug1rEhlRSq/ncDnUzwat0/tiIQQQgxMkhNCxCe/wiM1/LaKg10AD1Xx/6YM9twLU9lUyqW7qHDzrxLsA10n3H4OuYPdazKxHTvF3UNlGxPShx6+EEKE0zdeocXF2FQmpLNsPPM+vadBPNvV2a9u0nVZ/LWO2w8E/6fSE/qtOFw+Xmrk8VrWObg6k+enQkUrD32Av3fRwxv7mZ7NxVP1Gi5J45K0wH/LmggRl56pY33vVu7LU3hrpqrRxKZfjOO34yWvE/P8SjxsaVPj4f/VB7utPfz0KA+OD9njl7l4oi7QNmoZbwkmKsRJaSBFp7hi/6UlhBCjgcxtFiI+aTU8Wx/ITAAvNFDtGcLpEyx8PIc3ZzA1ceCD97qCg0tpBn7kaeTu//L5Z7ngcb70Eq1dpz1bCCEiq62LRic+Pwea+O8+DjYPfEp8mZ7I1rl8OTew1cRXczmj/6Tjt1pOdppf4ev/4pGP2FaDb8iDItfs5cZ9rHMAvNxIoxfGpHDLguARZj0W46dPlIEFEX/8Crs6g93BfNYSn5akk8xEDGv08rtq5m/md9UDHxz98kx8MIu83rx+ronSwa1ZH6T7j+JTGGPmF+OoWsjTU+JhzwkhhBDiGHlPEyJu3Z4fbPco/Yp4DEaSjkXJgzpytpW2M3lnFi9Oo/wMCrwePjpCTXtgvuuRk45yCSGESsqb+nUnZqgUh5pmWXlsIjULeW4qs6zMS+pd8QbAW60nO6e8iR21vLidb77Cqif5uGJIz9i3AIVX4eljM0CvnsVZ4wAK7Tx6BctCN8tUxC+/wvp27j7EhTtidWHNUU+gdvwx0yU5IUaZL+4n9yO+Uc6mDp6uH/j4mDA1kXWzmWDhglT2zw9x2aXHJnLwDA6dwfcKyQhptShxUgr9rtJCCCHCSso6CRG3rsigwESlB62Gy9L5TDirKyXoOMfe2xmb2u9rh1uZnRfG5xZCiCEp65+ciI/Sc09vRq/lnGJyhlB5PVnP5zIB9BrOsfNKEyl6zk3h4rSTHb3uSLDd4SF/cOnrXqvSyDDQ6A10P3RwZwFo4K5zyLJy83wSZLhFDOzVZr64n4buQHdPJ9NicGS/xUtJIvtc9CgAM2LwWxBiJKy6wIsf2NLB7tj8Q/60MWY+nI1VF1iYGEIJOsZZQvyY4qQUeK2Znx4lzcBr09WORgghRgdJTggRt/Qa7irkQBdfz2esOYJPnJKAzUR7bxkpWTkhhIgq508kz0ZZI2VNdHhICvXuCpHn9fH8Njq7eexjJmdyzWzOHjfUx/jRGH4whjlWdKcqk9I3OVFo/3RyosuPT8F6ihEZo5Ybs/l9NVdn8uVcFhzPoSQauW3xUKMVo9YYczAzAbzSFJNjmqVJ7JxHt599LnZ2UhKD34KID3cfIsPAnCRmW0mO4MDA9VnBvaOBZ+r5xZDftULphQYMGi4PxULKzJOUJxQx4702vnWA7b37cm3pYE5Iy3MJIYQ4KUlOCBHPblVlxYIGzhyLx8fYFIpSmRgXs5KFEHEjPZGlxSwtVjuO0NlUSWfveO2+BjqGssVQrwGqY/sVzhqHTsP+RoDFYz99yKvNfH4Pc5NYamepnWUpGPrnOb5byPfHYJfPnmIEShIpMnPEHej+u5nvj1E1oBEwaplhZYZV7TjEaOX280BlcAXDL4v5TkGEnro0iSkJ7HWRauBzmVylannF/zRz3V4U+Otkrg9pLSYRc3qUYGYC+N8K/jFNvWiEEGLUkBtEIUQYfO8ctSMQQohR492DwbZWw1knyRyMlFbDDaXcUEpTJ+uPMu0k4zfvt+FT2NDOhnYeqlDaOvYZVk5GG0xQpEvdJjFiGliVzm+rAGZYOT8VRXZNF2JYdjiDmQlgXASXWWvgf8ehgYtSMaq6CebbrVy5O/Bz+MJenD6+mqtmPEJdy1I4w8aG9kD3n40cdTMmkhUIhBBiVJLkhBBCCCEEQIuX9x2828oHDj6YfcoKRVEnx0Z6Ik2dAHPzsYXzNjo9kUumnvQr77UF2wsq68x/fo9X93D7EiZnhjEeMfp8IYtxZi5Jj2zJSiHizmZnv26Ey9dcFgUrq30K3zqAxx/8nwcruSEr9DtGiFihgR+N4eKdAJdn8INCyUwIIUQkSHJCCCGEEIK3WzlvO8dnka5zcH6qmvEMwc3zuHEuu+t59wAzck5+jNfH7nqSzYwNy3fV0M3uzmD37EPVAPnJ7KknNxlb7G/sIaLGnCQpAi5ECPgU8kxUewBS9BRF0yCsXq9ftGjR8W5WVljKLek0/HcGy7ez3wVQYGLNTMlMRAWXj383k2/izBP3txqCefPmeb3eY+0xYwZbAfCiNO4q5LqsmNzQSAghYpQkJ4QYjdx+vlbOj8ZE132IEEKo6IThznfbYic5AWg1TM9mevZJvvTcVjZUsruObh+Xl/DNJeF4/iQ9/57Oe228V+vd6jUsPVwDcKCJb5+NRco5CSFE1Lktj9vyqO9mcwfNPdFVHs1oNF5xxRXHu1ZruPZmyTexdhbn7aC+mzUzZZq8+t5p5al6Xm7E6WNV+oiSE6tWrVKUwJyThISEQZ6lgZ+ruj27EEKMQqqWeBRCqEGBr5XzRC1zN/N2q9rRCCFEdEjRM6vP6Me7bac+NLasO8rWarp9AFtrwvQkFi2XpPHrYjbP8LXs+GhxZS3AkVZ+9T7KQCcLIYRQSZaRi9JGxUbQa9u4YAf3H+XtVpy+4P9nGnlvFu/MZOJph6+7/dy8j32ucIc52v2+mqfrAr+g15tp8Q7qLLd/4GNGtbcPsKGCfQ3UtuPpUTsaIYQ4kSQnhBh1/ljNE7UAzV5W7OChKrUDEkKI6HCO3gPo/f7FPtdFqfEyqD6nz+aeh1to7Qrv09nM9m8uMv7hcqZmAbxdzj93heu53D0cbuGjo7y8k7/vCNezCCGEiH3vtvFmC/ccZvl2Uj6kvc8IbYqeqaet4eNTuH4ff61jyVY+6Qh3pKPadX3yZF6FlxoHPqXCTeqHrNzJH2uocIcvtJjl8/OTt/jua9zyDz73LC+H7VOZEEIMl5R1EmJ0qevmzoPBrl/pN3VICCFGr0c//uK7FecnJiyuqEtM1PO3a8CodkyhMDuPpzYHu/saWDjYysvDNymDRy5jazVH21hcNMiTHq6iycssK7OTKDIPosbIH9fzr9577BQLn50x3HCFELGtR+Gwm72drExDF1X1iUTUWOcItidYsA16IOTYovMXGwCavJyzjX9P5xx76CMUwEVp2PW09QCYtdR1D3zKay10+Xm9mdebATaVMlf2Jeqr3dOva5fiZUKIqCPJCSFGl2wj/5nO1XsCi2Qvz+D7hWrHJIQQ0cDTM7WueSrNAG1ent3ClxeoHVMoTM26/7IlCemWG3O0abOzSB1s2eWR0moozac0f/BnPFHHdmegfVk6L5cMdEKuLdhu7cLdg1k+2QoxurzXxm3llHfR7Qc4eAbjLGrHJKKPT+Hj9mB38VB2Mtjn4qm6YNfpY3WLJCfCxazl6kwOdHFtFpenkzyId/VXm4PtVAOzw7VBScxy9F9OkiyXSCFE1JGyTkKMOstT+KSUmVamJvLkZLQyv0wIIYAb55LYZ6nEgeb4qOvk0Ol/UVry7fzifMPYGxsSdjgHPkUVHj+7O4PdSYPJoeT0nxtZJ7U2hBh1ErTs7gxkJkC2BBAn1+HjsxnBXSUWDSU5MSWBN2YEV1rcnMPPZMPkcPrDBNbM5KbsQWUmXD7e6bOH4kWpsnbqUxz963nKygkhRPSR+WVCjEZjzaybTUsPSTq1QxFCiCiRbOaGufzhIwrtfHUhC4sGUVcoBjxVh8sH4PbzVB1nJTMjKicV7nHR0ycbNKiZjzl9Vk5YTTi6ICXkgQkhArq8vLidNjerplEULX9rJyQy97q4KE2lUEQUs+t5YjJAo5f1DubbBjqhv7PtvDuTC3ZwZjKPTYyPTwfRa0gz57QanpzMa8283kKzl5Xy5/9pJdm8fAOOLhxuHG4KZdWPECLqSHJCiFEqUUeiZCaEEKKvy0uwGjl/Evo4WVqqwB9qgl27ns9lDurEFi/vtLGmlXPsXD24U4bH0cPfGni2nrsKmZbIXhd+BWD2YApGF9i5/3xybOQkYTWFMUohQqS2m3QDhhgd2rzvLdYfBXhzP3+7BntU1AZJ1pNroqa3prqsnBCnl2HgM+nDOXFOEhtKyTGij9G/3zh1rAzU1Zn4FDa0U3Lajc1HKZ2WtATSIlXVUwghhk6SE0IIIYQYBY608tdNTEhnYgYT008+rGbQsXJKxCMLI7efS9P5cy3NXoAbs0kYRFr6wh282RIoatXoDVdyoq6b7x/ihcbAwo5qD7vm0eVnp5NtTooHU3XArOcsKa4hYslndrKjkykJzEhkVTpXZKgd0OA53IHMBNDZzat7uW6OqgEF/U8OPQpTEpicMLiKcCKKNXvp8DEmKtPNY6UcThTTaYZWrUsIIUT0kOSEECJsvH6q2jjSypEWaju4+9xRsgpa2+jSH2rtKU4h1zjw0UKIyNhTz3sHee9goPu3a8iL/7tYi5ZfjOPeIv7eyB+q+UruoM5K0gW323in3ucztemK00J+AU/S8ffezATweC235GLRMt825IIbQsQEn8KuTrr9bHey3UmWMaaSExWt/brvHoye5MS9RWpHIEbM4+f1Fp6u47VmLsvg+biaJyDih1fBp2COk+W1QggRLeSyKoQIm1f3cOML3LuaJz/hzf20joqV9vq9jSlf/6/tlx+l3L5ad6BF7XCEEL3KG4Nti6HfdgXxzqzluiw+mjPYOcXnpQarAbQWAAAgAElEQVTbbVrd5nve4+pnONp66jOGI1HHtVnB7uYONsuG1mJY9rn4ZQVLttLQrXYop3WwC7c/2J0eW+VHGjr7dX9+oUpxiPh0/V4u38W/mvAqvNJEW4/aAQnRn9vPH6oZv4GHq9QOZeQcbj46itMz8JFCCBERsnJCCBE2Y1P7dQ+3kBr/i+2N/9yr8foBjctrfL2MOUVqRySEAKCsKdiekD60/RajjObdg7yxn3PGc+ZYbKEvfrG8d6dbo8+/uKK2R6vF4QlHOufLuTxaA2DTc10WKfKxVAzRgS5W7qSsd/LDq83cnKNqQKe1o//wfnRuTX9Ky8ZzZhHVDiraqHKQHlupFRF9FPouyLs8g5d6pxB4/Py9kctk+bGIGo/VcN8RarsBfl3FbXmDKpIZdVpcPPYxu+upbAP43ws4c6zaMQkhBEhyQggRRkUp/bpHWynNVymUyNF0B2dFGt46yA9VjEUI0Ud+Mi0uatoBJgxrN8zosaacjZVsrOSB91kylntXhLbm0lgz9xf65/1q9ZLyygRvD8CSsRhDfyM+28qXcliczJUZJMbifb5QW6GJuj6rJV6J7uTE4mSencLOTnZ0sqeTKTE3YcOkZ1wa49LUjkOMiKOHDh95JvWKrfoV3j/EM5v5yfnkB+orrkonSUdHb6G/fzWxIjmYzTOZTGazbPgghsblcvn9gfsynU6XkDD8a26VJ5CZABq6+XMt34jFm9oEA6vL8PdW7txdL8kJIUSUkOSEECJs7BbsFtq60GrIT0Y/KkaelOTgLGZ/UYrUzhMiWtx9LkCHhwNNJ98NO0ZoOrs1myoDHZ8fDeEYYfphhpcSG20JgXTO4qKTH3aYbU6W2llqZ5YV/dAjeXzSiOIUo5xRy4WpvNAQ6L7VgssXvRNac4xckzXwYUKE1ctN3LyPTCNzrJQm8f3CCP7J+BXWHuLJTzjcAvDUJ/xg2bGvWLRcmckzdaxM4wvZnG1y3X7bPcfPu+mmm5YuXRqpKEWc+NnPfuZyBRbWrVy58qqrrhr2Q30zn99U0dmbPPttNbflxeASXLOB4jTKe1cS765XNRohhAiS5IQQIpzuWY7dQqEdQ7QOFYSakhhcha7pkFKeQkSZJBOz89QOYkSMm2rw9qlbf874sDxNkomvLeLWRRxt5aMjLBxz0qP+08wOJ681AyxP4a2ZYYlFiNNYlR5ITuSbWJVOpz96kxNCRINju/s0dPNGCx86+ElRZJ/+iU3BHYzWlHN9KYX2Y717i/i/caQbADo7T3G6EGpIN/DVXB6oxKLllly+XRCDmYljSrKDyYmyRvxKzH4nQoi4IskJIUQ4jYI6TifwZyb68m1+q0GxmkhLkHq5QsQuj58N7bzbxtl2ltrVjqaXLzdJOW+CZt0RXF7MBs4oBFa3oMB8W6i3bdBAUcqJNfp6NXvZ4Qx2zxhFW4yLKHJhKvcUsSqN2UnqlakRo0+Zi/IuzkwmOdbup48lJ46ZbY3syKRWww1z+clbga5f4ZnNxxdPFIR+ByUhQubOAvQabs8nM6bv7krzqWlnWjYlWUzOlMyEECJKxNqHKTEUXq8X6OnpaWpqGvDg2OXz+eL7G4yk1tbWgQ8Sp7eymJXFwa68OMUgtLe3qx2C6EeB647a1joNbkUD3JjqLulxDnhWZPRMTGuemKb54gzD1lptU5fb2YaTHx5K3uQyAONNvqvsntszXAM8ioLW4fbbR1TC+7V2IwQzErM1jqYm70geUIRWd3f3KPmA9HUreGiWxYoj09XV1dXVpXYUMaDWq72nLvFfDhNQaPC9MtaRb/T3PSCa7016FLZ1pB2vBjhF39XUFNlFCtOTUwpsusp2tBrPkkLXxeN8J/tZnfBS7Orqitofqeqi+fUWKn6F9S7D39tMCxK8V6cM9lqvKMrxtsfjGeFPSQ932qCdCPysw/g7nZLElDMC7a52QnrJ7+jo6OjoGPi42HG8LNjxzUuEEGEiyQkhhBBCiH400OnXHMtMAB92GgCtw6Otc/ZMiorNYBWDtnt+oD5Vt5/tXYFPdAc8uqaeU86D0zW6DFtqDbsaDLsbFaOu9dGVI4khS++/yu75sNNQ49UaNMxL6BnJowkhRPSr8OqWlNtdfs3x7rdqkl4qcsTK9GMNvDy2fbtbv92l296ln2OJ+HVbq3FdPc24odp15VRfXlKkn13EoIcaLU+2WKq9WqDMoxt8ckIIIUSskOREPNPr9YBOp7Pbo6YaRYi4XK7u7u5jba1Wa7NJLYkRURTF4XAANptNq5UtnEfE6XT29ATu9AwGQ2JiorrxiCjncDgURUlMTDQYDGrHIvpZnqZd1zud9IBH5/nJx3nbK0lP7Hn+msjXjunu7j4+e4tPXas/cWq6lWBMZ6Ub7faTv5y0bxzVPr7leDfFo1eyrMOOarmd5bko+I+4lV2d5KYmD/uhRGi53W632y3vQWJA7e3txyeEmkwmi8WibjzRzw5LG3m9JdAda1buHadNsQVutY5dq6P83uS8FM4L9iwQ8V/6hXYuLDl9XuKED0Umk2l497OVHt5q0y6yKRPNSvwVsImJ19vI1Tdpj2UmgI0uQ6s5ZaxZ8SnoBvqFajTBI4xGY0wMicTW79Tv9/dd/J2QkGA0xnTRqxMdvxD1fS0JIcJBkhPx7Ng1VKPRHMtSxJO+gzJx+Q1G2PFFrzqdTqeTfSRHpO9nF3lxikHS6XTyUok2y9K4ryLQntzUVtPkyQOaOvUVDoojvXjC5/P17er1+r7vg/vd/Q5enKI75auptIDHNx7v6XbUceHkkYc3wcqE4ec4ROgde3nIe5AYEq1WKy+YwXh4Aq9vCLTfnqUZaw5+cj42PUX+9EbuhB/gsF+caxq5pRwg1cBCG09PJjWOpoKMktfb9dn8uS7YfaFZd1UGC7dyYSoXp3F+6qB224qVn1Lof6c7a3ljP8lmki0kmzl3PMaQ3eyfUOwo/m5njn87kpwQItzi6tohhBBCCBESZyRxSy5n21na4cj58XPBL2yoiHBy4qtl2DT6s0yGUotXf7KboxuyWZXOxnY+bmevizGn2UhiYjoJBly9O0NsrQlJckJlNe28VUZtB7Xt1LTzh8vIkFSJECJcii3cU8RPjvDSNIpGtHGPCLt1jkCjxcs6B3YZ/IhBZyZTaKbCHWhPTuC1Flq8PFvPs/XoNOyex6QEtaOMWuXNvLo32F1afOpDhRBCNfL+LIQQQghxIqOWRycCkJFMVhL1vVv8banmmtkRC6O9hz/X0qPofklysk65J6vzC6nuTx9m17MilRWpAz2cTsuMHPY0MDuXWXnMzQ9HzJHW4OSJTcFuTbskJ8SnPVbD1ESWSO2x+FXtYYuTfS72ufD6eXpKGJ/rrkK+U4BVFhuf3oeHybUxTs2Nmo4nJ4CFNuKvstNooNXwnQLae7gmK5AOXLY9+NUsIxMlM3Eajj57Xpv0mGUAUAgRjeTaJIQQQghxahpYUMi2GhYUckYhM3Ii+eRvt9ETKLyHw6dJ1/tPe/gg/GA5VmNcjdDk9q/LXNvBTJUiEdGq0sM3D+DxszKNn49juuzEESo+P3Ud5EVFzueRan7eW4vPpOWvkwcuST9sFtmgbUCd3fzfu3R4OH8SN89nBPsbDVt7D43eYHdxVLxOxXDclhdst/ewti3YvSg18huBxRRHnxktybLUSwgRpSQ5IYQQQghxWt84E706Y1H/bQ62DRrOsnpPfezg2EwjfYRok56IXktPb9qmtv20R4vR6N4jePwArzXzejOvz+CCAZcZidM43MLaQ2yvZXc9Og2v3hwN+c4pfXJOHj9H3BTL9t4q+ttW2j0Ab+zn7QPcfz4Lx0Q4BJuelsXscbHOwToHy1Mi/PwiLDQafjeBV5t5uxW3n4vVXJkTC6wm8pJxuHF6JDkhhIhakpwQQgghhDgtVTITb+5nT8OkzPwZaZk7zInAgkSvVasMeF44ePysc/BOGz8uwqD+IGR/Wg15yXh95NjIsTEpU+2ARHTZ08mTfTZTHWPmHLt60cSi57by7kEK7RSkUJTC2ePYXd+vltqRFnVL9xwzuX9pl32uIScnjo11rlT/W4l9TZ28tCPYNeuZnq1KIFoNJYmUJHJLrirPL0IvScdXcvlKLi4f77TJ9XwgX5rPl+YD9PjpGvEEFyGECA9JTgghRCi8vo/ntjI+3VRgpTDJOyMrGmYRCiGoaEOvJccWe8v+N1fz5v472XUnVJbk/+Nb56TrRlzTaej2dHLHQda20eUHuCCVM6OwMsZTn4u936+IFI2GpXbeaQ10fzIWU8Szjd8/RIqB6YnMSCTHFGuv1rIm9jeyvxGg0M7Z406sbrezLhqSE5N6UxH5JiYnYB7ib/n1Zj6zi0wD+88gSTaTGKF2N4V2ypsC3etLsQ5z0Z4PDnp0/69RtzRUsYl4kaCTZRNDodeSFHdrZ4UQ8UKSE0KICPIrtLhIj8diz/saqGijos0MpgRD89OXqh2QEAKAxz7mw8NYTUxIZ0Ehn5uldkDDke9yXZdykn2wQ2xvA3/ZyOIiFhUdrw+erOfNluAhb7VGZXIixsZ6RURNSWDNTN5q4a5D9ChcE/GlNV6FByrx9q56ureIHxdFOoYRqehT373AHvjXZqa996K0s5ZV01QIrD+bnq1zKbYMJ7XQo3BbOT6F2m7uO8IDxWGIb1QZl8afPsu7B3h8Iz4/l5UM4zHcima/W7fPo/P4NVsadT/3kmEIeaBCCCGEUJ8kJ4QQ4bepktVlHG6hog2DjldvjsOBpANNx5s9RfY4/AaFiFFljQBOD1urSU0Y6OjR7cPDbKpkUyUPfcD4NH5/GRZDnokpCex1BQ5Z08p9RSqGKMRwaGBFKstTqPeGcZPkU9nvCmYmgEmxdR3yK1T1SU4U2gE0MCOHyjam5zAjm5nRUjFn1nA3Xf5nE4d7Uy2/reK6rOE/lAjQalg2gbOKqXFgHEq+yOvHoAWqurXbuwKDFd0Kf6iOtayeiF+/rqTBi9OH08eKFK7NUjugEfL50amzs5oQQhwjyQkhRPjVtLO6LND29NDcGW+LJ/wKB4O71vaMtQf/v8MjS2iFUI3DTYMz2J2Yrl4oQ2c3k2M71lTSIjKcue5IsO0HS2CS6nmpweSEx0+Pgl7yryIGaTXkGFV43h3Oft0ZsfUJyOvjM9OoaKWijboO8ns/4dy3Qp3NeMLjN5XBdo+CyxeCx/QpKmTCoo5By5hB70Pt9vLP3bywjQcuJscyzuTb0qV3+wM/xN9X891CLPHzohMx7HfVHO1NZ9p0sZmccHnZVsPuOnbVsa+RZz5HpqRkhRCqkeSEECL8ivrflhxpjbfkRLePa2ZT3kRZE/UdhvKWlFtf1zq9ms5uEo28/kW14xMxpa2L2g5au2jrwuuLhloZMay8qV93YoZKcQzLrYu4ddGxptfjoaMjvE9X087hPvWbFhcdb65Ko6OH81JZZidTjbFdIWJat0KhmQo3gFHLhNhaOWHS87XAhQivD3/vGpA4ykwAz0zhoSqeqMPl49osFo2seJ0Cf6zh99V8NJtkudseDJ+fv+/kua20dgE8+Ql3L9HCFLNvq0sPmLV8PpMunyQnRFRI7LMWyBmKXKYKDrdw9+vB7u56SU4IIVQkH5eEEOE3NrVf93ALc/NVCiU8zHpumHus2V7dqH9lb8ILuwNf6uyWpbJiaF7czrNbA+1EoyQnRmRmDn/6LGWNlDexv5HxUbNyYn8j49KOVa6IForChZNZf5S2LoBFY45/5dwUzu2TYv7xEcaZWWpnjDniQQoRg27M5sZs2nrY1UmVB0PszqY3xO0+0cUWfjeBe4t4tGakW+zWeLXfOmp9twPgjoP8ZVJIAgyBr5ejQGkSpVamJEbZ61Cr5Z0DgcwE8MFhrpwKTDT2HPDoxpt89030XjJBzQCF6Mva51rYGaPJiYnpGLR4/YHurjrOGcpmO34FbVRdRIQQsU2SE0KI8LOZmZyJ3czYVIpSmZGjdkBhpFiN/oz+syKd3STLGJ4YNLsl2O7sxuuL4/GgsDPomJTBpFAumHD08PVybszuN14/NJ3d3PZPzHrOKmb5eGbmRsUNXl4yd52DX2FPPRsrmXzyXYPberj/CMfmTheZ+WUxV8bUchQh1GLXR+Vm8qKPNAM/GDPwYafh8XPhIXuNN5B4fqKWS9O5ZGTZjpDwKzxdT3tPoHtrHo9E1Vi/Bm6ax/deC/7HSzsAk5ZLkz0aSNIppz5ZiEhLN5BhIFGHVUd+jJbvNeiYkMGe+kB3d93QTn9mC2sPaVZM0M5J96fIfa4QYqQkOSGEiIjHrlA7gsjxJxr69dvdkpwQQ3DCps2tXbLOOnqsc3DdXo64eaeNHXNJNQx8yske5QjdPrp9vLqHV/dw74qhzVYLK62GkmxKsk/19Q8cHB8iOuImSRJnQgjRy6TljgzXt2uC79r/e5SL01A9/3zQHcxMALOj8GPFGYVMzWJPPRYDV0xXLhnP914C9X90Qnzaa9PVjiAkSrLZ18DYVEqymTmUuYMKrN5PlUNzoClVq3GfU+S8dW7YohRCjAqSnBBCiBDz5Sa5V4xTkkwam9mcaSfZMvA5QhyX0ucFo9XQ7pbkRJR4so4v7g9UXK/28OUyXpo2rHGTNeXBtlnPwsIQBRgJ77cF2zoNi2UmuBBC9PGFVPdrHaZ3OwzAzTn8pjgqhtdbqjq+sKP26RkTj3VLk9QN52Q08KX5bK7i6lkkm+nsVDsgIeLdtbO5cS6JQ99MbF8DVY5A26/4k2N08YgQIopIckIIIULMl29z3lIKGI1Gs82mdjgi1kzM4KHPYLeQmkCSKSoK/ggAzkomUUtHb3HhfzSyuqzz/ImJQ3sUl5et1cHu4iLMw1t/EQptXWyrYUs122r4yfkUDVypqkfBqgts/1iaJCsnhBCiHw38rsD12SPJvyyOioJOx8x/a+f0f+/ekJu5P91u9PmnmTXRuCahNJ/S+NqUTohoZh/u/LnV+/v2PGePrByeEEJIckIIIYSILkkmZuepHUR/97yJ149Jh9nA4iKWjFU7IHWMs/DIRL6wFyDB53vojXUrXE08cvnQHiXBwIvX8/5B1hxgZy3L1Cv7XeXg2r8Fu1urB5OceGg8DxSzpYP32sgY+mQ7IYSIe7kG/+550TW1QNPZneDtefYfaxb8z+WX7zlknJ4dx4sy3X5cvuHWXRRCDGjlVHRa1pTT2tVTnOLLl6l4QoiRkuSEEEIIIU5rQyVub6CdZR1UckKB57eRZ6PATn5y3OzpfV0Wr69vLHfx7D/WTGpqQwPtbmxD3FQmxcKlJVxaQr3zxC1GIikvGbuFtq5Ad2s1l5UM5jy9hvk25sutqIh9Lh/bO9nSwZwkFspLWoROVGUmAC6YzKt7S2saX3px9bJDVSy6II6TE2+3cvFOpiayyMbiZD6bgTVOPoMIER3Gp3HbYr66UNlU6XJ2qB2NECIeSHJCCCGEEKemgMcb7JoG98mhrYtH1wfaWg13n8uKiaGPLeI08Kdcj+mu14w+P4ACmyqHv/oh6+RjQw9W4oMLU5mWGM66GxqYlct7BwPdrTX4legbURsiBdrd1LSTnkBG3A69iZFTYMEWPukI7CJze74kJ0RcK0gG0GoudTQzMwdj6Ebrmzr58WpumMu8giipFLXOAbCnkz2dPFHH5elqBySEWu7+L1VtJJtJtjAnjytCupG3TqvML+huaQnlYwohRitJTgghhBDi1Hp8KH265sF9cqhoDbb9CulD3JghiiXNykGv5VhyAvi4IrSlmRR4oJLabr57kAIT3ynk6+Gr8jUnj/cOYtAyNZvZuXh9g00+RaEeP1/+OzXtdHkBbl3E1TPVjklEr2MV9/29F7ctTlWjEWGgQGM3XX7GDHFtW3xKtvDM58lJCv1Cxue3sauO77zKnDxuWcDkzBA//tB91B5sT0/EFrNva0KMVLWDirZA2yq1OIUQ0Uveq4UQQghxaj6F+QV4fLi9dPtIGVwZosq2ft1CezhCU4dRx5w8yhpZMIYzCpkb4t07tzup7Q60Kz30KKc9eoSWjKXAzrSsGM5JHKfX0uIKZCaA2vbTHi0EpUls6H2ZbOmIh4VD4ph7j/BWK3s7ae3hsxm8NE3tgIbkQBO766nvoN6JAvcsD83DasL2RvxJVaCxpZofvcnz16LThuWJBsersLHP5X9xsnqhCKG646U7gWTJ0woholfs34sKIYQQInzMen518ZDPau5CQ2DJhcVAWvysnAD44TISTWGqX/F6c7/uRalheZaA1AQ1N70IuRwbrb334ZKcEAOZ06ful0lLXTe5JvWiiV1+haOt7KxjZy1HW3nss6rX9tnZyUeOQHufS9VQhuH9Qzy9OdA26lAYzM+zvYcuP1mRnxjt81PVZy7CsvHqZiYADbwynXUO1jn4uJ3FUq5NjFp+hQ5PsGu3qBeKEEIMQJITQgghhAi1G0r53EyqHFS24fSoPlYVYtYwDmGatOSbqPIAjDUzMY5yB2GXY2NPfaBdKzs0igGcbeeHYyhNojSJ/HBlG2OZ28vuegrtpFtP99N5dS+/fj/YrWxTfanc5D6XzbIuehT0/eO/pYxsI1/LJTNKypx4ffx9B+dOIMvaby+ibh+OrgGHFD90cP1eii2snhHx1T/1Trz+YHdcWuSeuZtn6rkj/8RvWa/hvBTOSwHwKfjCuvpQiGjm83P1LBxdONw43ORKpk4IEb0kOSGEECPwwWGACelkJcnAhgiBZ7eyrYZkEzYz+XYuL1E7oBEw6SlOo3jQQxUKPL+V5RNG+T7GdxZwRwG7O/lvC2atXFeGYnERmVZyksixkSc34WIA4y3cPza8T1HXTZYxZv+Ky5u54z8AZgP5yfzg3JMPPU/L6tfdWRtVyYluP0fcjO8zvH+gi8drUOCXFdyQzXcKKFZ9PvHHFTz6MY9+zKzcE1ez1TtPk5zwKtx3hJ9X4Fc44ua31dwe4kKDA8m18e+bqGijopXKNqZEYsOJfS4erOTpejx+JlhYder9rnUadLH65yfEiBl0fGWB2kEIIcSgSHJCCCFG4IlNHGoGsJpYNZUvy0dAMTJljWysCLQnZcR2cmKoPjzMox/z1Ga+NJ/Lp49o/qfXzzf/xbg0JqQzMYPiNIyh3gI0nDRQkkhJfJXCioRl41k2Xu0ghAhw+8lbT7KO6VZmJHJjNqVJasc0JMe3DnJ7OdBE4ilWjI1NJdFIZ+9WOTvrWDklEuGd2sxElqcwOYEpCUxOILf/8ojfVAUqDrr9PFbDyrQoSE68uT/Q2FYTaFgMZCeRaT3NW6FP4bJdvNanEuBdh1iewvQIv3ckm5mezfTsyDxbQzfTNwV3Y/pV5emSE0IIIYSICZKcEEJEkAJNTg63cqSFbh/XzVE7oJHp9nGkJdB2etDI7CwxYg53sD2qdq5zeXnoA4AuL79bx5tlPPQZEodbceNoC7vr2d1b4eee82TMWggRYXs68Su09rC2jbVtLLXHWnKios9eAiY9GacY89ZqKMlmQwU2EyU5ERukPo0ZVt6aefIvNXn5a22wOymBlWHd1+dkehRquyk4nutpd7P+aPDLi8bwg0Fta9StcLad7c5AGUBAB/tcEU9OhIfFYvn5z39+rK1p6Urd1sLTm/lCaaaRy9J5qTFw2DoH69tZKCvlxMncc889ihJIZFmto3pVrhBCRDlJTgghIujR9Ty/LdBONHLtnJgtdgDA4Rb8fWrZTpC5W2LE2vskJ2yjKTnxxEaaOoPd7KThZyaAsqZ+3YkR/dt09FDTzRTZK0KI0W1nZ7/ujJgbGavsk5zITz7darYvn8Gtiyi0R3zHgyEzavhREQ9XUdcNcGdBREM+2MUTdTxZR6aBrXN7/7fKQUoCjc5A94LJg9zWyKLlOwV8K58XG3igEr2G/zeFSfHy1qPRaIxGo3FbneVf+w27GlAgwcDVMzHp7ywIJidyjNR3n/aBxChmNBqPJyf0+lAOfLV4uWoPTh+dPpw+HhzPZbF+F+jzc6iF3XUcaObOs2P7Dl0IEYMkOSGEiKD85GC7s5smZ2wXl69pR6sJ5icmZgS/1OPXOtw6jwu/kw4Pc/JGNNIqRo9pWSSZaPfQ7iYtXsYYBmNmLu8eDOQnLAa+sXhEj1beGGxbDOQln/rQEFvn4Lq9aDVsLcUmH7KEGMV29ElOJOgYF3Pp5u+czdUzqWijsg37aaMfHzPDcjY9dxdyRz5/a+DpOq7PGviUUPltFd86EGjXeNjSwZxjK2mmZvHidWytZnUZW6pZNGZID2vQcG0WpUkUWzDE3XiitrnLsLMh0HF5WX+UpcVn2FiSTEsP3y7g85mYtKqGKEYlrYa3W4PdZq96oYTEB4f56du4e7+Nz8+K5CdnIYRAkhNCiIgq6r94/nBrbCcnzilm4RgONVPexOEWsoP1Ggx7GpPvWxs88k+fZVLGSR5BqMLTwwvbuWJ6NGaM7jwbwK/w0g5au/jFu7S4uHAy5xRH4tn9CoqCTo0b/SVjKc3nLxt5eSdfmj/SK8OYFObkUd5Eh4cJ6ZGZGdujcP9Rfno0kK/8+gGemtz7tfcPkWllcqbMRBNi9LgpmwkWdjjZ0YlFG4Mb89ot2C3MyFE7jtAzabkpm5siW4DqrP7bhP+lrjc5AWg1lOZTmo9fGd4b1uQ4nczgWZBnfXwLXn+gv6acpcXAyyWkGeQdVagmsf9GZk6fSnGESpY1mJkAdtefmJyobcdsIEX1/XmEEHFLkhNCiAgqSgm20xJwxf5KbLOeqVlMPXHqnZLUf0l+hwcRPV7aERwEv2hKNJah0Gp4YiPunkB3ckaEkhP7Gvj2q5TmM7+A+QVkRbY+eoKBry9m5WTGpAx88OldWsKlJShQ3xHcpjXMjrj5VUVwJdXTdSxJ5ks50OPn1+/jcJNrY/kELpgk89GEGA1kW3vR12wrs61s7a3e9EIDD43/1K0LEQwAACAASURBVFqHcHwgaXezpZpMK9lJ2C3R+Jnn1JREY/ecHOOGaoAUy/EV2OkGNaMSwqDBpMXTmzWL+eREcRpmffC+Y1cdKyb2O+DPG3nnAPMLWDGJxUWYZRRRCBFiclkRQkRQkom7ziE/mTGp2AZVUTdG+a39b5v6biQg1NXUyTNbAFq7+NX7vL6P318WjffqKQnUtgfaLV0RetJNlXR2s/YQaw8BvHg9WRFf2zQuLWQPpaHveqZwG2/h1+O5tSzQTdFTeOwit6UqsM95TTtPb8Zu4YrpEYtKCCFElPhiDreVU2zh5mxuyI5UFabyJn68OtA2aHn0ihgqwwW4zx2rJBg05000LhirzspOIU7mM2n4waojUUdpZCfzhJ5Oy+RMttUAJJsx9l8Y4vLywWH8Ch9X8HEFi4v42YWqhCmEiGOSnBBCRNaFkwc+JvbJyono9eeN/VYuz4vsbpiDl2IJJifaIpWc2FgZbBfYVchMxLiv5PJGC/9uoiSRf5VQfGz5+5oDwSO0mggtghFCCBFlrs1iWiJnnXZz8dCrdwbbXj+pCQAKtLjQabBHe52W7rk53XNzrFarZCZEVHlxmtoRhNaVM7hoMtOyyUs+sWLa2kN4eoLdpfI5VggRepKcEEKI0FNM+o5vnaFLSUjISsVmGl07G0e54jQSjYFSP+mJfH6W2gGdQoqFJBMpFlISTtysJUw6POypD3bnFUTiSeOJz69xdj812XzfEe4fi/XYtLNjpaWOm50XGBgSQggxytj1LLUPfFiI9X0PMmh55KPAJuddXm6ezw2lEQ9ICBF9zhx7yi99eDjYNutZcuojhRBiuCQ5IYQQYaDBs6TQaDRis6kdiujvyhmcN4EnNvGfPdyyAHO01i3+6QWRXtKh1/KdpWys4JMqOjzMl+TE4LS42FDBxxV8UsW8fPu9K34zvs9XNfDbVVS0saact8tZNv6UjyOEEEKEXN+VExlW9tRT07sus6pNlYiEELHkxyvYWMHqMtYd4axxWKL11kkIEcskOSGEEGKUsVu44yw+O+P4zorRKPLFpiwGLprMRZPxK+xrCOXeD/HtwbV80DunbFMVPv9JSk8U2rl5HjfNQ1FO/JIQIpq092CT2yMRT25fwrWzaXDS4AR472AwOVEZP8mJHU5uP8hiG4uTWWAjWf6KhQgVg5bFRSwuorMbV7fa0Qgh4pO8bwshhBiVCiNfWyFGaDVMzVI7iNPaU88L2/nhcgxRUIF6QWEwOeH0sKee6TknP1IDmpPnnP7RSGsPF6aSZzrp14UQYbTdyStNbHGyuYMuP42LTyy4LUQMM+kpsFPQ+5nnYDMfVwTalQ4U4uPl/oGDd1p5pxVAA4cXMMasdkxCqMjro7qdZDM2U8j2a0k0kmgMzUMJIUR/kpwQQggRv/bU0+EhyYTVhN2MTW5VY98b+3ngPbx+rEa+vVT9UZUzCvt1P644ZXLi1H5dyfp2gOmJ3JzDt/JDFNvoVNdBRRu17dR2kJbAlTPUDkhEu3UOfnwk2K1wy7CmiF9Ts1hUREEyhXbyRzBLY0MFz22j0M6YFArtzMpTd7rAOkewnW6gUP6ExShX5eDGFwLtJBM/vYBZuaoGJIQQpyPJCSGEEPHruW2sPRRoT83ij5erGo0YGQUeXc/z2wLdV/dSnMbl01WNCTKsjEujrp3SfBaMYUHhwKf01+xlQ+9+pTs7OewOcYCjzkMfsP5ooD0lU5ITYkBzkvp1N3dIciIeKNDkZW8n+1zsc3FJOufE4oJJv0KHh2Qz8H8VrEyjJHFkD3jueM4Nxe5HZY1srWZrNYAG3vwfUDM58VF7sL04Wf15C0KozNHn02SHB7OM+wkhoppcpIQQQsSvDk+wbZWKOTFOA0Zdv//56yZWTFT/N/uzC0i3DnvS6OpW/H22orgwNTRBjV45tmC7tuPUxwkRMNOKToOv989wi5PLM1QNKNY53OyspayRm+arOEjsU8hcF+wm6GIqOfH+If65i/oOGp1otbz5P1uc3HWIuw6xIpU78zkvVe3x94o++1Vk2zCFeFTB4/E8//zzx7tLly4tKSk51cHdflak8FE7uzsBFkXxhmIikl5++WWPJ3AjUFpaunDhQnXjiai2rn7dZEm5CyGimiQnhBBCxK++yYkktYewxcjdNI/DLYE9HvKS+fmF6mcm6D8aPnQtXpL1OHoALFrOjqHhs+iU02cafFsXXV4sBvWiETHAomVaIm4/pVbmJLE8Re2AYtfmKh76IDhsfcFkckd0eRwJff/B+8dquH+s2gP6xxxp5eEPOX8iZ4075dXJ4Q4sSgDw0+F+sDowtri6hdUtbJjDfNV+tED/5MSY0L9v+Xy+TZs2He+eJjMBGLX8aRJAaw/rHUwZ/OKSA034FSZKNjI+bdmyxeVyHWtnZmaOruSEo/863GSLSnEIIcSgSHJCCCGGzq+gjYo7XDGAkSQn/Ao7apmRE7nftdcfFTs8RzOthh8s49Z/kmLh3hXYoiAzMXQHu6jt5szeqZ1fy+OWXNa3899mXH4s8hIYoeO5IouBXBvtHklOiAF9UopB3tWPe3AtWg2FdgrsFKeRmjDYE62mfmPWO2tVTE4AV2Twj8ZAu8lLs5f0aLgYrN7P5io2V/HgWs4ax51nYf5UWFnWvr2qGtcLDcGJz/NtzFM3MwHMyMGoo6KNti4KoyWhl6LnorRBHOf0sKac1/ZR1sj8Qn61MuyRCRFhC8fw84twdOFw0+6WD0JCiCgnyQkhhBiizm4uf4pxaYxPY0IGCwvJsA58llDFHy+n3U2Hhw4PGYOeSne4hTfLeKuMpk4eXsXMSO0gd+mTeH3YzCSbuKyEi6dG6Hlji8XAg5dgM6H71Ch+tYO6DiZkRHPS4q1Wrt6NRsMnpYztHWvSa1iSzBKpRBESs3J57ApybNjM0TFNGlq7eG4rexs4o5Br50RLVKKPEGYmnD6+d4gZiUxPpCQRW8zdbCnwZhlub6D7uVl8ddDTjcenYTYEz91Rx/mTQh/hoN2QHUxOfLcwpJmJBicPf0hFG8smcN3sk7wfnYpfYXV5oO3uYV8DppOFldnvg2V9o7skkW3OQPfO/Ci4inxtUaDR7g7WRIswhWH+IB78gLd7fwubKmhwnvADFyLmZVrlVS2EiCEx93lZCBFfPD2sP8qacr57TjSPJ/ZT3oS7hz317KkH+OVKSU5Er7QE0gY95fOYRic3vhDsvlkWoeSEz4/TEwig0UlHdySeNEalnGJx+poDPLERICuJyRncuyKqVjgp8OtKvncosMPEpbv4aDaJuoFOE0OVZGJyptpB9PIrvLKbxzfQ2Q2woxaLgSvU3sVdhNOuTv5QHey+OYMVsbWRTHNnMLsAFAylYo9Oy7QsNlcBaDV0qfxGdnEaT07m5SbmJ3FXYUgf+jdr+egowBMbMeu5euZgT9xaTaMz2D1/Ehr2uniqjh+N6fOOkJVEaT6ZVrKsZCWVTrRtyeLdVn5dxd7OKNsTxRbxWvZuLx8eYU05aQl8Z+lwHuGCScHkhAL/3c8NpaGLTwghhBBDI8kJIYRKWrt4dD1rD+HyApxRyCUxMk/8QFO/7oR0leIQ4ZFhZXoOO2sD3fcO8s0zQ77T40k4+w/iyM51w1DeO0W2vgOTLqoyE0BDN7+oCO59vcPJl8t4doqqMYlwUxT+vSeQmTjmuW1cOm0I86xFrNnZ2a87aYj5cfX1rcsEFA5xO4ELJzMzh+k5TM08SbWiyNLADdnckB3qx+3s5uOKQHtGDhcP5Tput7BiImsP4e7pMuj/Nm/aX7awvh1gSkKfUBMMPHhJ3/M0cG4K56bQ4TtxO43R5W9beeoT3D0ACQa+MaxPaHPzybTS0JslOv7hQYihUKDbT6ePTj/ZxrirDdjaRZWD6SG/gAohxElIckIIoZJEIx8cDmQmgLfKYyY5Ud4nOZGaMIRazCJWXDAxmJxwdbOrjtL8sD/pCTvXxcpCoqhS1md8IfqyhllGXpjK+TsCBTDSDHwpR+2YRLjptNyxhNv+FeiePY5V09DE2QCG6GdHn2nxNj2FMZdo1kBJNhVttLthiCsngPMmhCOo6LK9NphnrmhjRy0Lxwz23OI0frCMO85i7SHvEcc3GkwuX+Arf6kdVB4laZSvt0s2BzITgMvL+qMsLR7yg2g1XDiJv+/kvImsnCwbYothWN3Cyp309F4J9sxnSnzcEW6t5rW97Kqntp1EI6/eHG1zfYQQcUmSE0IIlRh1nD2O1/cFuttrqHeesAFglFpajM1MWSPlTacbAPX5De8fwaulw027hyVjmRWprQvECC0t5qEPybWxYiLnTYzQyzLZzDfOpN1NuxuHh7z++w94fRhG+YDEQDo81PcZFJyg3ljDq3to97BsPFlJJ3xlWQoPFHP7AWZZ+WcJRTE3aimGYXoOpflsrkKr4aZ5jI2tEj9iyLQa7HraegCmJ0bB3gBDNTuPRy4DaHdT6cB+ijJ6o9ne+mC73c2MoeeZLQbOn2SDq/bxZF3g/z5wUOZiYnyMb4bP2eP4zVq8/kB3TflwkhPA1bO4dk4k1sWKOGXSBjMTgNN36kNjS3U7b/UWPevs5mirfG4RQkSAvB8LIdRz3sRAcsKgZcEYPD0DnRAdFo4JTJFTwHXqesoajeXX6zj+sTU9QZITMcNq4pnPkW2L6KhSsvnESvTvH+LF7bR20dZFl5e3bwn93CW/wv+8xKRM5hdQmk9SLC/XSDLx75sob6KskbLG4YwWhYQCz22jysFjH1OSzeUlLOs3j/ib+Vi0XJ9FgiSbRo8fLee5rXyhFGss/4mJwfnteB4aT5WHHU50sZea6MNmZppkUE/m5vmcN5Gt1WypxtNDonHYj/TFnGByYnICdd2SnBiI1cSCMXxwGKOOxUXD33F9BL81IQBr/09x8ZOcKOm/gOu9g5KcEEJEgCQnhBDqmZXL0mLmFXD2uJgcFdWc9t5Gq1ESjZrjGwl0eCITlAiNHJvaEYDTw666YLfDE/qNKPY1cKCZA828thethvtWcNa4ED9FJCWbmZvP3PDX4DqNskaqHIH2rjrm5J3wdQ3cImnK0SbFwq2L1A5CRI4GCkwUxODnGjEoGii0U2hn1bQRPtLiZEqTmGnli9ksTA71jIj9jTy3lawksqxkWpmbr/ouIKFx1UzOGseZY0mIi29HxKYTkhOdcZOcKLRjMwfK+vGpLfGEECI8JDkhhFDPscHQ+KVY+yQn2iU5IYYopX8xjdau0CcnNlYG236FSVJ2ecTeLu/XXTYKyq8LIYQYFg1sKg3bKs1Dzbx7MNj9xxfiJDkxI2cIiyMdbpJMUjRfhFy2kZ+Nw6ojUYtVx5xYqEw8KFoNN87l4Q8B0hK4ZrbaAQkhRgVJTgghRLgoSSbqnBh0JJuxxMUNoYikEyp9t3VBSoifYmNFsF1o//QeCWLI7BbSE2nqBBifRlGof2UiqvT40WvVDkIIEcPCOGredx8mvZbUPhWj/AqNTiodVLZR2cZXFmKMx1KDCvx4NU4P31zC9EHsNi7EoCXrubtQ7SDC5PLpTMnkSCvzC0iTSnNCiEiQ5IQQQoSL675zktJTZLc9MUyZVhYXkWLBbiHFQk4YMgfnjMdsYEctXh/z4/UeK7Kumc3nZrGjlrfLGZ+udjQibPwKf9rA1mr+eLnMyRVCRKP6jmA709rvSrX2ED9eHex+Zlp8ptLfP8jWaoDb/smKiXxloYy0CjEwDUzNYmqW2nEIIUYRGTITQohwUZJMkpkQw5eeyM8uDO9TXDmDK2fg7mF7DZlxsyJdbVoNs3KZJTtLxLXX9/LcVoBXdnNZidrRCCGi1dObGZvKkrEqPHVGIsVp1Dtxek58i8+39+tWtsVhcsLt5ZGPgt3VZaycIskJIYQQIgrJqJkQQggxupn1nCHLJoQYivcPBRqPb2Bp8Yk7xIiY5Vco72JzB5udXJnBApvaAYmY9t99/GUjGvjqIq6aGc4STidz83xung/Q2U2Xt9+X8vu/sqvaIhdVxGypDpRYPGbZeJk0IIQQQkQnqZMrhBBi0A41c7iF1i78itqhCCHE4IT8euVX2FUXaHd28+3/hPjxhUq6/KSsY/JGrt3Lg5WsaVU7IBHTttXwwPsACvzhIx58H59/MOd1+3m7lVBethKNpCf2+x+zgYzetRRJJnoGFRiAX2FvA53dIYwuXBYV8fiVga2zzQa+ulDtgISIlG01vLKb9w6yrYaKeEw9CiHijqycEEIIMWgPfsDOWgANnDuBe5arHdBpPbMZl5ckEzYT49KkdqoQo8jOWt7YT20HNe20uHjjS6HcGeJAE64+05Avmx6yRxaqsmjJNtLeE+hu7jjt0UKchl/h4Q/7DfofbcOvMIhtp59v4IZ9zLByRz6fz8QYpsmE3z2bBCMFdpLNQzirroOv/AMgLYHCFL58RlR/uBqfxsOX8k45nd5gMkaIuPfOAV7ZHWhnJ/HCdapGI4QQA5PkhBBCiEFr6wo0FDAN4g5bXa/upa53bGnVtKi+fxZChFZtB6/uDXYbnWSFbkv5MSn85jPsqGVHLbvrmC2lQuLHHCtlrkBbkhNi+LQafrmSu/9LWSNAgZ2fXoBh4A9OCjxYBbDDyY37uPeQsj+j2djgpNHJqpJQFoaaP6xyjsdnYTe7aHahiXClqqHTwLIJagchRGQ53MH2kLKPQgihEklOCCGEGLTWrmDbHvU11js8wXaSSb04hBARl9M/FVHbEcrkhEnPnDzm5AH0+NENd2Kzu4d3DzAtm0L7wAeLiChN4vkGAJOWHBNdfixSBHd4ntjI0TZau2h1cXYxX5qvdkARl57I71Zx/9vsqOX/LsI2qM8h77Sy3Rnsnrthv/Ff7/Z2JgzyQcKoon+xszi7drV1sbqMDRX86uJQLrYTIsL6JSei/n5NCCEkOSGEEGKwvH6cfYb7o3wDWL/SryZySJITR1tZXcZlJSfWbhZCRJuc/tu91raHaytU/bCGro+28u89vLEfp4fLSvjWklCHJYbp4jRS9ZQmMTURw6AHJ5u92PRDOD46aTq60RhJMITm4dYd4UBzoF3jCM1jxhyzgfvPp7advORBnvFh/x/VHR9tD3YaOqIgOdGnfn1aAolG9UIJqSoHf/qYdUcClbg2VXLGsFaWCBEN+t6v2WXlhBAiBkhyQggRlfxK1E1ZOtDElmompDM+fZROw9dp+NNnA7Mg27qY2X+kr8fPU59w4WRybac4P7K6vOTa6PDg9KCMLDnR7eM/e/j/7N15fFxV+T/wz2yZfcvaJE2apG2677SUtkALWDalIlDFsupPAdkUv4LfAgoqlEVRUb64oKIgaIXalkWRrQWB0r2lLS3dszX7JJl9u/f3x0wzM2mzzXpn8nm/+sc5yZ17T5PJzJ3znPM8bxzAgTYAMKhx9cxkDTOsx4sjLTBrYFLDpIEuL5mpG4hGoHwdRptRqEepCaVGjC/M9IBi/egtHGoPt984gJvmQ5ukGWFKzEQdJuqG/ahbPsN2B35Uha8US+7mZehUL+3BP/agUI8KC8YX4tYFCZ3OqgNOBic63QMemiVs7niWZchlQ49MAPhhFa4qws8b8FwLluT5p7R2Rr7X6sC4TL+UXT8Hi6pRZ8PxLmgkNpPgC8Lpi3PpjEaJ949COFmG/NVPGZygLPb7q+DyoduDbk/S4s1ERKkksVsKIhrhBBF7mvHmZ3jvKP64HAXDnyFInY+O45nN4XapCc99ZSi5g3OKXIYJRaf/VqsDD76JPc3YXI9fXw6VBLJg6PPw4goAEES4fFAm8MtSyPD8dnSeTEP+xgF8ZWZygwfyQx2451+R/u+vRG0/P2oiGgq5DH/9aqYH0b/LJuOJ98Jtlx9vH8LnJ2V0QBS/7Xb8ow0AVnyKx+rxy3E4NztT3cgbewCg3Yl2J3o8gx0+mOg5Ypur/+OyRJsDVz6HCgtmlWFWOeZVwJCqdSqT9fj9BPykGj2O2G+0OVN0xWEoMqDIgPlSmrgXROxswlsHseEwzqnB95fEc5JCPeZVYFNduPvBsThjUURSIAP0edDnSWXFGBHRYBicICLJaOjGXevRcvKj2DuHcNX0jA4o1sH2SFuGEReZGMDmevz4TfR4AWB/K37zEW5fmOkxRZHLEp1BUMjxufH4+8nUCkc7cbg9yasXu2OngVi8jii3fa4WT38Etx8A1Ep05cS68pFq5dFIe5cDtkDmhpIYWX1URqGKhAMsY6wYXwirDvnaYW0dkKgdTQBQ34X6Lqzfh6cux9RRKb1gSR5K8lX43mIU6VFsQLEhd3IoJdeDb2LD4XD7vSO46xzkxXWLfsmkcHDCrMGFEyCKgz2AiIiIkoPBCSKSjFIjvMFI983PpBuc4Kr2aEp5TOnpl3ZjYVW4VGzOuHBCJDhRaekbS0icPfaEJgYniHKaToXPjcfuE1g2BUtrU7cEm1LtiBvvRiXhP9OEZZnOuxMnQZSfsEe6iQcnrpmNa2YnehLp2N4YaWtUmFicputyT9Wg5lZEghNOHz46jnNr4jnPgiosGYvFY7GwWhI7gEnyTvhwzANHEM4gvAK+nK5XBSKi3MPgBBFJhkKO88ZizZ5w90Ab6ruS8PE4KXxB+KICJ1JLX55Zs8txw1z8aUu4e81szCjN6IBSYGwB5oxGpQUXTsDE4qQXhJD1RNXuVsmhYX5Yolx360Kolawuk+1qtDgwDw8cw3MtEESsqsnaX6kgelaeq2nzoL4LdV2o5X1OrOjgxPRSKDl5LRnn1uAX78EvhLtvH4wzOKGS44GlSRwX5bw/ncC9J3fOqWQMThARxY/BCSKSks/VhoMTU0pwQS0skkn2mqfAy9fB5sbBdhxsx7yKoT7w+e042A67Fz0eTC/FHYtSOcrMuW4OdjXhcAfuu2AYP5zs8sQXUnfu4GWTFOfUoMeLHg88gZjJraCAbg9sbtjcKNChOj/Ri/12EwQR8yowvZTZyYgyRmq1ZCleVRo8OxF3V+DldiyRxoKKeCjlwfkV0OszPQ5JEoH7z8f2JuxoxJ5mzC7L9IAoilGN+WPw/lHMKMMF47E4rsgE0fAZom6i/SJ8AvIYtSQiigs/FxGRlEwqwW0LsbBKovW7rFrMqxje5Pu2hshquxwurCeX4QefQ1BAIec14mJSo9B4+m9d9Rw6TpYSvXJ6ovU8ggLW74PDi7/thEaJa+fkVNoNIqIMmazHZL4B5ioZMK0U00px/Rz4gggIgz8ks/wCFDLIs3Ubz7B9cz7uWIRiQ6bHQSOLIXaFj5PBCSKieDE4QURSIoO06kwkLrp4QI+3/+OyXw6HXjLLoo0EJ2wJV83d3wbHyeehJwALi1sQERENWZ4iznrL6fT2QTy2AUV6lBhRYsBd50Cb0+kiK7N3yxJlMX3sK4EjCCtn14iI4sKXTyKiVDJGlTntSXYVZRoJopObdSUcnNhcF9OdW5noCYmIiEhSWhwICmi2o9kOhRz/e96QHiWII2izBVHCzrPig1nQK2BQwKBAYU5HAImIUorBCSKiVBptxoQimDQwqbnfnOKRHxWc6HT1f9zQFOkxoQgH2gCg0oISPieJiIhyS6s90i42DBRyePsgdp1AQzfquzChCD+5KA2jI8oNRSoUmTM9CCKinMDgBBFRKn1lJr4yM9ODoGx26SScUQGrFlYt8nWJnu3zk/H5yehyY2tDMgZHNJI8vx1b6jG9FNNKMXUUdFwkSUSS1OKItAdehfD+Ubx7ONzO7dRPREREJFUMThAREUnYrPLkn9OixQXjk39aoty2pR47m7CzCQDGFuCPyzM9IEoHt4AmL8ayrBJlkcunYnopWhxosaO2cKAjK6KqNTR2Syezk0qlWrp0aW939OjRGRwMZaklS5b4/f5Qu7a2NrODISKiATA4QUREREQ0IL+AfS2R7tRRmRsKpcO/O7G6Fdsc2OtEtQYHz8z0gIiGbmEVFlYN6cjo4ERAQLMdZabUjGl4VCrVhRde2Ns1GJiFkobt/PPPF0Ux1NbpEt58TEREKcPgBBERDUGzHW8cgEULixZWLWoLoeH2fyLKBgEBOxrx7mFML8VFE+I8yWdt8AUj3RmlSRkaSdY2O/7UHG4fcqM7ADM/NlHuGW2GVYsKCyosqDAPlNnpNx9BIUelBZVWVFqgz0vjKIkkTBCxqQ4v78ZVMzC/MtOjAe5/A3kKmDUwa3HGaEwpyfSAiIgGx7tsIiIagqOd+OOWSPfZL6M6P3OjGYwg4sa/Q58HoxpGNS6eiDlMCEA0Iv12E179FD0eAGjojj84oc/Dsin4pBlHOyAC01IZnPAGoOYteobNMcZ0dziw2NLPoUTZa1IJ1t4w+GEisH4fnL5w96rpuG1hKoclMR0uqBQwqTM9DpKel3bj5U/Q1AMActlAwYl2J7Y3YnsjvnN2Ct/igwLePwLxZDdPweAEEWUFfvIhIqIh6HLHdK3STr/t9OGYLdKdWZbay4mAJFI0E9EperzhyASA3U1od6JQH895qqy46xwAsHuxvxXFKcgxIgL7W7FuL947gueuRgFzUGTS7Njf8DY7Fluwrh3nWmBJ4ucntx9qpUSy/KeKIKLHA5sb5WbkKTI9mizUYsfm+nABiRYHHr4IhuTNkg/xqdfpikQmAFRakzYAKQsI2HQcr+3HpuP4+jxcMzvTAyLp2d4YjkwA2FyPui5UnhLH/qwNP34LdV3h7tJazE5BPbkQuzcSmQBg0aTqQkREScXgBBERDYEtKjghA0xDu9n9uA5HOnGsE0c7sbQWV05P0ej6sntjukn8GB+t24N3DuGNA7h2zlCTOxNRmp03Fq/uC7dFYOMRXDEtoRMa1Zhbkfi4+mqx495/42B7uPv6p7h2TvKvQkNWnIfZRhSrMNuIOQYsMOOwG1fuhUGBeypxRzl0CU6zCyJ+8jbePgirFj++MLV7cTLlk2b84A10uSGIAPCHqzBuwOLMdFqHxj1KfgAAIABJREFUO/DTjZFuiyNVdzUDqLPFdE+dfs1Jt6zBZ23h9uv7sWI2V6JQX1dMwwfHIt1/7sGdi/oeU2SIRCYAbGtIYXCi2xPTNTM4QUTZgcEJIsoGInDchqpMLNTq8cKo5qcR+INQKeAPAoBZO9Rlnj/biBZHuD0mjb++PsEJY7I/xgsiHnwT/z2KgAAAbxxgcIJIomaWwaxBtwcyYGY5RhkHf0hGFOhjYsCv7MOK2Tm+oF7ytsWGh1Z8ioCIrgD+9wh+2YB3Z2JiIptbNhzG2wcBwObGrz7A765MZKiJkPd4Na8eDJYb5dWFmKBKZi0BrRKdrki3093/odS/4thXrRYHxhakewwBATUFqO8K3wem844ug+aOjgQnGruxqynlO3Ep68wejTFWHLdBLsOCKpxbc5pjrFrUFOBIR7i7vTGF45HJMLsc3R50e9DthlnaO92JiE5icIKIpK2xG28exFsHUd+F1degJO3zSnetR4sdE4oxsRhnVmLaqHQPQCKuPwPXnQGXD90euHyDHx9SlR8JThztTNHQTkOfh4snwuGF3Qu7F/nJzo4il8EXCEcmAHx4DJ4ANHG+peZ93Kio/wz5epg0KNTjDJbHIEoehRzXzoFSjnNrkv9SkERKOS6dhD9vDXdbHPi4DmeNyeiYKGKXAy+0RLoWJcYlOOfz8/ci7QNtEMRMxaIUx7t1L38a6f/68qTd6lhj/+Jsrn6Ok6p1e/GfzzCrHLPKMHVUxirBjIpNMdZqz8AY5lbgTxUQRDTb0dAFy8iY8bxkEv66I9J99/AgwQkRuGMttCrMrcAV0xhdHhFkwIpZONqJL04daPXDnPJwcEKjgkWbwhf8Sgt+flm4LQ54JBGRlDA4QUQSdqAN33wp0t3agEsnpXUAviCOdCIoYEs9ttRDEEZucAKADNDnDW9NZU0+Pq4Lt4/b0jf5MtqM7y9J7SXOH48Pj4fbfgFN3aiJcyVj3vYTireOhjtlJry4IhnjI6KTrkpXQrkEfX4SntsGQcTkEiybksK0DzR8Rz3IV6HTH+7+uBrKBN/NagqwsynStXszlX9D0RQ72T3anLRTWzSQRU2QZd3Oic312NOMPc14bhtKjFh9TWaGoVdDp0JQRIkBJca+IZ90kstQZkKZKWMDSLPRZswowycnsKAKl07Emf3XOg7xB7H7BAB8XAe3H9cxNd/IcOGEwY9ZPBZGNWaPxsRiqOSpHxMA1sMjomzC4AQRSdj4QujzIiX4djalOzhxqB1BIdKdUJzWq+eAqnwAKDKg2orqfPgC0KgyPaYk6U0yJpehSA+Xf8CjByK3R+1EYXJYohGr2IA7F2HqKObll6AvFmKJBT+rxxMNmKjDFUUJn/Grs3CiB2YtNErIZeGqDJmgaIwKTujzkrkoXiHH1bOgU8GqQ74uA8mIEiGIMdGjqZlbmyID/nEt9EwxmgnfORtmzVB33UXvDXr/KIMTFDF1VCZfQ4iIJI/BCSKSMLkMM8rw4bFwd3sjxPQuAznQFtOdmPhsxAhzbg3Ork5mAmvpqLDg6S+h2IB8XYLbQWTRwYkhVhonopz0xamZHgH1y6zEj6pxazna/cm4EzmzEquvTfw0iZP5glDKw4kKKyxJvsu6aX5ST5dGh9rhiKpfNTujxQbSXwGbQqrzh3Hw7z+OtNsc/R9HuePVDuxxwhmEI4gyNb5XkekBERFlJwYniEjaZpXho2MYW4hZZZhVDlGELI3RiTMrcdc52N+K/W3ocvetSTgsIuDxw+VHgYSTniedNlf2SZxKrcTkkqScScyTQ6cK771I0c4JvwCPP/mFwYmIRpiSPJTkVsDdcfMcxzdmKdrd2javRscA+Um6PFwxDTuawpniZzHNGg0mOobU5UZQgCJdCXwoQ55vwd9bw+05RgYniIjixOAEEUnbxRNx0USYMjSpWmbCsilYNgUAAkKcywlf2IHVu9DjRVCAVYu1NyRzhJT9eu4/x2Qy5cmVsHtPf0S7E3uaYXPD5obNhVsXDrv49r5m3LEORjXKTCg345tnonTE5IwmIqKBKeTBEn2wqhB6faaHIhmjzbhjEQB0ubGnGWXJK8VBuerzkzDGigIdCvQo0KV1NRVliF4RaTuDmRsHEVGWY3CCiKRNOmu9lfGufhJE2E4WgbR7052ZirKFUg5rP5m+P2nGA/+JdL86a9ihhaYeALB7caANB9pwy1nxjpKIiGgksWixqDrTgxiyYzbU2VBiRLEBFm323nAKgtDS0tLblcvlGo3kt/WMK2TFIElpbW0VhHDtwKKiIp0u+ZvXDVHBCQeDE0RE8WJwgogoxaLjKwEBHn8uJzuiVOgTtLC5hx2caOyJtFUKFHJtLBERUc557wj+sDnc1qrw+tcTLIuVKR6P57HHHuvt3njjjYsXL87ccCgrPfnkky5XuEr5pZdeunz58qRfQi+HQgaDAnoFSnMr4x8RUToxOEFElGJ9Shz3eBmcoOE5NTgxXE3dkXapMUunKoiIiGggLVF1mE2a4b3dO31o6EZ9F6aXotiQ9KER5Z4fV+OhmuzdoUREJBUMTvSrra3t7bff3rx5c0NDg0KhmDRp0plnnnn22WcnZT/g4cOHN27cuHv37sbGRoVCUV1dPWvWrMWLFxcXFyd+ciKSliorls+ASQ2TBka1hBJVUbboDU6olbBqIYjDPsOXpmHqKDT2oKk7obruRCPNmwdh92J6KWryGdUjIqlrtUfaJUMOMHS48PXVkaUP956PpbVJHhhRLlLwvoCIKBkYnDgNURT//Oc/r1mzJvqLW7du3bp169NPP71y5cp58+bFfXK73f7www/v3bs3+ot79+7du3fv888/v3Tp0ptvvlmp5O+FKIdU5+PWBZkeBGUzowYvroBVG/+em6mjMHVUUsdENDKs+QT7WgBAn4dLJ/HFnIgkLXrnxNCDE1Yt7N5It6ErmUMiyiWtDhyzoUCHQj1MGm6aICJKCk6C9yWK4q9+9au33nor1NVqtdOmTXM6naFwgiAIP/nJT+666674sl663e7bbrvNZrOFugaDYfLkyYFAYO/evV6vF8B//vOfurq6Rx55RC6Pt/QuERHlGBlQNswiE0Q0KBGDTCt4AjjQFm47fakfEBFRYn53BVqdaLGjxYFRQ94oKZeh3Izj4Y+oqGNwgqgfm+vw+MZwWynH2hu4J56IKHEMTvS1adOm3sjEPffcs2DBAplMBsDr9f7pT396/fXXATzxxBOTJ0+OIwXTk08+GYpMaLXa++67b+rUqaGTC4KwcePGn//85wD279//z3/+84orrkjif4qIiIiIAEAEDrbh3cN49zAevxQVln6P/LQFQSHSnV6ahtEREcVPo0KlBZX9v6z1p8ISCU409kS+7vRBo4SCy+aIAAAdrkhbBhikFJkQRMhkA6y6CIjY4YDNj6X5aRwVEdEQMDgRIxgMPvnkk6H2Aw88MHv27N5vqdXqm2++OS8vb+3atQB+//vf33vvvcM6eU9PzwcffBBqP/bYY2PGjOn9llwuX7JkiUqleuyxxwD89a9//eIXv6hQKBL87xARJcfjG3DCDosWVi0ml+D8cZke0IACAuxeGNVQ8rM0EcXqcOH2tWg8WSJ+w2FcO6ffg7s8sGjRdTIPewZzow26yYOIKBEX1mJGKSosqLDEbLn4zUd4fT/Kzai0YHIJvjorc0MkkoDo4ES+Lv63Zpcfu09Ap0rmuocNh7HqHZi1MGtg1uCHn4NZE/rOS214thnvd6MngIk6fBp/knIiopRgcCLGjh07nE4ngJqamujIRK/rr7/+9ddf9/l8H3/8cXd3t9lsHvrJjx8/HmrU1tZGRyZ6LVy4MC8vz+fzBQKB5ubm8vLyuP4TRETJtrcFRzvD7aW1Ug9OHOnAN14CAI0KRjUeXIopJZkeExFJQ74uZjPEOwMGJ5aMxeKxaOjC7hOo746Upk+PoID9bdhchy31mFuBG+em9eqUIi0O7GvBuAKUm1lineIhAt1uGNVJ3s1wTs3pv17XhYCA4zYct8HuZXCCRrro4ESBPp4zrN6FjUfwaSuCAhZVJzM40e2BL4g2B9ocAKCOLHXd68RrHeH2fhdO+FCal7TLEhEljsGJGG+//Xao0V9WJYVCcckll4Q2T3z00UcXXXTR0E8eCnsAKC09/TuQTCYrKys7duxY9MFERJnXu3AYgCXe6TkR6HThWCeKDQPlUUmc42RqeI8fHj/3TxBRhAxYMg4v7gh3j3TguA1jrAMdH1pKnH53rsMnzeF2QGBwIkdsqcfjGwBAo0RNAR69FCY1RMDphVoJVS5um253osWBThc6XdCqsLQ20wPKTofa8X8fodWBFjt8QTz7ZVSnJTNLb64nIJ5sUUQ55nvn4vo56HChwwV9XBP8+9uw5+Sb+45GBIWkBRq7PZF2ngJqVW9viQUPRB24oQtXDztDORFRCjE4ESGK4scffxxqT5o0qb/D5s6dGwpOfPDBB8MKTvTWqNi7d68oiqFqE9GCwWB9fX2obbHw5o+IpEEQY2524whOiMC31+FwB+xeALjhjNTOsoWu0iuldeo+PI5Nx9HmQKsDeUo8/aUUXouIkmLJ2HBwojofS8ZJt5Tl5JJIcOKzNnR7evMzUBY73B5ueALY14Lb/4keL7o9CAr46ecxtyJ9I/nvUZi1KFUNfmSCfv0B3j0cbo8rZHAiftsaIu1WRzqCE3YvbFHLUyr7j+MSjRAWbfzrtEJml+Ptg+G204fP2jEpSYGC7qi/VrM2OuXUmSZo5PCc3Di63c7gBBFJC4MTEQ6HIxAIhNr5+f3e7ZWVlYUan3zyybDOP2bMGJ1O53K52tvbN23adNZZZ/U54JVXXgkGgwBKS0uLioqGdXKiEUEQcbgDOxqxowlLxqbw8+0nJ/CfzzCxGBOKUW0d6WUAfUGcNw42N7rc6HKjQDfsM8iATlckZnDMNuDRCesTnEhpqbp9LVi3N9zWKJkXnigL1BbhWwtwZiWqpD3RNq8Sf98VbovA1gapp9SjoTjUEWmPMsa8IXZ5Tj08VUTgyf+ixWExq33zyj1LqgITClJ1rfyo2wabq//jpOH3H8Oixaxy1ORLK+9WsTGm2+JIx0VVctx/Aeq6UGdDXRdqWEWXKGFzonJ3y2U42pm04MSCKpi16Haj29NnV4dajiuLIAOWWLHYgioudSAiiWFwIqKrqyvUsFqtcnm/c5FGY/jWUBCEQCCgVA71Z6hQKO69995QGe1Vq1Zdd911F154ocFgANDd3f3yyy+vW7cOgEwmu++++07dV0E00onANS9GqphqlSkMTmxtwPp9WL8PADQqrL8B6hH8aqlR4v4LEj1JVT7qwq+xkfIVKTKzDN9fArsXDi/sXhhSmVS1KCrbrCcAuxem4cVCTD96D56AIl8PixZnjek36TMRJYsM+PKMTA9iCKaXIk8BXxCVFsyrxBjuqc1+YmySnDmj8dqnkW50BsVU+6wtNLst7/Zq3jwSLNKlKzjhhiBmZtJfBJq6UT5gvUBvAH/fCb8AACYNbjoTn5+cntENzqiGRgWPP9xtsafjohoVLhifjgvljKCArQ3ocKHDiQ4Xzq3BLFaRpFilJpxZidFmzBmNmWVx5oY6rbkVA2y/e67fzCBERJknoem2Dz74YOHChRkcQE9PT6gx8K4FlSqy/dntdvfGKoZi2rRpTz755KpVq06cOPGXv/zlL3/5S58DqqqqVq5cOWrUqKGczefzDXyAIIR37omiOPRBZqOc/w+mWu8PUBRFKf8wZWMLIsGJHU2iIKZolbrsQFukU2IQ8xSI98ci5Z9nOsmq8/HekXCnoVv0BaFK2X6UchPKTTFfSd1voVAf/RwUW+0wDu8zhvKzDpnLD7QDQL5OPLs6mcOjXNHnlUTir9WUHCo5fnwhqvJRYgh/Zci/9NDTg88TKXrpWhy34VCH7HCHOLtc9u4huE5ON3d70vb7kv33aHTXN390qJGSAVg0kTdKhUwcfhQ/OT5rk33zZUwuES+agPPHnX5C8JMTMv/JvCc9HlGfN9z7h+g76oRGezqyxTUQgRKDWKzHxJIU3ttIQPa+68m+/zqEk0+DAh1mlqXuWil9vuUeCf2UHr0k0j7lqd6nIWXZ+3c6RDn23yGSMgkFJ5YsWXLttdf++te/1moTy+IXL7c7vF6poGCgpUMymUwul4fm/YcbnAAwZsyY22677eGHHz615LXVav3ud787xMgEgOuvv/7gwYMDHDBjxgwAgUCgo6NjgMOyXTAYzO3/YDr17h+SJm2tWf/eyU6nq+uTY8Hy4f0BDomI/H3NvRPn3iqTPd4nmM/n45MzRDXWoL5wbKDSFKwwByvNQk+KMzuli1ITNBXohEJtMF8rFOo8PmdwWL/wgFDYOy0FOBVBN58wNAQ2W478BdEgxukBLzq8gx95On6/n+9BUmSVYW4h5hYC0J9XBUA0awRjXmBcfiBdvy/jkdbe+ECw3Bi6m3K73b2fhpJIXmtU/HixYNYIFrWoy4PfgY60pCSKZVi7SwNgX4tsX4v4q//anrpYOCVNpe7Dw9FfslXphLh+I6n6bPKN6THdnP7r7vNU9Hg82fJqlm9Sy0+maPM0djpTP2x+Fu5P9Myy1+vNop9Slv5OHQ6Hw5GBl/fUcbnCqQh7V/0SUYpIKDgB4I9//OP69evXr19/aj2GNPB6w5/98vIGWfeqVqtDN0zDfZHq6el54IEHDh06FOpardbx48cHAoF9+/Z5PB6bzXb77befe+65d95559CzRRGNHP4p4V1NQr7WP7UoRUvGZN5AsMIs89tkLj+AwHgm2E0C/5Si3l9fLgmMMXf+7tK4Hy53+qO74jB3XRARUVZz3jgzI9e1f2e+85pp6s1NeZsa/VMKU3otIV8r5Gdm5VkvmV9Qv1fX2w2ONp0amQAAlUKwauQ2D4BApVngmzINn2DV9AYn5OksJEMZcneToc4ndwoylyj7gsn37SLJV9YhIpIeCc2Ah6ostLe3L1iw4Oabb/7FL36hVqd1z+/Qyzz0HjmsfV4ul+tb3/pWKHnUmDFj7r777oqKit7z7Nmz59FHH+3p6dm4cWNra+uqVasGqHtBNDIFRpsct871Ty4MlhhSV3ZY1Ci7HzwXgqg44VAe6gxMTMKHdpkvKG93yew+ucMnc/h888pFrYRefimDvIurZHav3OGT2X1Ba/Lr0+VtOyG3eYKj9MESg1CglVZ5TyIiyhChSO++dLz70vEYAVkrVLuaZY5IOlzv+afPoOi6apLrykmKJrtqT6uYp0jX6CinCPlaHO2CXCZYNKJONfgDKMu971Qd8oZfLqZpApkdjD0o80OWr+AyfyLKMhKaHTt+/PjVV1+9YcMGAL/5zW/Wrl27fv36uXPnpm0AvcUkBq3l0LvHIrr+xKCefvrpUGSiqqrqiSeeiN4bIZPJpk2b9tvf/vamm27q6en59NNP//Wvf116afyrcYlyk1zmOa8qbdfqTXSQONWeNtND7/d2bT9fGqwcsCQjjQyCWW2/fahvc7qXP1Uc75Z3e+XdHt+MkiGut9X850je1qZQO1Bb0LXqvDjHSkQ5QIQsKMATgEohqjn3SgCQutUe0uGbU9a16jzNO8fUH9TL/EHPon5rxkKGJN7+0QjkuGk2lArBmMflICOEXh4J8DqFDP/SV57Qv+PI+/VoxxLDIDNaRESSIqHgxKhRo9555521a9dec801Lperubl53rx5d9xxx+OPPz5onqWkMJnCBVQHTrsvimIwGAy1h763w+Vybdy4MdS+5557Tpu1Sa/X33333ffddx+AP//5z5dccsnAmzluvPHG7u7uAQ6or6/ftWuXQqEwGAwDHJaNvF6v3x9OhyKXy3W6023NpiETRTFUBEWn03HLToLcbnfvS4RSqdRoNADkxTGhCL2gFHLur5Li43Q6RVHUaDSDZvPL29Uq39saaqvLzbKhPYVUbZHd5bJSU+69HYwQgUDA44lkh9Dr9UPf7kkjkM/n8/l8ve9BAOAPapa/CE8gVKnVf+v84GWTMjlEkobQe1CorVKp0rxtPa1mGzB7jPe2gPxgu750oPqCifD7/V6vNyOfTRRvH5ZvbhCL9WKxXhxlFOaOTvMAkqvP5xGVSpU1NzBpHGcGn29ZR6lUpugpZFTJcbJCik+e6BM1kd/p2k7F37pUAJYfM90yKviTCr8uxYsQeucQQobycSa79N5s866bKNWk9dohk8kuv/zy5ubmm2+++YUXXgDw5JNPvvzyy6+++urMmSlPyWo2h2cPOzs7Bzisd04cwwlOHDlyJNQoKSkpLy/v77Bp06YplcrQHERLS8vAxbGXLl068EXXrFkDQCaTRT6a5opAIND7i8jJ/2Ca9d5YqNVqhYJLKRPi9Xp7gxNyuTz85CyIWYKX5xHAJy0BAEJ/enl5eYOH4QsMQDg4Ie/yDul1TxBxwt7bU1RYFXziZSev1xsdnFCr1Qwk0wAEQfD5fJH3IABqwO3vTeCjCspUfDUgwOVy9QYnYqJZuUoDzE3t3LHX683MZ5P97dgQ/ryJEgNWX5vuASRV7710yIh4csYlY8+3bBA9oaxQKFL0U5prgkoOgwIGBeYY5YlfJb7faZMXtx6NdJ9uVpxlVVxbkuBYBiEIQnRwIvci3L0vRAxOEKWaFD/ZGo3Gv/71r++//35xcTGAxsbGWbNm3X333dFRgRRdN9RobW0doJiE3R6e6FEqlUPf0tHe3h5qTJ48eYDDZDLZhAkTQu2Ojo4hnpyIpM4Ye6Nm92ZoHJTNrFEFRW3u/o+L0u1B9M10mSnJQyLKSYfa0ZlzBS1lgDoqGakntTfVRJRuzY5IuzjetFQN3fjXfvz+Y/zgDXz3laSMiyi3PTEO78zE+ml4YTK+23/GuFT71IVg1AzWpQW4JsWRCSKiJJLWzoloixYtqqure+CBBx555BEAjz/++N///vdXX3112rRpKbqiTqfT6XShBUQ9PT29Gyn6aGoKJ++ePn16HFfpswzkVL1rIQWBhYyIcoVJg4cvhkkNowYmNUxc30TDN9qMcYWwamHVonhoCz+tWrzxDXS60NSNxh5ML03xEIlywqp3cagd5WZML8XisZhfmekBJYlGGYlJeDNctJOIkqw1slESJfHuDnn/CH6zKdL1BKCR7nQBEfU634rdZ+D6/djQhUIVnpkwEsoJEVHukPTdhlqtXrVq1Te+8Y3ly5dv27atrq5u+vTp995774oVKwbYVzVx4sT4LieTyRYsWPDWW28B+Oyzz/qrxb1t27ZQY1jFuktLw1NC27dvH+AwURQPHjwYahcVFQ39/EQkaXIZFlZlehCU5ZbPwPIZw36UDCjQoUCHaYxMEA3G5Yco4nA7ADR2o7Eb+drsDk5sqcf4Qli0ALBiFoIC1CpolBibqpz7RJQZVfmQydBsh9sff3BitCWm29jN1wqiMJcfT30Yvqku0GHKqJg9zRJQqcHbM/BEA2q1GJWOmq1EREkj6eBESE1NzZYtW1555ZUbbrjBZrM99NBDDz300ADHD5CRaVC9wYk1a9acNvYQDAZfe+21UHtYwYmKivAeP4fDUV9f39vt4/Dhw6Gk0kqlksEJIiIiopRrcWDDYbxzCF1ufOccRN9ITi/L2KgSJvMEcP8b8AdxdjW+MBlXToecKymJctSDSwFABJxexL39viI2OFHfxeAEUVi7E6/ui3R/chHOrs7caE5PLsP/DCe11HEPKjXcY0FEmSfFmhOnkslkpaWloRIUKTVr1qxQDZ+9e/du3br11AOef/55r9cLYMqUKcMaj06nO/vss0PtRx55xOfznXqMz+d79NFHQ+3LL7+cdYmJKPP8Apw+xB/zJSKSttc+xfLn8H8fYn8rmu1YvSvyLRkwNYtzNis3HoPbj4CAdw/jrlfw1sFMj4iIUkwGGNQwxVuTttwEGaBShAOZnzSjrgsBphomQt9iVAW6ZJ48KOBAW0JnONiO/a040QO3f+APbp1+/LkZN+5H1SZUbcKRoZWxIyJKqSzYOdHc3Pz1r3/99ddfD3U1Gs0555wzQFqnRCgUiptuuunJJ58E8KMf/ejb3/72kiVLQtfy+/3PPffc2rVrQ0fedtttpz78qaeeCm28qK6ufuKJJ/p89+abb/7www+DwWB9ff1dd911zz33jB49uvc/cuzYsVWrVrW0tAAwGo3Lly9PxX+QiGh4djXhu69ApYBFC6sWDy6VelHlZjv2t8KoDv8rMXKlMBENZEbs3ogKC66fg0+asesEPH4Y4p3jSzoRqO/C5jpsqcf/OxPjCwd9RN4bhyIdrUqCazyJUuiRd6FVodiAYj0mFqP89NUEKYZKgX9ciwI9Xv0UP9uIl3bjpd1QyPHydVLLYEOUbh3OmG5SghMdLrxzCNsbsasJTh9WXwOzKs5T/eoD7ArXRsXCKjx8cX8HHvXghv2R7oYujOUfNxFlmqSDE4FA4Kc//en//u//9n7l8ssv/9Of/tRfqeqkOP/88zdt2rR582YAv/jFL373u9/NmjXL6/Vu3769t0L1TTfdVF5efupjg8FgqN71aWtZG43Ghx566Pvf/z6Aurq6W2+9Va/Xz5w5E8C+fftsNlvoMKVS+eijj4Y2cBARZZjNDQD+INocaHMgT/I7urY14LENke4rN7L8OBENZLQZ4wtxsD3c/fAY7lyEGWW4JqOj6qPHi/+3Gi2OcHfqqEGDE/Jur7z3eADnj4c23ikPStwzm/HRcYwvxLgCTChiEaCU8wv49/7I8uGb5+PqWZkcT7KEsja1ONDiQKsd59QgP6nLtwEUGQCgzhb5ikYZrltDNMKVmtDhhC8IIDl/ei12/PqDSHd7I5ZUxXmq7qgdEMaBppJmGmBRoisQ7r7bha/zHYmIMk26wYlt27Z96UtfqqurC3VNJtPq1asvvPDCVF9XJpOtXLny2WefDW2ScLlcH3y8vyibAAAgAElEQVTwQfQBt956a9zDmDx58tNPP/3QQw81NDQAcDqdfU4+ceLE73//+/n5+fEOn4goqWyxW5jNiU30CyL2tuBYJ4524pgNX5yCc2oSOuGp7N6YbjpXPXsDaHPC48e4wVc0E5GELBmHg+0o0GHxWCwZh9Rsz02ISQ1FVC7WzfW4ds7AjxDMavuzl5t2d+KVfdjWgMsmp3aENLBPW3CoHYfaAWBCEX53ZeRbTh9sbnR70O2GPq/vVp5kCQhYvQsLqzDGmpLzD8wTwD/3wOZCpwudbnxlJuYNJy16HDqdMYlNiuItEC01B9vwjZci3TIz5iU7OBFyvCvSrrQwJz0Rzh+P88eHA4SdbqiSsWBrQhF0Krj84e62hgSCE55Ie8DPawoZzrFg/cklGe92QQT/xIkow6QYnHA6nd/+9refeeaZ3q9cd911//d//6fX69MzALlc/rWvfe2yyy574403tm3bdvToUaVSWV1dvXDhwvPOO89oNCZy8vLy8qeeeurgwYMbNmzYs2dPfX29TCarqqqaOnXqkiVLqqqqUpSxiig3tTqwoxEuPy6fmoSzfdqKCrOEknhIQVfUMhx9XhJuxL+zHv5guD2hKLXBCX1emnI6/WEz1u5FjwcAKix4/up0XJSIkuXCWkwtwbRSSWeBm1eJtXvC7b0tcPqgzxvkISoFlozFkrFosaM4odtXSogIHOqIdPsEsFf+CztP5uKYV5mq4MSuJvx2E367CZUWnF2NK6cnf8X9AGTAbz6KdBeMSXlwojU2AUtRmj5FplxxbJSl1Z6qC7mj6iNWZiKgRSRNobIuyfq0qJBjZhk+PB7ubmuMs86fIMYGJwbZ6rTYgndsONuMxRYs4d83EUmA5IITr7322tVXX223h++0CgsL165du3DhwvSPpLCwcMWKFStWrBj6Q+6444477rhj0MNkMlltbW1tbW0CoyMa8dbvw4s70NQDAGYNlk1JdFLJL+D2tfAHMdqMicX4wmTMTM0EQXY5dyxKjOhyw+ZOwmpiuQxjLJE5mmOdiZ7wVNHBibTFmUSEIxMAWh1DXYAUEOD0QRC5Wokowwr1KJT83OW8inBwIl+HuRVw+wcPTvQqYWQiozpdMZH+cQUx341OmNOdssqk7x8NN+q68MIOXDE9VRc6LbUyZnWwLQ0FWEVMKEKrI3ytnNk5YdYiTxHOKgOg2THg0Qn49eXw+FHfjTpbFrw8EmWv2aOxvw1zyjFnNGaXx/+h4A9XodsT/jepeOBjbyrFbeVQ8QMIEUmGhIITbW1t11xzzX/+85/er9x+++2PP/44qy8Q0WmIYjgyAaDbg2OdqCkY8AGDOdYZXtHf0I2GbiwYk+gIc8OEIkwoSuYJq/IjwYmjtgEPjcstZ+HqmbB7YffGufgoDtErGb0B2L0wDeGd63AHvvlSgQyiPg8mDX74OUwc5LMEEY1cs8px83zMrcTYAkY0s89XZ+FQOw51oNPVd+dEdP6N6KWvSSSIkeAEgMklySnlOixWHVzd4Xana8BDk2FaaTh3ll9AhzN3dk7IgBIj6k/mXOpToTe5NCqMLxy0vA2dxtFOrN6FDhc6XOh04ekvYRQjxNSPL07FldMjb+ueuN4F5LJhfRDWSb6GIBGNNBIKTlRWVnpOvhZXVlauW7cuVCyaiOg0+mxr2NmUaHBif2tMdwKniVOjOh8A9HmosqKmAIKY5DwqWhW0KqS5sFufWY9Wx5CCE6HNFiJkDh8cPijlgz2AiEYwnSpHKvqOQAU63DQ/3La5YYjd8mKJCk50pSY40eGMqVlydrITKg5FgQ4OL/J1sGrTmiZIJc+1eeGb50MuR4kBJQboc3kNX15e5C9FLs+qe6QeD17fH+m2O3PtSZglVCpV77NIoZDqfLwqq57bRESpIaHgRDAY3qB6//3333///SqVKrPjISJJq7TCqg3v1teoYPcN9oDB7G+LtPV5KDcnekI6rUsn4cJaFBpyauVvdT6Wz0CRHsUGFBswemhPnp7YSShTYsXGiYhI+qynpAJfMg7jCmHRwqyJSfGUREUG/P0aHGrH+0fw3lGcU52Sqwzsl8skXdMliyzKxK8v7XQ63apVq3q7BkNWJeYqiF2z0pH6rUJ0Oj/84Q9FMbyNWqdL+XYxQYRLgEoGderDDa4gdz8QUU6RUHACwMSJE9etW8diDEQ0OBlw1QwAmFWG2qIkrDq/6UycW4P9rTjQBo0yp6bOJeXUeZkcMMqIWxcM+1Hd3pgugxNERCNQdX54T2FKyRBO0fO1eSm/1mkxMkEjR5+0aQxO5LSuACZshiMIVxAA/jgRN45K+UXP2YkWH+aZMNeIpVbM5s4cIspyEgpOPP7447fddpt0N9wRkdSsSGqCC5MG8yowryKZ54zmD+KNA+jxoscLuwdLazGDBbdHtjNG4+7FrmabzO5V+yHXDPkdWQQcXtjcKDVC1c+bpj+Ir63GKBPKTCg34awxqLAka+BEREREdHpaFcYWQJeHAh0K9Rib+ugjZY5WjtaoDfyOYP+HJolHwC4HAiIa2rCmDbZKBieIKOtJKDhx5513ZnoIREQpIwKPb4x0awoYnBjpKi2otLg7OkRRVJhMeYM/ANjTjB/+B11uBAQA+ONyjO2n1MoJO+q6UHeyZmahnsEJopHO6cOJHrgD8Abg8eOMCgw9JkpEkuUJIE/BvSnS8sflmR4BpUmeHEoZAuH0UXCmPjgRikz0msvIBBFlP34mISJKizwF1Ep4A+FuT2qKXlJuUyvR7ox0QzVXTqupJ6bLGipEtL0R9/070n3hq3xlIMoFT32A1/eHq15NKMK3hp9nkojiJQP0CnSf/ISXhp0Tm+0x3XkMThBR9pNQcMLr9Q5+0BCo1eqknIeIKMmM6qjgRHJe8Whk6VOxY6DgRHdMt8yUkvEQURbps0/CE+jnOCLKKi0OBAQ09aCpB0Eh06MhGnH+pwJBEQYF9AqckfpQwQVW/HQsttixuQcuARUsWkdE2U9CwQmj0ej3+xM/jyiKgx9ERJR+Jg06XTCoYVLDyDAqDZ+5T3Ci/xKLo81YWovGbjT1ICDw+UZE0Khiul4GJ4hyQqsj0i7mImqidLtvTFovN0mHSSdrrjuCYEI3IsoBEgpOEBHluKcvR56SSYEpfio5vjIT+jxYtbBqMa6w3yPnVWJeZbjNKUiikeC9I/jXfnx+MuZXnv4A7pwgyj0i0ByV5KXEkLmhEFG6GRSZHgERUTJIKDgxadKkQGDYH5OcTufx48dTMR4ioiTrs2qVKA63nDXsh6gl9F5PRKmybi+2NuDD4yjUqy6pxbJxfQ8YbcYTX4BGBY0SGiUK9ZkYJREllSjijkVosaPVgRYHxhVkekBEuejOdehyo0CPAh3OrMQF4zM9ICKinCKhCYtdu3YN9yHNzc1XXnllb3DCarWuWbMm2eMiIiIiIpKwph5sbQi3253yY7bTHKNVYc7odA6KiFJOLsMlEzM9CKJcd9wGmxuh91azJuXBCRHwB6FKx7aIngDe78aGLrzbhRtG4bbyNFyTiKgvCQUnhkUQhGeeeeaWW24RhHDVr6997Wu/+tWvdDrdwA8kIqKh2lKPgACrFhYtLNq+KUGIiCiDOl3Y2oC9Lfj22Xjt0+jvBC6uzdSgiDJPEJlCk4iSJiCgyx3pFqRsxqndqfj4mGFLXd6eVpw3Ht9aMKRHObx4YQfMWpg1MGswqRgW7eCPAgCIwJQtaPCGu6PVDE4QUWZk5UxTQ0PD5ZdfvnXr1lC3sLBw3bp1CxYM7bWbiIiG6Hcf47O2cHvJWDywNKOjGYINh7GrCUY1DGoU6HA+91wTUS7afQK/fB+HOsLdL07BnNE4ZsOHxyCIKDMFp4+Cxz3gKUYwQcSzW9DpRqcLNjcun4qlKYvlbDwCrQrjC2Ed6lQRJcHVf4U/iCIDivQ4bxzOOyXFGRHR0NlcEKO6BSlLinjvv1X7W8NZgLc1DHxsRJsTf90R6T56ab+lp04hAxaZ8bfWcHdjF4IiFIztElHaZVlwQhCEp5566o477uj9yi233PLEE09oNJoMjoqIKDfZoua2hrwGZ3jcfhy3ocSYnImbnU34555wu8TA4AQR5SajOhKZALClHstnYHY52p34135YdVw2PhCZDH/fFakHPjeVqa5+/QFaHQBg1WL5DHx1Vgqv1ccnJ3CkE4uqU7jIN24i4PFDm5pCXIKINieCAjpc2A/UFqXkKpnl9OHdw2i1o8WBFge+Pg/TRmV6TES5S6nA1TPR4UKHCx3OFJadn12O/ScDBYc60NiNcvPgj+r2xHTNw5sZW2KJBCe6AtjtxKyU/f+IiPqTTcGJY8eOLVu2bPfu3aFuaWnpunXr5s6dm9lREZGEuPzYcwJnVHBeJglExGxhTu6qT5cfP3oTRzvRbAeA/zkXX5ichNP2eCNtozoJJxyWdicautHqQKsDaiWump7uARDRCFGVj0I92p3hbig4AaBQj2vnAIDLlbGxSZ8MsOpwoifc7UjZFpMebzgyAcDmHujOpMWObY3ocqPbg24Pbl8IfV6iV1+3F28exM/fw+QSnDcOV0rgLentg3jpE3S4wsuQ3/wmUnGz1ulCUIh0i3Kx8LsviMc3RLp1ttwLTng8nmeeeaa3e9FFF82cOTOD46Fs9Nxzz3k84Yn7+fPnL168OM4TWbW4+axkjWogi6rxQtQeiHcP45rZgz8qweCEFQDkMsw2YIkF5nTUuSAi6is7ghPBYPDnP//59773vd6vfOc731m1apVanfa5JyKSoFYH/rkHO5uwvxWCiD9chXGFQ33smj348BgmFmNCESYVozAXP8TGx+WDPxjpJnfnhFaFXU1w+cPdo53JOa09KjhhSPsbxDOb8a/94fZoM4MTRJQqMmBuRfgFR6OCPg8iUjLPm6vytZHghC1lgZzD7THdAe5MDrbj0Xcj3a/OSjQ44Rfw4XEAEIG9LTCoJRGcsHuxryXSdfmSEIM5VZszpluci2uALVqoFJGbtBZ7RkeTEoIgfPpppJTO/PnzMzgYylIHDhxwnQzV19TUZHYwQzK5RCzWyzrc/hklqosmYVH1kB7lD8KghuPkh6BhBifGafGv6TjLBHN2TA0SUW7KglegQ4cOLVu2bN++faFuZWXl+vXrZ8yYkdlREZGE+IIxy0y2Nw4jOLG9AVvqsaUeAMpMeHFF8oeXpXR5WHsDutzocsPmxoSkJkaQAVX5kUmKY7bknNasRpEBdi88/gzsnIhentnqGGSu8HAHGrth0ihEj2DMg8mU+vERUQ65YDwKdJhbgSmjoJJnejTZZpQJHS7k61Cgw+SSVF2loTumO7ag3yPNseH/Pstg47CzEU5fpHvO0Ga4Us0am2Cq05WS4ESBDjfNR5sDbU60OlBiTP4lMk4GFBvQePIJ1uIY8GjKKG8AHS64/BjX/ysAUYgM/vvOs5tkcovOarUO9VEXjMcF4xEQYPeiyw3d8F5XZcBF+cMeKRFRckk6OBEIBFatWvWDH/yg9ysrV6584IEHVKrUpCgloixVbo5JcLGzKZzgYigOtEXaE4uTPLCsJgOs2hTW8KyyRoITydo5cd8F4YZfQCA44KEpEL080xeE3QNT/2uX3jyIF3cAsACiMc+/5trUj4+IcsgZo3FGKosl5LYfXDD4MYn7wmQsHovDHTjUjqaegd5PLbFvFl0JZ5rqdMGkDqc6lAELpRGcyI/9CdjcqLAk/yrFhrTW9siUEgNaHSgxoMSIKs4sStKzW7F6VzhMWGTAS7zTo8EJEwpFR1zhRqU8tR/ciIhSSbrBiX379i1btuzQoUOhbk1NzSuvvDJ5cjKSkhNRjpEBM8vw1sFw95MTEMQhlZ2wuSP5oMHgRHrNGQ1/EFX5qMlP/udqlTwDS4mLTgYn5DLk69A9YHCiJ7IwVjCkYOkoERFlnFGNmWWYWTbIYaGdEzLApIFZA0XCKbounIALxmPXCbx/BF0eqUxXlRhxdjWsWlh1yNeijFsGE/DwxdComMxN0mSyyAamTtdQP5sQERGNPFIMTvj9/gcffPChhx7q/cqDDz64cuVKpVKKoyUiSZgzGnVdmFmGWWWYXjrUu39fEJdMxP42HOuEICY5cxENLLQHOZdMKcFTl6PYgHwdlIOFRqKCE2L6M1AREZF0GNVYfyOM6mTOXSrkmF2O2eVJO2Hiig34yUWZHkSu0DKRgOQVROUxCwro8SS5fhtJhlvAcQ+cQTiCcAaxyAxTCiau3rbhtQ7MM2GuETVahiaJKKdIbrp/9+7dl1122fHjx0PdiRMnrlu3rra2NrOjIiKpu2QiLpk47EeVGHDPEgDwBHCwHeOHXKmC6FRGNaaOGurBUSnFBWNSd060O9HtQbkJGs5cEBFlA9mwS5gSkdQV6mO6HS4GJ3LVph6ctzPS3TYHs1NQ7ObVDvyiIdwuV6NuPrfiEFHukFBwwufzrVy58mc/+1nvVx577LG77rpLoVBkcFRENCJolJg25GnlRPxmE450wO6F3YszK3H7wnRclCRo1cXo8qDHY29sF7TK4X1abXei1YEuNzrdMKlxTk3Md/99AL//GACsWoy24Mll/OxCRERElFZVVnx1Fgp0KNCjQIdy5jHLWfrY/dKO1JS922KPtCuSutGOiCjjJBScqK2t7d0wAWD58uVVVVVr1qwZ7nmuuuqqpI6LiCh5PjmBPc3h9hhrRodCGWVQw6AGzL4SpSiKwwtOPLYBH9eF2zPK+gYnmnrCDZsbKgU/uxBRxM4mHGqHJwBvALo8XD0z0wMiogTsbILDixIjSgwwapjnRVpGGXHT/EwPgtLBELuY1ikk/xIBEdujghNzU7Azg4gogyQUnGhqaorurl69evXq1XGcRxTFJI2IiCjZTFHVBaKqDhANQ3RpU5ur73cbuyNtlhslomjvHMK6veF2mYnBCaLs9red+Ojk2r6ZZfjlsoyOhmiE6hOcSMXOiTY/phuw0wGvAADzeINPRLlFQsEJIqLcZ4xKKm33Zm4clM2igxNd7r7f7d05AaDcnI7xEFG20ETd+XsCmRsHESVDiyPSztf1fxwRpVBxHl6ZBr0CBgX0clSkoIRQaR42zYZPwCdObLFjsSX5lyAiyiAJBSdefPFFQUjBFjgiohB/EM9uxWVTUGLI2Biq8zGzDEY1TBqUckcuxcUaNQHh9CMgQBmV7PaxS9HQjaYeNHZjZln6R0dE0hUdnPCOyODEHzajvgujjCg2Ymw+ZvBFkrJZS1Selwze3BKNbBo5Pl+QjgvlyTHHiDn8BElEOUdCwYkrrrgi00Mgopz25kE8vx0v7MD54/CVWRiXlrvIPq6eyTQalKhzazChCBYt8rUwnFIRrzof1fkZGhkRSZtGBQAKOTRK6PMyPZpM2FKPT1vD7QVVDE5QFnP64PRFusWcsCRKgRY7PAEU6KBXs6wLEVGKSCg4QUSUQoKIF3eEG28exMYjWHvDCJ2aoWw3yohRnIMgouG7agaWz4jZazXSNHOlOeUKfR5e/zpaHWh1oMWB6aWZHhBRLvrbTqzZAwB5CowrxNNfysAYBBGfnMC00r4LklIgIGKbHe92oSeAh2tSfTUiojAGJ4hoZNh0HHVdke7FExmZICKikUU1gsMSAHxB2KLq9JQwyktZTp/H7ZJEqdXhCjd8QQTSm4RcBPa14O2D2HAYHS78clmq87U+2YD7jsIeBACtHA9UIW9k3zUQUdowOEFEI4MgoswUrhUsA748I9MDkrYjHVi9G1YtrFpYtFhYxVgOERFlN7cfC8ag2YEWO5y+8BY0v4AuFwoNyczXIYLZPzJjRyNUChQZUKAb0TuEiChZeoMTAArSW3a+3YFvrYl03zl0muDEmj145yDMWpg1KNLjxrmJXLBQFY5MAHAL2GzHInMi5yMiGioGJ4hoZFhUjQVVeO8IXtyJEgPKeas1oLou/Gt/pPu3FVkQnHjkXXzWBqMaRjWmlODqWZkeEBERSYlZg1WXhNtvHcRvN+GJ99DjAYBXvgaTOjlXcfux/HnU5GNcIcYVYG4FCvXJOTMN6rENkWUoV0zH7QszPSAiynIZDE4UGTBtFD5pDnc3HMadi6CIDbset0UOKDEkGJxYbInpvtvF4AQRpQmDE0Q0YshlWDwW546Fx5/poUhedOILABZtqi4UFHDchqM2HOvE0U58dRYml8R5qjobDnckdXBERJSjtCqc6Il0O11JC04c6USPBzubsLMJAFZdnL7ghAh84x8waVBiQIkRZ43BhKI0XXroQltVOt2wuVGow7jCpJ1ZBNqckbZelbQzE9GI9eBStDnQ4UKHKwOvqOeNi8Qeuj3Y34YpsR+UuqI+siX8ea1MjVodPnMBQLUGWm4/I6J0YXCCiEYYGaDl59XBRN/pqpXQpOwnZvfixtWR7qzy+IMTdm+kbUjSHFMc3jmEXSfQ5kCrA6Um/PjCjI2EiIj6kx+7ANbmQpU1OWc+1B7THfrk+xPvodWBLje6Pbh0Eq6ZPexLO704GHV1i0aKwYkVL6DlZFnyZVNw1zlJO3OPB/5gpFvMgudElLAJRZl8IT13LH71AcYX4rxxWDIOJae8rHV7Im2zJvELrqyECCy2oCoJJyMiGioGJ4iI6BS6PFRY0OWG3QuLNoW5sy1aWLSRWMjRzvhPFR2cMGYuOLG5PpIRy8U9OkREkpQfu8K009XPccMXHZwwqlE05Cnyj+vQfHLWvtURz6VbYh9VLMmK31ZtJDiRxB87gLbY//7Qf/JERNJUoMM/rh1o+92MUuhU6Pag24NSU+IXvH5U4ucgIho2BieIiOgUX54RrhnuF+DypfZaVVbsPBmcOJZAcOJztbC5YPfC7sXozGVILY76/NDmOH1Z1D9uhtMPkwZmtbJI5Z9QkMbxERERYNVhaS3ydbBqka/D1OTNx8yrhEyGg+040oGxBcOI7ps1keBEl3vAQ/vRJzhx6hpbKYgOC9ni+m/2pyofL65AqwNtTrQ5UJOfzJMTxaeu62RSICcqrVhYlekBUbYZODFgYkUmiIgkgsEJIiLqn0qelD3CA6nJx84mKOSotGBMAlMJty5I3pgSEL1U0xdEj+c0P8A3PuudgVJfOJbBCSKidMtT4N7zU3Lms6txdjUACCIc3sGOjhKdLjw6U8cwzqDB0lq0OsL/pJnXyBqVUCu5OyeUcpSZUJaEtcNESfODNyLbgi8Yz+AEERHRqRicICKijLpqBi6bgtEWqHKi7FqJEYV6FBtQpEexAaJ4mmN6IrNOYgYzUBERUerIZTANJ7o/rgBuP8waWLSojitUP7kkUrdJECFLXU7GBFw8ATPLUHByzwpRbsvXRYITHUmNxtHI8HEPphtYm5qIchyDE0RElFE5tshxXgVevm6gA/xCdC0KwcDy7EREBHxzfjLPJpdkZALAtFJMK830IIjSpSAqAtfhzNw4KLX2OPFhNxxBOAW4g3i4JjmnbfRi/nYoZZimx1wTbi/H1AGTPBERZalsCk6IJw18mEKhSM94iIji5xfg8MLtz7WpeRqUx4/qfHR70ONBQEjmzok/bgZkKDehzIwxluGt2CUiIiKi5Co4OZcsA4RB5jEoe71pw12HIt0fVUOZjADxZjsABETscGCHA9eXDPYAIqLslAXBiRMnTvzyl7988cUX6+rqhnL8oNELIqJM+sNm/GM33H4AKDFg9bWZHhCll1GNZ78MACLg8fu6bPGcpMuNfx9Alxs2NzrduOlMjCvEmj2wn8xvfuV03L4waWMmIiIiouFaNhlLxqJAB4sWSqbmyVmG2PWxziDMyZhp29ITaStkmCnJQkJERImTenDirbfe+tznPpfpURARJY8M4cgEgJ7hlMqkHCMDtCrRpTh9XYqBOX14+qNI9wuTUGKMRCYAlHNHDhGdzi//i3YnPAF4AzinGldOz/SAiIhyV6kJTGM2AqQoOBHaOREyTQ8dU4QQUY6SdHCis7Pzoosu6u1aLJYJEyZotVqZNMu7ERENhTEq2Y7bj4DAhVQ0bBZtTNfmRlNPzFfKzOkcDhFljU3HIy8XVdaMDoWIiChlfP+fvTuPj6q+98f/mn3fMtkJAcK+oywqiNCioFKluGJdWrzi0tr+er3a3lqrtZtar9Z+3bqgvaDV0lJFkCugLeBaKygGZd+XkIUks+9z5vdHhsxMgCSTzMw5M/N6PvzjfE7OnHkTYc6cz+t8Pp+o6ssWmS8crTZl+60Mp27mdHIYFQgImTnt/47Cv134txufuDlsgogKmaTDiRdffDEajQKYN2/eyy+/XFpaKnZFRET91mWNAXcQNt1ZDiU6C70aKgXC0Xiz3Y9AGDUWNLoREYCCW2aciDJFk/TlPxgRr46ccwVhVEt3mWgiIsoo1fZmocENQO4IyA45svpel5bAeSEMCigyepGp0aCmDFeVZfKcREQSJOlwYtWqVQAqKyvffPNNpVLSpRIR9daIUnxzCswamLUwaaBXiV0Q5SEZUKKDPwyrDiV6lBowsRp//gaEGFo8OO5CFcMJIjoTXdJFJ1BM4cT3VuGIA2UGVJrw1WFYMFbsgoiIKIsUDYlJkZQfH83qe6nlUHMkPBFRX0m6x/+zzz4DcOeddzKZIKLCUWdHnV3sIij//eWmMzwCLJehwoSKrI9eJ6J8VVcCGaBVQaPEyKJ5GjMGNLkRFdDoRqMboyvELoiIiLIpdWigMCT9aQyPO/HOPtj18f+GlEAlmTUfDrVjTwvmjhC7DiKizJB0p7/RaPT5fHV1dWIXQkREJDGcnISI+uC+2WJXIAZvEL5wolnJqbuJJE2lUl111VWdzcGDB4tXC+UnV+CasnPCQnwG1Oqx49I+w96TePHfiearN4o/aWqzB+t34x/7cLANCjnOHwSzpudXpWm7F88dhzMCVxTOCP4yBgMy/yZERCkkHU7MnTv35Zdf3r17t9iFEBERERFRfmr0pDTLObyMSM4oWP0AACAASURBVNJUKtWMGTM6m0YjA0VKUyh6/vjJMmdA7g4hKgRHDE37DK2+lGaJPlOl9d3uFiw9lZdEBazdiesmQJHh+aROBPG7hkTzZJjhBBFlnaTDiVtuueXll1/+3e9+99Of/pQzOxER5ci9b6LBBZsOVh2m1uDr6T9qlHsnvdAqoedip0REdJoyA370VTS50eRBoxs1lvh+bwitPrT50OaDSYOpA/v1LtsaYNGi3AiDuv8lU3qWb4UrgDIjygwYbOP8mUTFboDF8Zu5sVgMMch8IZ01/Uy61ZvYNqihlUB/1Hm10KsSAwF/9xF+9xFMGli0uHoCrsrMLZs59Q/qimbkrERE3ZHAJ+zZXXzxxVOmTNmyZcsDDzzw6KOPil0OEVFxOO5EgwvHnQBg1eX63YUYTrhgN6R3D7BkJdp8kMtgUOO6ibhlctbqIyKifGPR4tKRZ9j/wDp8ejy+PaWmX+FEDLj3TYSjAGBQ47ZpuGp838/WBwfbijoXeWcvDrfHt+eOwI/niFoNEUmGDDGDui/LRYQFKOWICABgl8CwCQBqBS4cgg17Una6g3AHEQyf5TVps6TegTkjZzmOiChzJB1OyGSyTZs2TZky5bHHHvv4449/8pOfjB8/3mw2dz+KQqGQzDpFRET5yOFPbNtyFU40efD8hzjswFEHwlE8eQUm16TxcncQAIQY3EHEYlmqMW3hKFq8iAiotYpdChERncaW1N/U7j/7cb3g8MeTCQDeENT9uB8JR+EMwBvCoF6v4OoP41srAMCgRrkRt03DhUP6XkC2tfvx6XG0+9DuR5sPt5+fgS8bLUkzd5UZ+ns2IqLvTMddF8AdRKsXIckMH5gzHJ+fwFeHYfIA3PtmYr8lY7dsNiXqdDArYFHCokSJpLsMiahASPqT5uabb45EIna7HcCmTZs2bdrUm1fFpNMtRUSUd4KRlFVDcxZOaBTYuD/RPOxII5wIRhJdQgBMEpgY9TfvYfP+eFfXpGr8doHYBRER0WmSH4Zt8539uF5o7rKsRZ+myF/xOf73k/hVWKfCutvSfndvCAfbIPGboUNt+NnbieaVY/v7ZcMbSvnqUsb1CYgoE+QyWLSwaMWuI8m0gVhxE2TAEUfK/swVWanG/vMydTIiol6RdDixYsWKcDhjw9OIiKhnQgw3nYt2Pxx+tPtRZc7R+1p1MGvhCsSbnZMz9EbHsIlORgmEE8FI4iHcLj1WREQkEcl94s4AhFjfFy7q8lHft/5xhSzRye4PIxTt7QiMpkxEIzljS50gpb1/sRAAbwjDS9HijQ/95MgJIipUnRcpqw7//RU4A/H/OtdSIiLKQ5IOJ2bMmMFwgogop3QqLBHpaZlBNmw/Ed8+kk44YVTj4bnxGVfdQQyTwDKYyR1DLV7EgI5biUY3vrcKZi3MWli0+MY5KOEK3kREIrlwCGqtKNGjRA+bru/JBICpNVh6LZrcaPai2YPK9BdfxWnrPDn9vQ05mt0pzQpphxMlqX/Mtv5NqAWg3Iil1wJAKIqTXhGWyyLqhieIldvR6kWrD60+3H5eejOXEp2RWYPLRoldBBFRZkg6nNi4caPYJRARUa5MHgCrFrVWDLJhaGkaL9SqMHto1srqk/KkxzbDUTj98b4Shx9NnsQjrleOQYmUhooTERWVWmvG1gTSqjC8FMPTuXidrsu8HM5Ab8OJ8wfhkcvQ5EGzBye9GZx8PCuMGijkiAowqGHTQSnP2JnVClTnasQnUS8JMfzpk0SzwYXJ4hVDREQkPZIOJ4iIqIgsnip2BZkzshxXj0eZEeVGlBthUMf3d85b1cHMZIKIiE6pteKmc2HVwaKFVZfGzIqlBpTmz1xGchlW3AizFhreilIRMGmhkiMsxJut/Z7HjArdjxr0Tccx1YRpZkwxwcpPSiIqdPycIyIiyrThpRh+4Rn2O1OXx7BogcAZDkuLEINMBs4ORUSU7ypMos2smGNcs5qKhwwoMaDp1NxrrV5Rq6Fs+UMD3nXCE4UnisFaLB3Z91Otd6kOBbHqJAB8vRSvj8tUjUREEsVwgogo57whHHfCHYQrCFcA80ZCy0/j4jDAjAVj4Q7CGYArAJMGnn6HE/Un8IO1KDei1ooBFlw/MZ+enyUiIiIqbFUmALDrYddjeJnY1RSxcBShaGJAc0Z96MKfm+LbY/vxTbwtIjsUTEx2N40z1RFREWB3GBFRzn16HA+sSzSnDuQUycViTAXGVKTs8ZzlyN74yzZsPoAdTQBw1IGjDgC4bkI/zkhExUSIAejXKtBERNSj3y4Qu4Kiptl8WH3Ahb2t2N+KG8/FrVmZSNaoSGx7o30/z7aAKrk5zdT3UxER5QsJhRNtbW0ZOU9JSUlGzkNElC0mTUrTFWA4QX3R5IknE51UCtg5bIKIzu6IA/euQSCCQATBCJ64AlNqxK6JiChFNBrdv39/Z3Pw4MFaLZfpovQcPHgwGo0CMC97v+ykUKoyAsDO5iy9nSEpnPD0I5wwy4WrrKHPg+r9fgCYzHCCiIqAhMKJysrKcDjc//PEYrH+n4SIKIu6hhPBsxxH1C2bruueajMfgiai7ihkaEoasRXIwHdvIqLMCgaDzz33XGdz8eLFFRUV3RxPdLoXXnjB5/MBUDW0XBEYtMA+AQB2NSOGbCzVNkiDSUYYFDAqUNKPbrYp+sh5Jq/Npm4N4wsvV8MmoqLAjzoiopwzp4YT7n6vOkDFqUs4UW3GiFKRSiGiPKFJ/fIfjIhURw6t3QmTBhUmVJpg1majT4qIiCTk4yN4YrP6y8MReSSmVsT0KnTebLkCOOHKxpj1bw/Atwdk8oR2FWZZM3lCIiLJklA4UVFREYkUwQ0SEZFNjyevgFkLswYmLXSqnl9CdLpBNlw4BFYdSnSw6XDpKOj5d4mIuqVN/fIfKPTv3kIMT7yLqBBv3jYNN08WtSAiIsqyVh+aPHJnUC6EAITOrYJHgYnVGF2OUeWwcIowIiJpkVA4cfToUbFLICLKCaUckznHN/XbhCpMqBK7CCLKK1oVrhoPrRJaJTRKjCoXu6Asa/MlkgkAZUbxSiEiopxw+BPbMggl2uDNM3F9r5clF2JYshIlOtgNsOtxUR1GlmWjzLwQjUEGzhpLRNkloXCCiIiIiIiySCnH/3eh2EXkUKM7pVnBcIKIqNA5E1PmxpRyyGSQpdO57gxg38lEs8ZSbOHE+07cvhuuKJwReKLYOQ2j9GLXREQFTS52AUREJBneEPa3dn3OlIiIKE+d9KY0K0wi1UFZExO7ACKSmnGV+Pq4aLVJsOli1vQncWpNvXDYi65jXohhpw/Hg/BEAcBV6BNAEpHoOHKCiIhO+ew4frwuvm3W4PfXZGO9uAyLCHhnL0ya+H8VJq67QEREcbOHYv1taPKgyY1GzxmmdfKF8c99aPOh3Yc2P66biLEVab/LMx/AoEa5EeVG1NmLsCdLTA+sw+4WlBlQbsTEKlw1XuyCiEhsM4dg5pDwnldCPl9fXt6a+qoSQ0aKyiOW1G5CZ1SkOoioaDCcICKiU5JnaHUFYdSIUIMQQ5Mbhx043I4jDvzXRT3McuoK4JF/Jpo/noO5I7JdIxER5Q2tCoNsGGQ7809DETy+KdE8rzbtcCIsYGV94vn9O8/HDef0ocw+CkXx8qeoMKLChHIjKk1QK3L37lLQ6EKLBy0e7GiCDAwniKi/zFrMGYZWH1p9aPUWYd5s7hJOcOQEEWUZwwkiIjqlPSmcUMhhVItQwzt78ct/JJrfmIQBlu6OdwdTmqIEKmfT4sEJN5o9aPGgRI95I8UuiIiIUpm1kMsgnMoW2tJ/zPakJ2VmofL+LWsREXCoHU4/HAE4A5hSg1prd8e3eLBsS6L58FzMHtqvAnJm1Rf4rAFtPrT7MciGX17ax/M0exLb/fzlExEBGF2OBy8Ruwgx2ZX4ViUsSliUMCswvuiGjhBRrjGcICKiUxyJ5eNg1fYwZCFLujzcerg9vXDCJKVw4rFN+ORofHtiNcMJIiLJkctg0yUm8ehDOJHcOY5+94/7QviPvyaaP5jdQzjRlNF3z6Uvm7Bpf3xb0dfvG4EIXElfA06ftouIiNJkVuJPo8QugoiKCcMJIqLCddSBzQfwwSE8eQV0vViJ4erxmDYQ7X44/OIkE0DXXpjD7Zg+uLvjpRxOJHcStXjgCsAfhlkLrQoi/XaJiKgrmx6OAGw62PUoTf8B0bCAKjNaPIgIQL/jAaMmZSRH8kMDZ9TkTmnm0YrfJUkzpfQhE+oQi2HJeWj2oMWLFk8PTzMQSUE4ijYfyk38KkhERNSB4QQRUSE62IafvYMDrfHmx0d6Nc9DtVn8FbB1KpQb4w+ilhrQ463btIFY9S24g/AE4Q6iUkr9MmVJnVwtHqzegT9+DAAqOWx6/PVm3pcSEYnv6a9Dq+x7JD+lBn+5EUIMDj9avH2JN5LJZTBrE0tAOf3dHg34wlApEI4CgFIOm65f755LyaW6gogIUMrTPolOhZvOzWBRRNny4SH84WO0+uAKAMD//QcMYsyeSkREJD0MJ4iIClGFCUcdieam/XkzCTWAH8yGQY1Btl7dtinksOkk2h3T+fysDDBp0eCKN8MCghEmE0REkqDvxcjCHsllKNGnjAboM0tSOOEJ9XDw1eNx1Xg4/Gj2iDnqsQ8GWDCyDDYdbHqU6PoYThDli2gMB9sSzVYfwwnqYq8fxqiMPXREVIT40UdEVIj0KpxXi/cPxpsfHUEgAm2efOZPHSh2BRly/iA883WUGWE3QCXHoxsTP7JoxSuLiIgk7L+/AoUcVh0s2l5duGWQbkjfjZlDMHOI2EUQ5Yo9Nbls9fawnEwOxABPEO1+tPvQ7sf4qq5FUj8IsbTD4mlb4Yho1DJ1pSp23yDcPSA7lRERSU+edFQREVG6ZtXFw4kKE2bXIZQ/4UTBsOtTbvNcSVOHmxlOEBHRmYypELsCIsq0ruFEX9dZyaCjDtz8aqL5q8swY7BoxRSES+vxpReeKLxRLK7C70ek8Vq/AEcEAEIx2ZGQLBLr6QVERAWEHVVERGLwh7FmBzxBuIJwBfH1sZhQleG3mDEY3zgHs4diRBlnEJKEWyZjznC4A3AGYc+3R1yJiIiIqG9K9Lh4OOx62A2w6zE+01/7+8Ca+l20vacVbgqDN4Q9LdjVjJ3N+OFXMju5VlMIx4Kn3iea3mtPBFOa1Zz0i4iKSX6HE+Fw2Ol0ms1mtZof3kSUV4QYnv0w0TynOvPhhEGNO87P8DmpP0aVY1S52EUQUdELhOEMIBBBIIJQRBJ9ZEREhU2lwE8uFruIVEY1FHJEhXizXQKDObJtWwO+/wY6ByV8fRzOzeTcSUZFYtuTbjiRusBQlSYD9RAR5Yv8WHbsyJEj27dvT94TCASWLFmi1WrLyso0Gs2111574sQJscojIkqbXp0yEakrePZDiYiIMuf1L3Ddy7jlL7h9Jb67Cpw7goioCMllKWvVFMPIicG2lEverubMnt7Qj3BitB5rxuOZIeH7yn23lASHcv5XIiomUh854fP5Fi5cuGHDhuuuu27FihUdOwVBmDdv3rvvvtt52MqVK9944429e/cOGjRIpEqJiNIhA0waOE8tQuAOdHs0ERFRhmhVie0YEI5CrTj70UREVKC+dyEUMtj0sOlQUigzjp5wQS6D5Ux/HKsOlSY0uuPNnRkOJxaUYpQeBgWMCqSbLpSo8DU7Aoaox+NTKBQ2DYdOEFERkXo4sWjRog0bNgDYsmVL585169Z1JhMzZ85saWnZtWtXOByeMWPGoUOHlEqp/6GIiADArEUoCrMGJm3XWV/7IwYs3wKTBmYtzBrU2VFqyNjJiYgo32lTvyoHwoUZToSiuGc1yk2oNKLChKkDUW0WuyYiIimZVSd2BVnw+GZsPQZAe2hv2K4Kj0+dUnVUeTycqDChVH+m1/fdXdWZPR8RUbGQdD9+fX39mjVrANTU1Pz+97/v3P/44493bLz55pvz588H8Kc//enWW289fvz4unXrvva1r4lSLRFRepZdD0UW5tYLhvHiJ4nm92di4bjMvwsREeUpTZdwIoKC7LRvcmN7I9AYbz48l+EEEVHhc5yanyp6plkLr5mAS0diVHnKlFbJ2v3QKqFTnfmnRESUBZIOJ/72t78BUKvVX3zxhcVi6djp8Xg2bdoEoLKy8vLLL+/YuXjx4ueee27Lli2rV69mOEFE+SEbyQQAZ+ryFWZOWUpEREnGVeLhudCqoFVCqzxrB02+a/KkNMuNItVBREQ55ExMlhtTnXa3Nb6yh5c/tAGfN0Cngl2PmUNw5wWZri8/RGJwROCMwBmBK4qpppQVNYiIMkvS4UTH3E033nhjZzIB4P333+/YuOuuu2SyxHKyN9xww5YtW955550cF0lEJC1dlq8wc8ZSIiJKUm4sip76JndKs9IkUh1ERJQrsaSREwDU6fd3tXoBwB/GMSccxbso4EYH5n6eaG6bgolF8MWBiMQi6XCivr4ewIUXXpi8s2M4BYDOYRMdBg4cCODIkSO5qo6ISJL8YWiUCEbizd6PnHhrFwIR2HSw6lBlRgW/gRIRUd6y6XBeLZrcaPQgKqSxtpMQg1zW82Ekun0nEYqizAC7gf/LiAgAYjH8ej6cATgCkWc2Cqb0PxlafYlte4YXpcgjltRxEs7IWY4jIsoESYcToVAIgEKR+FwUBOEvf/lLx/b48eOTD/Z4PAD0+uK9fhARAcD4KmxYgmAE7iCcAdRYen5Jh1c+wxFHfPvSkfjRV7NUYF/4w2ee+/WIA698BpMm/t9XhmZyaXEiIspf0wdj+mAAiAHeYA+d15v2Y+1OtPnR5kM4ijdv7dVbxIBrlsOkQZkR5UbMGYZzB/S/cOqt/92C9w4CgFyG82rx6OU9vYCICp1chsk1HZuRt+2Cz9f94V35w/CHE80iDifMqT2FzqhIdRBRcZB0ODFixIht27bt2bOnc8+BAwd8Ph+AefPmaTQpc5V0LEQxevTo3NYoaZFIBEA0GnU4HD0enF8EQUjeLrw/oFjcbnfPB1G3otHEd7dwOCzmX04lYFfA74G/52MBWNr9nT03Qb3cL/Y/K9VnJ1QfHpMfdSqOuWIGlev3V5zhmL0nDG/t6my6h5qi6HUYIw2xWAyA1+v1pXv7RMUk+aoHwOVyiVUJ5YWOvzAiX4OkxtHdtVBzrFX376OdTWdTa0zT8+zaMm/IctKLk14cbAPgH6AP1hn6X2kvyVt8hp9ujJUbhFKDUKoPzRokVKY95LHjGtQhEAiEw+FuDs4WISZzBeXOgFCii5nSmIvSdMKpOHWGcCzqlcDf9o5/egV585Vjfn/KP9hAIMBf6en49617yZ9vvbwgysKC8ocXytv9sja/vD0QqtJGcvu7lc7/U1lEDpg7m40un0MR6nJM8m8YgM/n6/IvN9913p11+R5ORBkn6XDikksu2bZt27Jly372s591jJ9YtmxZx4+WLFmSfGRzc/Py5csBzJ07N/d1SlbH1SIWi3WkFIWq4P+AucTfZGZJ9y9nDOjyCGlUkLkTK2lHjCrRK1fvPqnesK9jW+YNRf2h0xe1U7hSvgGHtXJB7LJPp914SHGgXdHql7f6w8NLvLedc/oxyZkWUY9E/+dJeUG61yDpUZjVyU2h1RMt7zlmUKYuaxG2aTL1C1d/0qDc3yZ3hWSuoGDXeRdPOv0YVaNLccyFY/GoMjjWHint9USOZ5L7vzByV9D6nxvkriCEGAD3d6cGZw/u/ctlJxOhfsSmldTfdkkVk4+6/AL5ada9dH85mo2H5I5AdIg1UmsRbLquNwWFSBCEXv2WZAhPq0rZI9JfPNH/wpsEPF3jMckFkzxmVsQGq6ORSKz7lxTe7Yzo/xeIioekw4mbbrrp8ccfP378+MKFC3/5y19+8sknv/jFLzp+1BlCxGKxzz///Ior4k/ULlq0SJxaJakj0VEoFEZjoc0dHwwGO5/tksvlnM6r/zonRpPLu/b/Ulr8fn/nNzOlUqnV9qunILNkjoD8g8OK9w7Fai3hb5+f8iNnAGoFQvHK1eUWhdifG4qhZYmGEDO2R2J1JV2PCafcTukrbNBI7rqm/qhBvvV4x7Zcp5al/mI7/ulptVqlUnKVk3REIpFAILEqo8FgkMmKoC+B+ioUCoVCIaldg6RMXmlNbhqCcqEXF0G5J+XJVm1tqTpDl07VJ42Kf+zv2I4NtsnOdFqFuzn13cs0xrTHbXi93s5HX1UqVZeB6Vmn1cuT1pvV+aHq/S8wLMidideqBlilcL8TDoeDwSDvTfqvy/2ISqWSwv9fqenz3zf1xiPyL5s6toVpNaGfX5KF6qRFqVTmxV8hSX2G3Gbu4YBYLOb1ejubhXc70/llm9+6ibJN0p8dEyZMuPLKK1evXr1mzZo1a9Z07n/44YdNJlPH9sSJE7dv396xvXDhwrFjx4pQqFR1fKuTyWSFd2saiUQ6w4mC/APmWCwW6+gh1Wg0yau8UB8Eg8HOcEIul0voL+czH+Dv2zseTsShdsX3Z6VMwK3VYsPtCITR7ofDr6oyq0SvfFh5ckvT6MOY6q7HmHSotcIdhDsIGbRmoxQf/qo0A6fCie2N2gNOlBtRGu9C6ugYUqvVarX67KegYhcMBpPDCY1GwyCZuiEIQigUktY1SOIGlmBSNWw6lOhRoldXW9GbX93AEtxwDpo9aPag2a2uKenVq3qjJBEzyJyBM/9/bEt8JkAu0wywQZH2x4LP5+sMJ8RJsyxanMoYlO6QsvcFqGN46Qa0eNHiQYtXObkmjddmUzAY5L1J/3V5BLtwolZfGCe9aPOh1QuVAhfV9fN8ffn7FgMOtXe25NXWAvndnia5Q1mhUOTLHzOPPkMEQUgOJ0RIuLOs84OI4QRRtkk6nACwcuXKW265pXMRbABLliz5yU9+0tkcPXp0Rzhx7bXX/vnPfxahRCKivFBpiicTANr9qD+BSal9/TJAp4JOheqenpPJjRoryoyosWCQDYNsGFV+hmMuG4XLRgFADAhGpJhMAChLfZT1rtfw1WF4qPAfUiMiyhtVZvx2QdqvGlKCO8/v+bA+sOoS287AGSZjBDDIhkuGo8mDJg/ksj4kE5JQou8MJ9CezmTlchkGWjHQ2vORRNLx643YGB8UhWH2/ocTfdHkhjdp8YBhdhFqICIiSiL1cEKlUr366quPP/74Z599JpPJpkyZUllZmXzAzJkzDQbDd77zncmTJ4tVJBFRHrioDk9/kGhu3t81nJAalRwrb+7twTJAK9UrWqUJNl1Kn4s5Dx6GIiIi0Vi00Cph0cKqg0WLUOQMkxbOHIKZQ+LbQg9TgUvXgrHwhlCih02HGovY1ZBUyGSykpLEZJ6F8zi2PemBlVbf2Y/LpjYfKkzoXDJnaMGGE1ZrYlCIFGZJ6sZrLTgZRpUGpZDbIvIKTmRAREVGql05qWpqampqas74o7vvvjvHxRAR5aVyI8ZUYEcTjBrMHIKZYjyrVZw6hnfMW4pAfDI6WArlHpuIiLJh/mhcMSaN4+XSHDnYCwvHiV0BSZFOp/vxj3/c2cyL1QJ6pTSpi9zhR1QQYczTmAr89SZ4gjjQhn2tCEXx5k44/Gj3Q6/Cf0zLdT1Zc++993ZOW5ebcCIGtITgicIrwBPFYC2qejdp67MN+Gd8qi31RUbTqqGeLFZJRCQ9+RFOEBFRBtw6FTHgnAFQ5efkD/krHE0kE+DICSIi6lb+hg1E1I3kkRMxoN3fuQhZrhk1mFCFCVV4YjNW74jvrDQVUjjRKzGg0QVXECPL+n+ygICKDxPNZ4fj2wN69cITwcR2pVLofyVERPklb8KJYDD43nvvrV69+tNPP929e3cwGHS5XABefvllk8k0f/58pTJv/ixERHG/fR8HWuEMwOHH7KH4/szsvt3Ugdk9P52NSoF3boczAHcQzgCqpLGqBxERERHlzKRq/HweSg2w61Gih0oC0/fYkla4caSz7ku+W78b/9iHXc1wBjCiDH+8pv+n1MohAzpn2fNEuzs4WUPSIiCVKoYTRFR08qBDPxaLvfjii3fffXcgEDj9p6+//vprr71WW1v79ttvjxgxIvflERH13c4m7GyOb4s18yzlhkqBUoNoz8cRESXb1oBmDwIRBMIoN2L2ULELIiIqAuVGlEtsiipb0nxHHRcFrUq8anLoYDs+PhLf3t+KUBTq/mZFMsCogPtUJuHtXcoQEBBIOrKCIyeIqPhIPZyIRqNXXXXV6tWrz3ZAfX09gCNHjowZM6a+vn7MmHSmZyUiEpe1WB9WIiIiES3fiq3H4tvTahlOEBEVqY6RE3IZbDrY9PAVTTgxKmkep6iAfScxpqL/ZzUkhRO9HDmhlcN/EdrDaAjhsCdULYR6fg0RUWGRejjxwAMPdCQTtbW1v/rVr2bNmrV+/frbbrut84DXX3/99ttv/+ijj6LR6Jw5c44ePcr5nYgobzCcICKi3NMkfVsORsSrIzsiApwB2HRcuYGIqAfnD8KaW2FUF8IHpjeEtTth1cGqhUUnMwgx7dkHQ4xOjSJ2NmcknHhuBGIxGBQwKlDb6zXmZECJCiUqDFMIHk8UkMB8X0REOSTpfvyjR48++uijAObMmfPWW2+pVCoAdrs9+Zhx48Z98MEH995775NPPtnY2Lhu3bqvfe1r4pRLRJSuEaVoHQirDlYdKjIxyntHE/7wMSxamDSwaHHthJT8g4iICIA26RYgEBavjuw41Ib/+BtUcpQZUWnC3TMw1N7zq4iIipBWmXJFyGvNHjybWJBa9eOZwXMrz3pwuRETq1FtxqgyjCrP1GViYWlGTkNEVFwkfR168cUXAahUqlWrVnUkE2ckk8l+/etfv/LKK42Nja+88grDCSLKG1eNx1XjM3nCE258djzRvHJsJk9ORESFIbkrKlpw01s3ugEgLKDBhQZXITwOTEREPXKmrFEq5VQdiAAAIABJREFUmNTdHSwD/t+ClD17WrC/FXYD7HrY9bDowKsHEVFOSDqceOuttwDccccdRmMPDxQrFIolS5b8/Oc//+CDD3JSGhGRJLlTvpTDrBGpDiIikrC7LsDt50OrhEZZgH33TZ6UZoVJpDqIiCiHUufIjVl6Pa1Sh/cOYvnW+LZGifVLMlRWvmoJ410HnBE4o3BFcGc1KrqNe4iI+kzS4cT27dsBTJkypTcHjxs3DsCxY8d6PJKIqGA5g4ltlbxYVrQjIqK0mNPssskvHSMnOpg00PNSSERUBDzB5FYPIydO1+pLbNv1HDaxy4drvkw0Ly1hOEFE2SLpcEKn0/l8PpfL1ZuDT548CcBsNme5KCIiCasyYdpAuIJwBaCU9/Zb9fYTePET2HSw6mDT4evjYOKQCyIiyk+XjsSQEjS60eSGUp7eawNhtPnR5oNJg0G27o78vAE2PcoNfA5ABBv2YN9JlBlRZkCVGSPLxC6IiCTga2MwbyScATgDcPhjOhUQS+Plrd7Etl2f8eryjjl1WW5nRKQ6iKgISDqcmDFjxurVq1euXPnd7363x4NXrlwJYPr06dmvi4hIquaOwNwRab/quAufJq1UMX90BivKDFcAh9tx2AGLFjOHxHe+tQvLt8KkgVEDswYPXJx2JxQRERWeofY+Lm36rRU42BbfvmIM7p111iOFGL6/GkIMAEwa3H4+rhzTl3fsm0AEjW6UG4t3UMiHh7Bxf3x7mB0vXCdqNUQkGSoFSg0oNQBAa2ta2QTak2aFshsyW1c+sqR2FrqiItVBREVA0uHElVdeuXr16nfffXfLli3dT+5UX1+/ceNGAPPnz89VdUREhaLL9NzpztCabf/9f/jocHx7ck0inDjpRcOpoXVKORRMJoiIqB90SX39bb6zHwe0euPJBAB3EGpFdwf3X8d7da4Osu8kvvM6ABg1qDDix3P6GMZIRLsfx5xo96HdD18YN0zq+SXNSd9bynpYm5CI4lxBmDScreisfnc12v1o9aLVV+CTH/ZOcjihVyAoiFcKERU6SYcT119//R133BGNRmfPnr1p06az5RN79uyZPXt2x/aiRYtyVx8RUV4LRPCvw9h8AP/cl9hp1kqulz95YPXh9sS2O2liWd5rERFRPyVfbtr9Zz8OaPamNMuz0D++rxVPv98xOQmcAfzxWgw7lUB0ds17gvAEUzKVfLR2J/74caK5YGzPI0Jakn7/ZXzAuQAFAoGnnnqqs7lgwYKpU6eKWE+B+PZraPfHx5ZdOBiTa8QuKLuee+65YDB+szBz5sx58+b18AK5DHY9J3TqZFHgwPmwKGBSQsX7LCLKJkmHE0aj8c9//vOiRYu8Xu/UqVPnzZu3ePHiTz/9tOOnR48e3b9//5/+9Kfly5d37Pntb39bUlIiXr1ERPmj2YObX0UgafbQYaVw+CU3bAJAbdKs3ye98IZgUAOnhRNERET9YdMltlu7HTnRnDriMBvhRFTAtoZE05kUlnQZ75jvvfPJv3YA338Dv7s6MUzkdDHAqkMgDFcQyM4vn8QmCMLRo0c7m16vt5uDqVcCYRxzIAZ83oDPG2DVFnw40dDQ4PPFP8mdTqe4xeQjuQxDpHdfSEQFSdLhBIDrr79+9+7dDz30EID169evX7++80e1tbXJRy5evLg3S1MQEREAlBlRZsRRR7w52IYXrgXSWzcuR5KXJNWp0ORGnR0AzhkAhRzuINxB9k0QEVF/fWUYhthRokNJTw/PnleLP1yDZg+a3Gj2ZCUesKZ22TsCie1md2K7RA9VlieVyrYuy1lfM6G7ZAKADPjjNQAQiOCkt3gX3qD8tW43Wjxo9aHVh5lD+rJcXB8caEv5kp/Xc8EREVFhkXo4AeDBBx+87LLLbrzxxr17957xAJvN9tJLL11++eUyGQebERH1jgyYVYeX42PRcKgdh9ox2CbFyZFGluG7MzDIhkE2lBkTFfZt9W8iIqIzOncAzh3QqyP1Kows69qrnlldBjI6k8KJaybg3Jp4NKKU2EyMfTCsFDedG/9C8p3paVzZtUrUWLJXF1G2/P5fiVVtSg25CidaU5rDSnPxpkRERL2QB+EEgKlTp+7evfvQoUMbN2784osvDhw4EIlEqqqqJk6ceOGFF06YMEEuz//v5UREOTZ7KF7+FCo5ptZidp10Bx/YdLhmgthFEBER5ZBWiemDYVTDooVVh7EViR8NsGBAYXXKLzkPRg1cAVw3UexSiLLPrk+EE23dziCXQefW4J6LsL8V+1vR5EGFKUfvS916uQnLG1GlQbUa1RrcxgEtRFSU8iOcACCTyYYMGTJkyBCxCyEiKhTDSvHwXEwdGF/CgYiIiKTjkcvEriCHbpgkdgVEuWLXo3NKiNZcLadRbcaCsfHtGFKGSntD+O37aPej3Yd2P747A7OH5qiqgtMaxkYHPNH4f9+sRFW3t1n1HrzdHt+2KbGE4QQRFaW8CSeIiApWDPAE4fDDGcDYytxNrCQD7z2IiIiIiHLHboBcFl/bZnCJCAV0uddQKbB+d6J5ssiWHxdiONyOXc3Y2YydzbjxnP7cH+3x49ovE82Zlh7CiYZQYrta0+e3JSLKbwwniIhEtWEPHt2IqBBvvnkrTPxmSkRERERUiL53Ie6d1cPC77mkVsCghvdUN3m7X9Rqci4aw5K/IXzqXuzLpv6EE0ZFStMT7eH4E0nhRPcxBhFRAcuPcEIQhKamptbWVkEQejx4wgROTU5E+UOnSiQTABx+hhNERJRdYQHPf4hgBIEIAhFcMQbn14pdExFRcdBKrxPGqkuEE44iCydUcgwrxc7meLNzo08MqWuhensKJ6aYEIuhIYQTIY6cIKLiJb3rYqpgMPjII4889thjgUCgly+JxWJZLYmIKJOs2pSmI4CBIlVCRERFQg78fXuiOama4QQRUfEaU44yA2w62HQYXyV2NTk3ujyRSextQVSAQt7tC84qeeSEQoZAT8/WPlaX2I7EEAn27W2JiPKbpMOJaDQ6Y8aMrVu3il0IEVHWWHQpzf48rBQWoJTnbskKIiLKUwo5VPLELBaBsKjVZE6DCx8dRoURlSZUmGDU8JpYaNxBKOXQqcSug6iwPHCx2BX025s78K8jsOhg1aLcmFj9uzdGlQOAToWRZRhdjmAU+j6GE3YVDp0PowIGBTRp3pYpZYj07V2JiPKcpMOJFStWdCYTixYtmjp1qt1ul8v7eJ0gIpKiMgNumwarDlYdrNp+LYv3/IdY9SXMGpg0GGTDLy7NXJVERFRYNCqETz2iGSiU/pAdTfh/7yeaf7kRVWbxqqFMC0Tw3/+HiIDHLodV1/PxRFQ8drbgvYPx7WpzeuHE9MFYtgi11v4vBKKQYZC258OIiCiZpMOJpUuXdmx88cUXY8emc3UhIsoXOhVunpyZU7kCiApo96PdD6Wi5+OJiKho1VjgC0GjhFaFcqPY1WRIozuxLZehrFD+XAQgIuDhDfiiEQDuXoX/+RoqTWLXRESS4UwafZ5ueGnScM0/IiIRSTqc2LJlC4A777yTyQQRUc9cSdOUmvkNm4iIzu73V4tdQRY0JYUTdgOUHG9dKGLA/2zGh4fjzaMOPLgeT38dGknfzBJR7jiS1ii1cPBCZuz347fH4IzCFYEzgudHYKRe7JqIqBBJ+vucWq0GMH36dLELISLKB+7kcIJfyomIqMg4kzqnKjhsooDIgLoSAFDKMWMwLhuFaQP7vGItERWguhJEBTj8cAY47VumtIbx9PFEszHEcIKIskLS4cT8+fOXL19+9OhRsQshIsoH105AgwuuAFxBjCwTu5osa/cjKsCogUbJ9U6JiAgAfjYP3hCa3GjyQNWn6Q29IXzZhHYf2nxo8+O6CWeYG+rpD2DWotyAciPq7LCxFywnrpsIqw7/sxm7WtDmw4Y9GGrHTeeKXRYRScM9FyW2hZh4dRQUS2p/oSsqUh1EVOgkHU7ccccdy5cvf+655374wx8qFJw/nYioW18dJnYF2RQD1u3CoXYcbsfhdjS44vtVcowsx7MLRS2OiIikwaBGnR119j6+/IgD972ZaE4f1DWcCESwsj7RvHsGrp3Qx/fqgwYXNuxBhRHlRlSYUGkqrqmr5o6AVYufbIjP3zXYJnZBRCRJ/V7XmjqYU/sLnRGR6iCiQifpcGL69OnXXHPNypUr77333ieffFIm4zWGiKhYyYAXPkGLp+v+sICoIEZBRERUcEpSh0G0+bse0Jx6Gcr2WuJCDN5QfKISowaH2/GnTxI/fekG1FqzW4DUTKvFK9/A5v2otuC8WrGrIZK8GPDMB6i1YqgddXboVWIXRPnEosBADcxKWJSwKFDOvz5ElB2SDicAvPrqq36//6mnntqwYcP9998/adIkq9Uql3f3iFBVVVXOyiMiotyptZ4hnABg4urfRESUCbbU6bTbfF0PaMltOHHrX3GwLb592aj4uguJdzdk992lya7HVePFLoIoTzS7UwZ7/XgO5o4QrxrKM3oFjlwgdhFEVASkHk4oFIrLL7987dq1O3bsuOmmm3rzkliMMwwSERWiQTZsPXaG/QwniIgoI9QKGNTwhiADLDqcflsRiqLChJPe+KC9bIcTxqQLnMOPFm+iadZCy6dYifJcDDjhgjOA0eVZOf/+1pRmjSUr70JERNQPkg4nYrHY1Vdf/frrr4tdCBERScBgGzRK1FoxyIZ2Py4ZDn8E7iBnnSYioox5/ioYNbBqoTjTWO0LBuGCQRBiaPOh2ZP11bCt2sS2M4DyCBTyeC5SkeVchIiy6q1d2LAHe07CE8RgG5Ytysq7JIcTMmBIydkPJSIiEoekw4k1a9Z0JhOVlZVz586tqKjofk4nIiIqWJePxhVjuMYdERFl0aBeBN5yGUoNKM3+rEqWpPDD4cc9F+H7M+O5CNdbIsprJ9z49Hh8+4gDgXBWxkJFBBg18AQBoNoCHYdbSUVIQECASQne2BARSTqceOGFFzo21q1bN2/ePHGLISIikakYThMRUTG5ZDhGlcGqg0UbH6WRs1yEiLJqRGliW4hhXyvGVWb+XRZPxbemotmD/a0IRXo+PhBBuw++MIbaM18MJfnIhdnboFegWo0qNZaOxAh9z68iIipIkg4n3nvvPQC33XYbkwkiIiIiIiouk6oxqVrsIogoC0aWpTT3nMxKOAFABlQYe54IbvlW/PkzBMIAYNNh1beyUkwReM+JvzbDG4UnCk8Ub44/86jvEyEA8EWxz499fqj5CBYRFTFJhxPRaBTAzJkzxS6EiCjLdjSh3Q+HH44AxlawJ4KIiIiIqGCVGjG5BlVmjCzDiFLUiT1SQSmPJxMAnAEIMc6k2jdfevHM8UTTJ8CoOMNhDcGUZpU6u1UREUmZpMOJOXPmvP7668eOHRO7ECKiLPvhWrhOfUW9YRLDCSIiIiKigiUDnrxC7CKS2JJWuBFicAVg1Z39aDqrLlGEN3rmcKJj5ESHEhU0HDlBREVM0uHEN77xjddff/0Pf/jDj370I5mMuT0RFS6rLhFOOAKilkJEREXgs+N45kMEwghEEIzghet6nvSDiIgKVZcoot3PcKJvDKlRhCeKijMddn05hmhxIoSGEFTs6yKi4ibpcGLhwoWjRo3atWvXww8//NBDDzGfIKKCZdEBjvi2wy9qKUREVASCUew7mWh2zuZBRERFaEgJbpkMmw42PWw6VJrELigdUpqEyqZErRZGBYwKGORQnKWuKSZMyavfMRFR9kg6nFAoFB999NH48eMffvjhzZs3P/DAAyNHjrTb7SqVqpugQqE406g5IiIps2rjG3IZokJfzlB/AnIZzFqYNTBpoODYYCIiOjtt6l1AICJSHRmycT9e245KEypMqDTislG8DhIRpaHShP+YJnYRfTX/BSgVsGph0WHhWMwZLmIts604fL6I709ElH8kHU7ceuutkUiktrb22LFjmzZt2rRpU29eFYvFslwXEVGm3XkBlpwHqw4mTR8f/Hnkn2hwxbevGIN7Z2WwOiIiKjRdw4k8HzmxvxX1J1B/AgDUCswfI3ZBRESUE8EIfGEgDFcAcOArQ8UuiIiI0iPpcOLll18Oh/P8TomIqDdqLP09Q+eSFQAs2rMfR0REBNj0uGQ4NCpoldAqUZbnC040uRPbFSZIZXoPIiLKMmfqcn1W3gdlS8dTwLzAElHGSTqcmDFjBsMJIqKeRQV4ksIJk0a8UoiIKB9UGPHAxWIXkTlNnsQ2V/YmynNqtfqb3/xmZ3PEiBEiFkNS1yWcsMTX8b7hhhsikfiMhYMGDcpxUQWj3oObd8EVgTMCVxQfnIPzzGLXREQFR9LhxMaNG8UugYgoH3hCKU2OnCAioqIyvhJqBZrcaHTn2TquRHQapVI5YcKEzqbRyMSRzs6mw53nwxmAIwCnvzOfHjt2bOeM33q9Xrz68l59UvrvzPMFqohImiQdThARUa8Y1Vi+CK4AXEG4AphQJXZBWfb+QbiDcATQ5sPFwzGyTOyCiIhIVEvOi2/EgHC0v2fbtB+fHEWbH20+mLV4fH78zFcvg0WHCiPKjZgzDBOr+/tGRETUT6UG3HCO2EUULHNql6Gz3xdYIqLTMZwgIsp/CjkG2cQuIleaPfjxukRzZT023ileNUREJCUyQK3o70m+bMKbO+PbtvgMIXD40epDqw8HWgFgRGlOw4l/H8FzH6HCiAoTyo1YOA4Gde7enYjyS0RAIAwjJ3ql/rKkdhm6OHKCiLIgv8OJjmF6giBEIpFgMLh///6lS5c+++yzYtdFRERZ09lP1IFzWBERUWYlX2icAQgxyGVo9qQcU56reWaaPdh7Ei9+goNtONgW37lwXI7enYjy0b6TuOPvqDBhqB3D7FgwFqUGsWuivGRW4MYKWJSwKGBWYgrnTSSiLMiDcKK+vv6xxx775z//2djY2JvjGU4QERUylQKjy7GzOd785hRRqyEiooJTkjQ7uRCDw48SfddwoixX4cS/juCJzSl7DGoOmyCi7uxrBYAmN5rc+PAQLh8ldkGUrxQyvDxa7CKIqNBJPZxYtmzZt771LbGrICIiKVlyHh7aAHcQo8tx8XCxqyEiosJSZkC1GTYdSvQo0UMmA4AqM66fiGYPmj1o9uZu5IT1tAGCOXtrIsqBiID9rdjTgt0t2NOCH8zGsNL+nnN/a2Jbr0IFH3cnIiLpknQ4cfLkyeRkwmq12my2gwcPAjCZTGazuaWlJRQKdfy0rq7uoYcemjlzpiilEhFR7kyuwas3whlApQlKudjVEBFRYem4ynQxzI5h00Uo5vTZC6vMIpRBRFnS6MbtKxPNXS0ZDieG2iGX9feEREREWSPpPp2XXnqpY2PRokWtra3t7e0HDhyYP38+gNtuu+3YsWPBYLC1tfWee+4BcOjQoTlz5gwZMkTMiomIKDdMGtRYmEwQEVGBs55aAEMGWLR46kr86jJRCyKijKo2p0zUtqclA+dcPAV3no+Lh2NICUaUZeCElFHLGvFWGz73oCUMISZ2NUREYpP0yImNGzcCMJvNy5YtU6vjF+yrr7567dq1f//735988kkAJSUlTzzxRCwW+81vfnPTTTd1vISIiIiIiCjvVVvw0g2waGHS8PFnogIkl2F4KbY1xJu7MxFOnDMA5wyIb/e+71uIYX8r2v1w+NHux4QqjC7PQDGUyh3Ft3Ylmk8Px90Dzn40EVERkHQ48cknnwC49dZbO5MJAFOnTgVw5MgRv9+v08WfJHr00Ueff/75TZs2bd26dfLkyaJUS0RERERElEkqOWqtYhdBRNk0ogzbGmBQY0QZxlVm+ORpZZq3r0w8yb/kPIYTffOzQ/j7SXii8EYxRIuPzk356YlgSrNaDSKiIifpcKKtrQ3A+PHjk3fW1dV1bBw5cmTkyJEd22q1+rrrrlu+fPkrr7zCcIKI8tK2Bnx4CI4AHH6Eo/jNlWIXREREREREWXbNBCwchypzekFCxsllsOrQ5os32/2iVpPHToRQ74lvGxRn+GmyKk0uSiIikjJJz9ZtMpkAKBQpH+d6vV6v1wM4dOhQ8v5Zs2YB2Lx5c+7qIyLKoF3NWPE51u/Gx0fw6XFEBLELIiKigibE4AujzYcGF447xa6GiKhYVRhRLXYy0cGmS2wznOgrY1IPlifa9acNqeEER04QEUl65MSUKVPWr1+/c+fOLvsnT5783nvvffnll/PmzevcaTQaAdTX1+e0RCKiTLHqUpquAEr0IpVCRERF4InNePPU1+xaK166QdRqiIjiIpHItm3bOpujR48eMICz8udEcjgRCItXRwZs3749Eol0bA8ePHjYsGE5e+vkcMJ7WjhxfRnmTEdDCCdCaAiiiuEEERU9SYcTM2bMWL9+/fLly3/1q1/J5YlBHh3hxNtvv33PPfd07uzIMGQyKTxvQESUvi7hhMPPcIKIiLJIk3QjEIiIV0dfCTH89n2MKsP4KgywSOKhYyLKhFAo9NJLL3U2Fy9ezHAiR74zHUIMVh0sOqgkPc1G3Ekvjjth1cGihVkLeeJKsGLFCp8vPkXV/PnzcxlOnGPEzRUwKmBQpAQVHeQylKtRrsaknBVERCRtkg4nFi5c+OCDD544ceKOO+545plnNJr4bHzTp09/6qmn1q1b53A4rFYrgGg0unTpUgBjx44Vs2Iioj6z6WDRxr9bW3VQnvZN9my8ISzfCpMGFi1MGoyvgp2pBhER9USb5+HEEQdWfRHftulw/xxMGyhqQUREea7OLnYFafr4CH69Kb4tA1YvhlkrZj0AgCtLcWWp2EUQEeUPSYfh48aNu/TSSwEsXbq0pKTkgQce6Nh/ySWXdGxcdNFF//rXvz7//PP58+cfO3YMwMKFC8WqloioX0aWYfViLF+Ep7+On89DrbW3LzzpxV+24Y8f438246EN2N2czSqJiKhQaFWJ7XycvqP+RGK73Y8yg3ilEBGRGJyBxLZMBiNXlyYiyj+SHjkB4K9//eu4ceOOHDni8/nWrl37i1/8AoDVar3nnnuefPLJ7du3X3DBBcnH33777SJVSkQkElcwpSmBx4WIiCgPnF8Lmw4aJXSqlCme8sX2pHDCpMEgm3ilEBGRGBxJq3anTutEmSLE4IrCFYEzCmcE4w2w5OFXBiKSMql/qJhMpt27dz/99NO/+MUvzjnnnM79jz322O7du9euXZt88KpVqyoqKnJeIxGRqFyBlCbDCSIi6o0RZRhRJnYR/aCUQ6+CLwwA46vYJ0VEVHSSR05YeBOUFVs9mLY10dw0CbN6PcKfiKg3pB5OANBqtffdd99//dd/eTyezp1KpXLNmjVvv/32ihUrjh8/Pm3atNtvv72mpkbEOomIxBERYNHCHYQQAwAzhzMTEVER+OFXcN9sHGhF/QlUmLL1LmEBDh92tWCwDeXGvBxiQkRUqJachwVj4fDDGYCq1yv2UTrMqb9XZx6uUUVEEpc3X6/lcrnZbE7eI5PJ5s6dO3fuXLFKIiKShFl1mFUHIQZfCK4gR04QEVGxkMswrBTDsrDwaAy49a846TnD3InfvgCXjcr8OxIR9VM4WnQd9KUGlHLBoezqMomTKypSHURUuPImnCAiou7IZTBquAocERFRBsgAh79rMgHAFYC6yPr+iChf/HoTDrdj/mjMGcabAsqULuEER04QUcYxnCAiIiIiIkpVokeb7wz7y405L4WIqCfeEDYfQDCC3S145gMsnopvnNPzq4h6opXjjyNhVsCihFmJYTqxCyKigsNwgoiIiIiIKFXJWTpgGE4QUVa5g9jTApkM5w5I41Xv7EXw1DPtoSgnO6JMkQG3VYldBBEVNAmFE8HgaeOm+0Sj4QBGIiIiIiLqh1l1GGpHiR4aJcJRlBrQ7EGzB3Z2+RFRdiz9N97ZixMuAJhYnV44sXZnYtugxkV1Ga6NiIgoOyQUTphMpnA43P/zxGKx/p+EiIiIiIiK19fGiF0BERUZVyCeTADY2wIhBrmst6/9r1lYuxPv7IU3hIuHQyuhrh4iIqJu8IpFRERERERERCSqkWWJbV8Yx50YaE3jtSPL8O3pePcAhpdmozrqvx/sR2sE1WpUqTHJiOkWsQsiIpIACYUTo0ePjkQiPR+Xyuv1Hj58OBv1EBERERERERHlwoiylObBtjTCiQ5aJeaO6FcNO5rw0WG0+9HuhzeEp67s19mKVTgGbxSeKLxR6OSo1cb3rzqJvf749uJKhhNERICkwonPP/883Zc0NjZec801neGEzWZ77bXXMl0XEZEYwlHEALVC7DqIiIiIiCj7BpfgK0MxrBQjyzC8FFadCDXsasbyrYlmIAytSoQy8tzkLdjujW/fXIHlo+PbDaHEMdVcLJWICICkwom0CIKwdOnSu+66SxCEjj233nrr008/rdfrxS2MiKjvAhF8/w04AnD64Qvj3lm4ghNeExEREREVAZUcP50rcg1dEhFHAJUMJ9JmTHrAzBONb7ij8EYT+6vUOS2JiEiy8jKcOHbs2MKFC7ds2dLRLC0tfeONN6ZPny5uVURE/aVRYu9JROKZKxz+bo8mIiLqn+2N8AQRiCAQxiAbxlSIXRAREYmqJPVxzzYfKk0ilZLHksMJ76l7O08UMy04EUJDCL4oR04QEcXlWTghCMKzzz77ve99r3PPXXfd9eSTT2q12m5eRUSUH2SARYtWX7zpCIhaDRERFbqfvY1mT3z76vF5EE4IMXxyFGMrYGSnDhFRFlh10Klg08Gqg00HdZ51GUmE4UwjJ6rUePccAIgB7gjUchEKIyKSoHy60hw6dGjBggX19fUdzaqqqjfeeGPq1KniVkVElElWXVI4wZETRESUTdqke4FARLw6eu1QG36wFjKgzo7xVbh+IqrNYtdERFRABtmw7jaxi+id17+AJwiLDlYtaiyos4tdUMKd1Zhvh1EBgwIVp02LJQPM+dQVR0SUXfnxiRhxFAevAAAgAElEQVSNRn/zm9/cd999nXv+8z//85FHHtFo+MwUERWWmUMwpgJWHSxaDO3FN+zNB/DqZzBrYdbArMWdF3ANbSIi6q3kZU7zIpzY3ggAMWB/K/a34urxYhdERFRYZGIX0Hurd+BAa3z7kuF44GJRq0kxr0TsCoiI8kcehBP79u1bsGDBjh07Opq1tbWrV6+eOHGiuFUREWXF4jRHgzW4sLM5vi0D7p6R8YqIiKhgaZLuBYL5EE58fiKxbdFioFW8UoiISFTOpFHmFt3ZjyMiIkmTdDgRiUQeeeSRBx98sHPP/fff/9Of/lSlOm1cHBFRcXInrUth1ECeRw87ERGR2P77KxBi0CihU6aMopCsLxoT2xOq8ukJXyIiyqAY4Ey6D7JyFdIsckaw2QFnFM4IXBHcWIFB/H0TUeZIN5zYsWPHggUL9u3b19Gsq6tbs2bNmDFjxK2KiEhanMHEtokz3RERUTpqLGJXkKY/XYcvG1HfiPoTOLdG7GqIiEgkwTAsWjgCiAoAR05k1+EAFnyRaJ5rYjhBRJkkxXAiHA4//PDDv/zlLzv3PPzww/fff79SKcVqiYjENKIUs+rgDMAdRIVR7GqIiIiyyaDGtFpMq83R2wUiuP8tAFDKoZTjP2eijJdaIpKAGBQb9srH22Et1k55rQqvfRMxwBeCMwAjH9LKIktqV5wrH6aBJKI8Irnu/vr6+iuvvPLw4cMdzVGjRr3xxhsjRozIfSUtLS3/+Mc//v3vfx87dkyhUIwePfq8886bOXOmXq/v/8kFQdi2bdtHH31UX1/f2tpqNpvHjBnz1a9+ddKkSXK5vP/nJ6JisWAsFowVuwgiIqJCtGEPth5LNAdacdcF4lVDRHTKnhbVE++XqOShqQOwcCKm1BTp5K4ywKCGQS12HQWuSzjhjIpUBxEVKAmFE6FQ6P7773/iiSc69/z617++5557FApFjiuJxWLLli177bXXkndu2bJly5Ytzz///P333z9t2rT+nP//Z+/O46Oq7v+Pv2fJzGQPkEBYAygRWSsCVhBFUaKgVOpXwa9bsVC0qO1XrbXVb0Gr/Vn9auvS2lYLiogbBQxUQLEgSl2KiCwqIAiETQlkn8xktt8fEycTJCGQZO6dyev58OHjnJuTO++EyWyfe87ZtWvXvffeW15eHjlSXFy8Zs2aNWvWdO7c+be//W3Hjh2bc34AAAAAzXXUB17ZqQblAID6/vm5JPmCjn8X6d9Fmn2VTulgdCYkrPSoz+SSLPIGjYsCIBGZqDiRn58fmTAh6aqrrurZs+dRFYKmuPLKK5sTIxQKPfnkkytXrgx3k5OTBw4cWFVVtWXLFknBYPCBBx64/fbbR48efXLn//DDD6NXrMrLy+vSpcuOHTu++eYbSQcOHJgxY8YzzzyTlZXVnJ8CAAAAQLOc1V1Ou7x+SbJbNeZUowMBaHtCkqToeRFev1Zur+uelkNlAq3KZtG2s5RhU4ZdLqva5CQdAK3IRMWJ/fv3R3dfffXVV1999STOEwqFmhPjgw8+iFQmfvnLX44YMcJisUjyer1z5sx54403JD322GP9+vU7ifkN+/bti1Qmzj333OnTp6enp4e7u3btmjlzZklJidfrvf/++x977LHm/BQAAAAAmiXNqf8ZpT++q2BIM0aofQss7goAx1fh1cd7tfWQth3StmL9/Up1jNrwZleJbFGfD48/PfYB0db0aaubmwCIAbY3qCcQCDzxxBPh9qxZs0aOHBmuTEhyOp033XTT5ZdfHu4+88wzJ3H+Rx55JNwYO3bsHXfcEalMSOrZs+fjjz8ebn/55Zc7d+48uR8BAAAAQMu4pK+WT9OKabp8gNFRALQZRaWa+abmf6J1e1Xu0dZD9b56Wo4W3uC75/ya73UKOe1M6gIAxDUTzZx46aWXgkGD16775JNPqqqqJPXu3XvIkCHfHXDDDTe88cYbNTU1H374YVlZWWZmZtNPvmvXrnDJITs7++abb46UPSKysrIKCgpWrFgh6f333+/du/fJ/yQAAAAAms8ifed1OwC0ot4dZLUo+O2aENsOaVSvegOSbIFze1YOybZ7AllpztgHxIkKhtronuUAcFwmKk5cccUVRkfQ22+/HW40FMZms40bN27x4sWS3n///YsvvvgkTv7Tn/60oV2+x44du3bt2tzcXL/ffwK5AQAAAACIf1artXv37pFuamrb24veZVdeO311pLa77VBDA0OpjtZN4g8qEJTTRB8cNVHXrl09Hk+4bYYdPe/YodkH1cWhLk71S9GTfYwOBACmEX/PMa0nFAp9+OGH4fbppze4buOwYcPCxYm1a9eeUHFi9erV4cbgwYMbGtOnT5/58+c3/ZwAAAAAACQMl8v185//PNJNS0trZHDCys/RnlL1aq/TcvS9LrG+9bvf0P5ylbhV7tV1Z2rq8FgHaLabb745sh1pSkqsdwwKhrSqVFUBVQZUFdRZ6TpQo3K/yv36wq3DvhjHAQBTozhRp7KyMjJfoX379g0N69Kl9pXBpk2bmn7yioqKsrIySfn5+UlJSc2ICSDR+YIqq1ZptUo9CoY0vPvxvwUAAABAwvjp2brzPDmOveJCq9tdov3lte2SamMyxLOQdOGndd3/O0X7vXXdLq083QUA4gvFiTqlpaXhRrt27azWBrcKj+xiHQwG/X6/3d6k3+Hhw4fDjVNOOSVy5N133/33v/+9a9eu5OTkgQMHjhkzZvDgwY3cNIA24cn39PqW2nZuul651tA0AAAAAGIrK9nIW2+XHFWccBuZJD7ZLEqxyR2o7VYFtL+m7qud2SUEAKJQnKhTXl777JuTk9PIsOh5D9XV1ZFaReOOHKldL7Jbt26hUGjevHmvvfZa5Ksej2fNmjVr1qzp2rXr/fff33gAAAkuy1XXLvUYlwMAkOhKqrV4s7x+efzy+DVpsHo1OHvYMMGQQiHZuHwHAGKlXdQ6SMycOCmp1rriRGVAd3bXLo8O1Gi/V2e0yYXKAKAhFCfqVFfXPul26NChkWEWi8VqtQaDQZ1IceLQodo9rBwOx2OPPfbOO+9Istvt/fv3dzqdn3/+eUVFhaR9+/ZNnz79ySef7Nq163HPedddd+3evbuRAbm5uZICgUBJSUlTQsaR8O8/LCF/QKOUlZVZLBajU8S36Dunz+c7iTun0xGqezfg8ZV+XRwyakI3Wl94MdzKykr+9NCIyKLJYeGFIoGGhJ+JmvIcZNtbnvHcuki38syOvizTPRbZvipJ//Xb/tOy/afn+Ptl+/tmK4mnxZYR/dji8XhqamoaGYzjCv8+eW/S4qqqqiJv1RHRqvc3Z9929iQFs5yhTFcgN80Xh3fpox7fvF5vI4NbQ4olU6otqx92e3/V3q2oyTDH/I3G12PIUa9Oq6qq3O6EmmQT+XGi3+ADaA0UJ+pEnq4cjuMsAeh0OsMvj5r+IFVVVRVuzJ07t6Kiwmaz3X777SNHjgwv4hQKhbZv3/7ggw+WlJT4/f5f//rXf//734+7YFRRUdGOHTsaGRDeOiwUCgUCgUaGJYCE/wFjhufdlnVyf32BtHoPQcEj7mDOsfdws7h9cthCdi4mjXv86eGE8KyHpmjKc1Co/ovNkMdnwnuXY8s3lmp/0oaDSRsOSir50yWBXC46bXlt4S1DzPCbbFncORvXGr8c9yWnHHUbLX4TzWHbV5H+xw+DGY5QhjOY7vSM7xPolNrIeENeac/PK7NblGoNpVhCKdbQCf0K4/EOn3hvZ+LxXwGIUxQn6jT9qtXIyKNqxY3w+XzhRniGxBNPPNG9e90mtxaLJT8//89//vPUqVOrqqpKSkqWLVt22WWXNTU6gATiO61DxW3DQ5muYIYjmOEMtm9wwdn0p/7j+HBfyGkPpTt8/XMqbhsey5wAgLjnrP9ewOM3KEdj7J8dirSDmc5AJyoTANCmWUs99p11cwu85/ZQo8UJQ+Q7+WgbAJqE623rRDaTOO6M5sgci+j9Jxpns9VNP7/22mujKxMRqampt912W7j96quvNr3yASCRBHNSvOfl1Xyvk793u2B2iqwN1k0tFTWSLF6/tdhtqYj1VGUAQLwLOe0hpz2Y4QzmpAa6Z8hlvuuWQkr6vDjS852eLdOtOwUAiClreb03PqEMNpgGgDhmoncgpaWlaWlpx13LqPVkZGREkjQyLHpWqdPZ1GfBlJS6VVnGjBnT0LAzzzwz3CgrK6usrGx8Q4vzzjuvb9++jQwIBAKffvqp1Wp1uVyNDItHPl/dsgMWi6Xp/xBoiMfjkeR0Oln4vplqamoic1qtVutxl4lrDluVL9K2ZqUk3l96W+D1ekOhkMPhCK/yBxxTIBCITMEUj9U4Hr/f7/f7bTbb8S+jcalq4dWRnkUy3RNJMFTzoyG2Ld/Ytnxj3VeugZ15smtB4eegcLtJdxg0KvxY3dov/9qI8HuTsKSkpOhL/RDWlu9vSe56kxIcOZmh7xTXo+9CdrvdwA+ams7M/6YHfZYnvnaU+VURsJQHLTO7eL+XEojeySPx/k4Tb6EqwLRM9AA9ceLE1atXP/300zfddFP4iN/vl2S1WmPzkU1mZma4ceTIkUaGHfXpQBNPnpOTE2m3b9++oWEOh6NDhw6HDx8Ox2i8OBH5RTVk4cKFb7zxhtVqDW8+kUgqKysjxYmE/AFjLBQKhV+9paSkJNhLitgrKyuLvI6x2+2te+esrJvmZW+fxh9CPAq/pne5XCZ8EwLz8Hq90S8/UlNTqWahEW63O1ycSJDnhcsH63JJUkm102Z1pnFJSoupqamJFCccDkdqqunWRYkvHo/H5/NZLJYE+dMzTuS9SZjT6WzrVckVW7XmK43vq7N6yFb7AqBN39/ycnT+KSrzqMyjqprU7KzvTqqLLr46HI7oq0VNy8z/pkG3njxY1721e0pqajC6OOFyuRLsmtHIlUC86gZam4mKE5999pnqzzBISUnx+Xzz58+/+uqrG/6+FhOpBHzzzTehUKihaxLDm0ZIstvtTf8sKbog0fjVjpmZmeHiRPTHEABwDDNGqsStcq/KPRrc2eg0AAC0pnYNbsIEAIms8DNtPqj3vlL7FF0+QDecaXQgo32/h77fw+gQbUtm/c8Oy8y4RxWAeGWi4kR5ebmkyspKowKkpKSkpKS43e5QKFReXh6ZSHGU/fv3hxuDBg1q+sk7duwYaVdXVycnN/jm6tCh2k3/TFgtB2AuY041OgEAAACAVrO7RJu/vWT9iFsHyw1NgzYq46jiBLt9A2g5JpqdFN4jeu7cuUat7GaxWEaMGBFub9u2raFhH3/8cbgxbNiwpp88PT09srLTrl27GhpWXV0dmZnRyOpPAAAAAAAgwb3xRb3u+NMNyoE2zWVVd6fyUzQsXRe2U2fWowXQckw0c+KSSy7Zvn37hx9+2KlTp4svvtjhcITXNXr44YdXrlzZ9PP8/e9/P+kMI0aMCN/WwoULj1l7CAQC//znP8PtEypOSBo7duyLL74o6ZVXXpk1a9Yxx7z//vvhxumnn8764wAAAACANqW6uvrBBx+MdK+66qqzzz7bwDwG++EAfb+H1u/Th3tU7VP/XKMDxYdHHnkksiPCBRdccNlllxmbJ95ZpD31/wrZLhpASzFRceLnP//5E088Iam4uHjevHmR4xs2bNiwYUPTz9Oc4sQZZ5zhdDq9Xu+WLVvWrVs3dOjQowbMmzcv/AzXv3//6JWamuKSSy4JFyfWr1+/atWq888//6gBZWVlTz/9dLg9adKkk/wZAAAAAACIT6FQ6MiRI5Fu9Ka7bdHc9VrxhXxBSbpl5Hd3fsYxlZWVud3ucLu6utrYMACARphoWadevXp9/PHHvXr1MjCDzWabPn16uH3//ff/61//CoVC4a7P55s9e/Y//vGPcPeWW2757rf/6U9/mjhx4sSJE2+//fbvfjUjI+O6664Lt//whz8sXrw4esvr7du3z5gxI/zCKz8//4wzzmi5HwsAAAAAAMSb8X3VIVVWi0afoh8OMDoNAAAtzEQzJyQNGTJk586dPp+vpqZGUmZmZiAQeOKJJ2688caYZRgzZswHH3zw0UcfSfrjH//4t7/97YwzzvB6vevXr49shjF9+vSuXbt+93sDgUAgEJDU0LYZ//Vf/7V79+41a9ZImj179uzZswcPHpyVlbVly5bi4uLwmIyMjJkzZ1osXBEBAAAAAEAb1q+TXrpGHr9SkoyOgpNxoEabq9TFoc4OtUti6gsAHM1cxYmwpKSkpKQkSVarNRAIZGdnp6amxuzWLRbLr3/96+eee27x4sWS3G732rVrowfMmDGjoKDgpE9+xx13DBgw4Omnnw7Pyfj000+jB+Tn58+cOTM9Pf1k4wMAAAAAgERhtRhQmQiGVOlVSbVKqlVarXN7y8rn6ifj7RJd93lt22nVru8rl91FASCKGYsTETNmzAgEAvn5+TG+XavVeuONN06YMGHFihUff/zxV199Zbfbe/XqNXLkyAsuuKCZlQOLxXLxxRePHj36nXfeWbdu3ebNm91ud25u7hlnnHHBBRf06dOHORMAAAAAAMAwy7fq96vquoVTlOkyLk382efV3w6oMqDHiuoO1gSVzQQYAKjP1MWJP/zhDwbeenZ29jXXXHPNNdc0/Vtuu+222267rSkjXS5XQUHBSc/AAJDg3D69v1tl1SqtVqlHP+ivUzoYnQkAAABA25CVXK97xE1x4oQc8un+XUcf7OiQnYtRAaA+UxcnjikUCtXU1FitVrvdziQDAImpwqP736rrDu5CcQIAAABAjLSrX5worTYoR7xKtR3jYGcWdAKA74ib4sTOnTtfeOGF1157bcuWLZGD/fv3v+yyy6699tr+/fsbmA0AWlhm/TcDZbwZAAC0jlU79PoWef2q9ikQ1AtXGx1IkuQP6uUN6pqpLhnqmqE0p9GBAKCNOao4UcL7kROTVr84Mamjzs86dsUCANq4OChOeDyeW2+99dlnn/3ul7Zs2bJly5aHHnrosssumz9/flpaWuzjAUDLc9nlssvjr+1ypRIAoJUUV+mTfXXdQFA2q3FpvvV1hZ75sK478yJdcKpxaQCg7emQol+MVrvk2v+yU40O9K2qGtmscpn9s6w0m9JtSrUpzaY0m67uqB9kG50JAEzJ7A/oHo9n6NCh0bMlUlJSevbsGQwGd+zY4fP5wgeXLFkyePDgjRs3pqaa5ikTAJojM1meCrnsykyW41iP1e9+JZddGS5lONUuxfwv0AEAZnTU04fHr1QTrDqxr7xeNzfdoBwA0FYl2XTp6UaHOJY//1tLP5fTrkyXTsvRAxcbHejY0m0qH2V0CACIB2b/MOvmm28OVyY6duz41FNPFRQUZGRkRL5aWlr61ltv3XbbbQcPHty5c+d///d/v/7668aFBYCW85cfKsXRYMkhJM18U4FgbXfqcF13ZsyiAQASh7P+E43XHMWJA/WLE10zDcoBADCZMo8kef36ptJE8zkAACfL1MWJnTt3Pvfcc5KGDx/+zjvvuFyuowZkZWVdeeWVEyZMuOiii959993CwsKtW7eedtppBmQFgJbVPqWxr4ZXBo/IOPrhEQCAJslN1/d7yJUkp10uu+wmWNNJUmm1LFJIkpTq4GkOAFAresHbLJ4dDBMyOgCAhGHq4kS4MmG1WpctW/bdykSE0+lcunRp+/btA4HA3LlzH3zwwdhFBABDlHvqdfnUBgBwcgZ11qDxRof4jhuG6uozdLBC+8tV6ZXF6DwAAJMoi3oflJnc8Di0sF0e/dcWlftVFlCZX4v6W4YZHQlAYjDHtVENePPNNyXdcMMN7du3b3xkRkbG9OnTJS1dujQWyQDAWEcXJ5wG5QAAoHU4bOqRpe/30IV9jI4CADCN6d/Xz0dpyjBNHKAzuxmdpg2xWfRxhbZX65saeYMq8xsdCECiMPXMic2bN0s655xzmjJ45MiRf/7znz///PNWDgUAJtC7g169ThUelXlU4dUpHYwOBAAAAACt7JxeRidoozJs9bplfsnWwFAAOBGmLk4kJSVJqqmpacpgr9cb+RYASHB2qzqlqVOa0TkAAAAAAAkuvX4pojxgUA4ACcfUyzoNHTpU0htvvNGUwcuWLZM0fPjw1s0EAAAAAAAAtBlWi27I1bTOurO77u+lERlsiQ2gZZh65sSECRNWrly5ZMmSL7/88tRTT21k5O7du1977TVJF198cazSAQAAAAAAAInvub517WBQR44YFwVAAjH1zInJkyeHG6NHj96/f39Dw77++utzzz033L7++utjkQwAAAAAAAAAAJwsUxcncnJy7rvvPkn79u3r2rXrnXfe+cknn5SWlvp8Pp/PV1paumHDhl/+8pe5ubl79uyRdM8993Tu3Nno1AAAAAAAAAAAoDGmXtZJ0j333PPxxx8XFhZKevTRRx999NGGRhYUFMyaNSt2yQAAAAAAAIDvKPfrFzvVxaHODnVxani6OjqMzgQA5mP24oTNZlu8ePHs2bNvvvlmn893zDFJSUlPPvnktGnTrFZTTwQBAAAAAACIDx8V6esKlVSrpFp9c1RwmtGB4sler/4WtTz56wM0Idu4NABgVmYvTkiyWCw//vGPr7vuunfeeWf16tUffvjhnj17QqFQXl7ekCFDLrzwwnPPPdflchkdEwAAAAAAIFE8/b52Hq5tX9iH4sQJeeZAvW5WHHz8BgAGiJtHR4fDcdFFF1100UVGBwGAWFm4WZ/uV2m1yjzq2U6zxhodCAAAAECb0S65rl1SbVyOuNQhqV63q9OgHABgbnFTnACANmfzQa3eUdu2WgyNAgBIaCHJH5THJ0npfHwCAJAkZUUVJ0opTpyYaZ01a5cCIUkanqFTko/3DQDQJlGcAACzyopasI43AwCAVvKLf2pdkYIhSRrRU//vEiPDvL5F//xcXTLUNVNdMjTudFGdBwCjtE+WJLtVWcn1ZlGgCTo59PZgPVykdnb9rpfRaQDArChOAIBZRV+pVOZRSHxAAwBoFeHKhCSv39Ac0o7D2npIWw9JUrtkjT/d4DwA0JbdMFQ/GqpUp1nehqzcrgynMpOV5VK7FDlsRgc6jvOydF6W0SEAwNwoTgCAWXXJUH6OslzKSlZWsvxBJVklaX+5Xt6gTJfSncp06ft5ynQd71wAADTAFfWOoNpnXA5J0v7yunbXTONyAABMttCfx6/frqzr/uwc/XCgcWkAAC2D4gQAmNWFfXRhn2Mc31um17fUdf9+FcUJAMDJiy5OGD5zIro40SXDuBwAAJMp89TrZrLMFAAkAooTABBvKo56XW6mC5oAAHHn/FPUq71cdjntapdicJhze2l3qQ6Ua385MycAAHXK6m/Cl8XlWbEWktwBlQdU5ldJjbL9lnb20PG/DQAaRXECAOJNmbdeN53X5QCAZhjRUyN6Gh3iWzedXdsISf6AoVEAGMPpdM6YMSPS7dmzp3FZYCalR12h1diboKlTpwYCtU8iXbp0ab1QbcqOavX5MNKzPt8jaVxGjYF5ACQGihMAEG+SrMpNV7lHbp8ctnrLcQAAkBgsUpLZdzoF0BpsNlvv3r0j3bS0NAPDwETO7Kp/XK8yj0qrVeZRl8Zm1/Xs2TMUqr2oPyXF6EmBiSKj/tNyecAk+6QDiG98pAUA8eayfrqsnyT5g6r0Hm80AAAAAMQ5m1XZqcpONTpH25VZ/xPEypDVoCAAEgoPJQAQt+xWZbERHAAAAACgdTmtckR9iMjMCQAtIm5mTni93nfffbewsHD9+vVbt271er3l5eWS5s2bl56ePn78eLs9bn4WAAAAAAAAII483UdOqzLtSrMEO3g9x/8GADieOPhAPxQKzZ49+5ZbbvF4jvHAt2jRooULF/bo0eOtt97Kz8+PfTwAAAAAAAAgsd3YubYRDOrIkaChWQAkCLMv6xQIBC6//PKpU6ceszIhaePGjZL27NnTr1+/zz77LLbpAAAAAAAAAADACTN7ceLee+8tLCyU1KNHj3nz5hUVFT377LPRAxYtWnT22WdLCgQCY8aM8fv9xgQFAAAAAAAAAABNY+riRFFR0UMPPSRpzJgxX3755TXXXNOtW7cOHTpEjxkwYMDatWtvv/12SQcPHly+fLkxWQEAAAAAAAAAQNOYujgxe/ZsSUlJSYsXL05KSmpomMViefjhh3NzcyXNnz8/dvkAAAAAAAAS1ZfFevBt3blUP35NP3xeX1caHQgAkFBMXZxYtmyZpOnTp6elpTU+0mazTZs2TdLatWtjkQwAYikkVXhVVKqagNFRAAAAALQZ5V69uU3/KdKXxTrsVonb6EAAgIRiNzpAYzZt2iRp6NChTRk8YMAASXv37m3dTAAQS59/o18vU5lHgaAk/fUK9e1odCYAAAAAbUO75HrdkmqDcgAAEpOpixPJyclut7u8vLwpg4uLiyVlZGS0cigAiCGnTUeirk4q9RgXBQCQoIIh7Twij09evzx+9WqvLka8ot52SJku5aTJajHg1gEAx0RxAgDQmkxdnBg5cmRhYeGCBQtuvfXW4w5esGCBpBEjRrR+LgCIlaz6bwZKeTMAAGhp/qB+/Gpd9+ejNHGAATF+tUzFVbJblZuuKwbqhwMNyADABHw+X/RyzYMHD+7Zs6dxcdq8DJd6tVdWstolq12yemQZkCEknWDZ+oMPPvD7/eH2qaee2r9//5ZPBQBoCaYuTkyYMKGwsHDNmjXr1q1rfHGnjRs3rlq1StL48eNjlQ4AWl+Gq16X4gQAoMUl2WS1KBiq7Xp8BmTw+lVcJUn+oPaWycseS0Db5fP5Fi5cGOlmZmZSnDCS1aLnJhmcYV2Rfvcv5WerT47yszW8h1zH+Sxr6dKlbnftBPTx48dTnAAA0zJ1cWLSpEnTp08PBAKjR49evXp1Q/WJbdu2jR49OtyePHly7PIBQGuzW3XNGUpxKMulzGSd2vV8NWoAACAASURBVEGvfqo3vlCGSxlOZafq56OMjggAiHMWyWlX9bc1CY/fgAz766/jasi6UgAAc9pWrCNufbBHH+yRpKU3Hrc4AQCIF6Z+QE9LS3vxxRcnT55cVVU1bNiwgoKCKVOmrF+/PvzVoqKiHTt2zJkzZ+7cueEjjz/+ePv27Y3LCwCt4Cffr9c9UK6vjtS2c9IoTgAAWoArqjjhNUFxoivFCQDAt7Yfqmt3zlC607goAIAWZurihKRJkyZt3bp15syZklasWLFixYrIl3r06BE9csqUKU3ZmgIA4lu5t66dyetyAEBL+G2BrFY57XLZlek6/vgW970ueupy7S/XvnLtL1OXTAMyAADMaVtxXTs/27gckDugd8pU5lepz3KwIvmS9JpTnKzECKBZzF6ckPSb3/zmkksuueaaa7Zv337MAe3atXvhhRfGjRtnsZzgHkkAEHfKPXXtdCM+PwIAJJ6BnQ0OkOrQwM7GxwAAmE1IumKgth7StkPaXaI+FCeMdNivcRvDTYuU2i0pSHECQDPFQXFC0rBhw7Zu3bpr165Vq1Zt3rx5586dfr+/c+fOgwcPPueccwYNGmS1Wo3OCAAxMbyHspJV4VWZR71ZyA4AAABA4rJIVwysbXv98gcNTdPWZdrqdcsDXCIMoLniozghyWKx9OrVq1evXkYHAQBDXTnI6AQAAAAAEHNOu1jX1lBpNlmk0Lfd8iDFCQDNFd8TDvx+I/brAwAAAAAAANoSq0Xp317kbJG8IYoTAJorPooThw4d+r//+7+//e1vRx2/44478vLyfv/735eXlxsSDAAAAAAAAGgLPhqiorNVMiJ4sH/xHTluo+MAiHtxUJx46qmnOnbs+Itf/KKwsPCoL23cuHHPnj133313dnb20qVLDYkHAAAAAAAAJLzTUtTNqQy7rMyaANASzF6ceOSRR2699dZw+z//+c9RX83Pz09JSZHk8/kuu+yyRYsWxTofAAAAAAAAAAA4QaYuThw4cOCuu+6S5HK5Xn755b179x414K9//WtFRcU///nP9PR0SZMmTSorKzMgKAAAAAAAAAAAaDJTFyfmzJkTbnzyySeTJk1KSkr67hir1Tpu3Lj169dL8vl8zz//fEwjAgAAAAAAJLyagDYf1MsbtHaX0VEAAAnC1MWJ119/XdIPfvCDvn37Nj7y1FNPve666yS98sorsUgGAAAAAADQRvxmhcY9qxmL9PT7Wr7V6DQAgARh6uLEli1bJE2YMKEpgwsKCiStW7eudTMBQOwdrNDmg3rvKy39XB/tMToNAAAAgDbGZpUvWNvefFAhQ8MAABKF3egAjQmv41RdXd2UwcFgUJLVaupyCwCcjJlv6otvatujeml4D0PTAAAAAGhj+nfSv76sbR9x62C5OmcYGggAkAhM/VH+GWecIWnx4sVNGfzWW29JGj58eOtmAoDYy3LVtcs8xuUAACSo/eX6xya9+Ilmf6Q//1sV3tjddFGp/vCuXvlU736lnYfrLssFAJjKgNy6dsc0HaoyLgoAIHGYeubEFVdcsWrVqpUrV27atGngwIGNjNy3b98LL7wg6dJLL41VOgCIlazkunZpkyaTAQBwAnYe1hPv1XUn9Fe6M0Y3vb1YizfXdeddre5ZMbppAEDTnZqtqwarfyf176SctFjc4pqdcvuUn628drKZ+spaAMBJM/Xj++TJk8ONc889d9OmTQ0NKyoqGjVqVLh9/fXXxyIZAMRSdHFib5mCrPAKAGhRyUn1uh5/7G56f3ld22pRLouEAIAp2a2aMUKjT4lRZULSq5/q//1LU15VwbN65J0Y3SgAILZMPXOiQ4cODz300N13311aWjpo0KCxY8f+6Ec/6tu3b/v27SWVlpZu3779lVdeWbBgQXj8ww8/3KlTJ0MjA0AruPR0jeyprGTd9U8dKNcFf1GaUxfl62fnGJ0MAJAQnPXfFHgNKk7kpCnJ1NdOAQBiJBjS9sO1bV9ADpuhaQAArcXUxQlJd911165du/7yl79IevPNN998882GRt5444133HFHDKMBQKx0z6q3xkVIqvAqwKrcAIAW4rJLktWi5CQ57TGdoue0qV2ySqolqQvTJgAAkqS9ZfL46rr52cZFAQC0IrMXJywWy9NPP33FFVdMnz59586dxxyTl5c3Z86c888/P8bZACDWyqN2w85wNTwOAIAT0buDVk43ZtbCz0bpZ6NU7dP+ctYtBADUOlghp71uJl9+jqFpUKfUr4f2qNRnKa5OLw9Ybsup/n6K7/jfBgANMHtxIuzCCy/csWNHUVHRxo0bN23a9PXXX/v9/tzc3L59+w4dOjQvL8/ogADQ+vxBVdXUdTNitVUpACDhWS2yWowMkJykUzoYGQAAYCrDu2v5VBWValuxth9SXjujA6GWL6Tf75FkkZySJmR4v59idCYA8Sw+ihNh3bt37969+/jx440OAgAGeeBilXtU7lG5V/3YYgcAAABAgrJalNdOee10UR+jo6BORv3tPyqCbBYFoFniqTgBAG2a3apRvYwOAQAAAABoo5xWOa3yfrsBYkXQ0JmXAOIfxQkAAAAAAAAAx9fLJW9QqfJn2EKdk4LH/wYAaFg8FSdC32p8mM1ma3wAAAAAAAAAgBP1+XAFg8EjR0qNDgIgEcTB2nAHDhy4++678/LyrFarzWazH4/ReQEAAAAAAAAAQGPM/lH+ypUrL7roIqNTAAAAAAAAAACAFmPq4sSRI0cuvvjiSDcrK+u0005LTk62WNhvBwAAAAAAwCAh6esK2a3KTjU6CgAgXpm6ODF79uxAICCpoKBg3rx52dnZRicCAAAAAACtxWaz9evXL9LNysoyMAyObcFGbTygzQd12K1rh2jaWUYHOtppp53m9XrD7Y4dOxobBgDQCFMXJxYvXiwpNzd36dKlbCYBAAAAAEBiczqdP/7xjyPdtLQ0A8Pg2JZt1ZfFte3NBw2NcmzXXXddKBQKt1NSUowNAwBohKk/8f/kk08k3XTTTVQmALR1e0r17lcqrVZptUo9mnWRUh1GZwIAAADQ9vTvVFec+OIb+YOyWw0NBACIV6b+0D8tLc3tdvfu3dvoIABgtN0l+tsHdd0jbooTAID4FgzJyk5yABCHBuTq9S21bY9fOw7rtBxDAwEA4pWpixNjx46dN2/e1q1bjQ4CAEbLctXrlnrU3aAkAICEtPQzfVQkj19ev9qnaOZFrX6LD76tj/eqS4a6Zqp/J10+oNVvEQDQIgbkKidNAzppQK4G5OqUDi15cq9fTlN/VAUAaEGmfsS//vrr582b95e//GXWrFms7ASgTctMrtctrTYoBwAgQW0r1js7a9udM2Jxi/vKVFKtkmpt+VrlHooTABA3OmdowXWtcuYKrybMUfcs5WcrP0fn9lZueqvcEADAHEy9LOCFF144dOjQw4cP33vvvUZnAQBDZSVLUkqSOmeob0c5bUYHAgAkFlfUlUAeXyxucX95XbtLZixuEQDQIlpvTb7txQqGtLtEb23Xn/6totJWuyUAgCmYujhhsVhWr17dt2/f3//+9+eff/6//vWvQ4cOeb3eQKOMTg0ArSDdqV7t5fbpQLm++EbtUowOBABILK6kurbX3+o3V1WjMk9dt2tM5moAAExu26F63T7ZBuUAAMSIqddKuu666/x+f4cOHSStXr169erVTfmuUCjUurEAIPYs0l2j9fBqlVTrykG8TAcAtLDO6erXSS67XHYlO2JxizNGaF+59pdpf7m6Z8XiFgEAJre9uK7dMa12+jgAIHGZujjxyiuv+HwxmVQOAObXr5Oem2R0CABAgrqkry7pG7ubS3XoqsGxuzkAQFy49HR1y9S2Ym0vVn6O0WlwbMU+XbbJesTbriJoKQ9Y/ti18jp2BgFwskxdnBg5ciTFCQAAAAAAgMR3Rled0bW27WPVbpNyWPRBuaTafRDLAq23CQmAxGfq4sSqVauMjgAAAAAAAIDYSrIZnQDHlmaTRYqsqF4RpDgB4OSZekNsAAAAAAAAACZhtSgj6lLncmZOAGgGU8+cAAAAAAAAAGAeV2aHKj3eDFso3RoameqLLPEEACcqbooTXq/33XffLSwsXL9+/datW71eb3l5uaR58+alp6ePHz/ebo+bnwUAAAAAAHyX2+2+++67I93rr7/+3HPPNTAP4tGsWbOqq6vD7UsuueSKK64wNk/i+Wt+6MiRyqgDLsOiAIhzcfCBfigUmj179i233OLxeL771UWLFi1cuLBHjx5vvfVWfn5+7OMBAAAAAICW4vP5Iu1gMGhgEsQpv98fuRcFAmysDQDmZfY9JwKBwOWXXz516tRjViYkbdy4UdKePXv69ev32WefxTYdAAAAAAAAAAA4YWafOXHvvfcWFhZK6tGjx+9+97vzzjtvxYoVU6dOjQxYtGjRT37yk/fffz8QCIwZM6aoqIj1nSLCFwgEg8HKysrjDo4vR11Kk3g/oFHcbrfFwmZWzRJ9YY7f7+fOicaFQiFJHo+npqbG6Cwwr6Ou+KuqquKxGo3w+/2SAoEAz0FoXPg5KKympia6i5OQwG++Ysztdkd3a2pq+JV+l1nubyFZDlXZPj9k+/yQ7YtDNRP6+i/obWSeb0U/oMXLmzKz/Js2zVFPGR6PJ/pTmgQQeSBi8hbQ2kz9OX5RUdFDDz0kacyYMcuWLUtKSpLUoUOH6DEDBgxYu3btnXfe+dhjjx08eHD58uWXXnqpMXHNJ/wYGgwGG5p3khhCoVBi/4Cx5PV6jY6QUBL+rw8thcoETgiP1WiKQCDAQhZoOu4wLYX3Js131NNcIBDgV9oQ4+9vgWCHmwotXn9td+MBz4guRuY5lvi6Cxn/b3pSfD5fghUn4vFfAYhTpi5OzJ49W1JSUtLixYvDlYljslgsDz/88Pz58w8ePDh//nyKExFWqzX8f5cr0fYm8vl8kbdPFovF6XQamycBhJ96nU4nV+M2U01NTeTaCqvV6nA4jM0Dkwv/6TkcjvAjNnBMgUAg+v0ej9VonN/v9/v9NputkdfPgCSv1xu59JU7TPOFH6t5b9J8R12nbLPZEu/9bPOZ5/4W7Jtt+/RguO3YXmLCf6x4uQuZ59+0KUKhUHQdMSkpyWazGZinxTFhAogZUxcnli1bJmn69OlpaWmNj7TZbNOmTfvtb3+7du3amESLD+HnBqvVetxfYNyprKyMFCcS8geMscjVGSkpKQn2kiL2ysrKIq9j7HY7d040LvzBkMvloo6FRni93ujiRGpqKtUsNMLtdoeLEzwHoXHRSzk5HI7U1FRj88S78KomvDdpvqMK8A6Hg1/pd5no/ja4q74tTlh3l6RZHEo1/mVt9L0oXt6UmejftAmCwWB0ccLlcsVFTaXpInchXnUDrc3UxYlNmzZJGjp0aFMGDxgwQNLevXtbNxMAAACQ2EJSMChb67wbD0lvbVPndHXJVPsUMQsIAOLagFxJSrKpb0cNyJWPBeIAACfA1MWJ5ORkt9tdXl7elMHFxcWSMjIyWjkUAAAAkIim/0MHK+TxyePXpMH66YhWuZUStx58u7bttOtXF+j8U1rlhgAAMTCos57+ofrkKKkZJe0N+7Vhv/pkKz9b2WnUrQGg7TD17KSRI0dKWrBgQVMGh4eNGNE6b6IAAACAxFbuUWm1PH5Jtf9vDfuiLjzy+pWRUKtAAECbk5ykfp2aVZmQtHaX5vxHv16m/3pBk+Yp1ELZAACmZ+rixIQJEyStWbNm3bp1jY/cuHHjqlWrJI0fPz4WyQAAAIAE44raD7n1ihP7y+p1u2a21g0BAOLFtkN17Q6s+AcAbYipixOTJk0K7807evToRuoT27ZtGz16dLg9efLk2GQDAAAAEoorasVXb+sVJ6JmTtit6hgH234CAFpRMKTtxXXdPtnGRQEAxJqp95xIS0t78cUXJ0+eXFVVNWzYsIKCgilTpqxfvz781aKioh07dsyZM2fu3LnhI48//nj79u2NywsAAADErQv7aHAXuexy2pXXrrVu5YahGtdX+8u1r1wVXlm5PhYA2rZyj7JT5a6pXc0pP8fgPGiamqAqQ9bygKU8YOmbbOnCMo0AToqpixOSJk2atHXr1pkzZ0pasWLFihUrIl/q0aNH9MgpU6bceuutsc4HAAAAJIYrBsbiVqwWdUpXp3Sd0TUWNwcAMLmsZM2drGqfdhzW9mIN4dkhDlQG9ERxSrotlGELpVuCvYNGBwIQt8xenJD0m9/85pJLLrnmmmu2b99+zAHt2rV74YUXxo0bZ7Fw4RUAAAAAAEBcSU7SgFwNyDU6B5okzaY7O7oj3XQH8yYAnKQ4KE5IGjZs2NatW3ft2rVq1arNmzfv3LnT7/d37tx58ODB55xzzqBBg6xWU2+eAQAAAAAAAAAAIuKjOCHJYrH06tWrV69eRgcBAAAAAAAAAADNYuoJB//4xz9ee+21oqKipgzevXv3Pffcc8EFF7R2KgAAAAAAAAAA0Bymnjlx9dVX+3y++fPnX3311ccdvH79+t/97ncxSAUAAAAAAAAAAJrD1DMnTsgXX3whic0nAAAAAAAAAAAwORPNnFi6dOnu3bujj/h8PkkvvfTSkSNHGvnGmpqanTt3PvXUU5IGDRrUqiEBAAAAAABwDB6/tn6jzV9rVC/1yDI6DQDA7ExUnMjLy7vsssu+e3zJkiVLlixp4kmmTJnSoqEAAAAAAADQqKoa3b5E24sVCEqSw0ZxAgBwXCZaBGngwIFTp05tzhmmTp06Y8aMlsoDAAAAAACA40txqLiqtjIhafNBQ9MAAOKDiWZOSHrqqafuuOOOSLd///7BYPDuu+++4YYbGvkum82WkZGRlZXldDpbPyMAAAAAAACiWKQBuVq9o7a7+aBCkqXh8VU12nlYgZC+1yUm+QAAZmSu4oTT6ezbt2+ka7PZgsHgoEGDog8CAAAAAADAXPp3qitOOGyq9Cr9WJeQzv6P3tqm/eWSNCBXf5oYu4QAAJMxV3HiKMuWLQuFQgMGDDA6CAAAAJDo/EEddsvrV7VPXr96tT/2h0onbfUOrdimrhnqkqEumRreXdZGLqkFAMSbYd01+XsakKv+ndQ+pcFhFd7ayoSkHYcVDPF0AABtlqmLE2PGjDE6AgAAANA27C7Rja/Wdf/vUg3r3pLn/+KQ/r2rtp2cpGXN2m0OAGA6vdrr5rOPP+zUDnXtap8OVqhLRuuFAgCYmYk2xD4JPp+vuLi4pqbG6CAAAABAnEtOqtf1+Fv4/MWVde3c9MYWIgcAJLBTs+t1dxw2KAcAwHjxUZzYs2fPpk2boo94PJ5p06a5XK6cnByn03nllVceOHDAqHgAAABA3HPWn1TtbeniRJWvrt2yC0YBAOJIz3Y6/xRNO0sPjdM/rtc5vYwOBAAwjNmLE263u6CgIC8v74EHHogcDAaDBQUFzz77bDAYDB9ZsGBBXl7e7t27DYoJAAAAxDlX/eKEx9fAuJPVPlldMpTpUpJNqY4WPjkAIF447Zo1VtcO0dl5yk5lIh0AtGWm3nNC0uTJk998801J69atixxcvnz5mjVrwu1Ro0YdOnToiy++8Pl8I0eO3LVrl91u9h8KAAAAMJ3kJN03Vk67XHa5klp+BfBfjK5rB0MtfHIAAAAA8cbUn+Nv3LhxyZIlkrp16/bXv/41cvyRRx4JN5YuXTp+/HhJc+bMufHGG/ft27d8+fJLL73UkLQAAABAHLNaNPqU2N0WAByLy+W66667It3OnTsbGAZx6mc/+1kgEAi3c3JyjA0DAGiEqYsTr732miSHw7F58+bMzMzwwcrKytWrV0vKzc0dN25c+OCUKVP+/Oc/r1u3rrCwkOIEAAAAAADxyGq1durUKdJNSUkxMAziVE5OTihUO0WPuxAAmJmp95wIr910zTXXRCoTkt57771w4+abb7ZY6i65uvrqqyWtXLkythkBAAAAAAAAAMCJMXVxYuPGjZLOOeec6IPh6RSSItMmwrp37y5pz549sUoHAAAAAAAAAABOhqmLEzU1NZJsNlvkSDAYfPnll8PtgQMHRg+urKwU8/UAAAAAAAAAADA9Uxcn8vPzJW3bti1yZOfOnW63W1JBQYHT6YweHN6I4vTTT49pRAAAAAAAAAAAcIJMXZy46KKLJD3//POBQCB85Pnnnw83pk2bFj3ym2++mTt3rqSxY8fGNiMAAAAAAAAAADgxpi5OXHvttZL27ds3ceLETZs2zZ49+4EHHgh/KVKECIVCGzZsOPPMM8PdyZMnGxIVAAAAAAAAAAA0kd3oAI0ZNGjQhAkTCgsLlyxZsmTJksjx++67Lz09PdwePHjwpk2bwu2JEyf279/fgKAAAAAAAAAAAKDJTD1zQtKCBQuOmgwxbdq0//3f/410I5tMXHnlla+88kpMwwEAAAAAAAAAgBNn6pkTkpKSkl566aVHHnnkk08+sVgsQ4cOzc3NjR4watSo1NTUGTNmRFZ2AgAAAAAAAAAAZmb24kRYt27dunXrdswv3XLLLTEOAwAAAAAAAAAAmiM+ihMAAAAAWt3uEm09JK9f1T75g/rvM1rszK9+qqWfK9Wh5CR1SNE9Y1rszAAAAADik4mKE36/P9yw2+1HHTkhkW8HAAAAcALe362n36/rXn2GLC105m8qtbuktp2d2kInBZCAfD7fihUrIt2zzjrr1FNPNTAP4tHKlSsjHyj179//e9/7nrF5AAANMdHn+CkpKT6fT1IoFDrqyAmJfDsAAACAE+Cq/+6gxi9nC71fcEe9qk9JaplzAkhEPp/vzTffjHS7du1KcQInavXq1W63O9xOSkqiOAEApmU1OgAAAAAAcziqFOE9mXnMx1ZVU9dOdbTYaQEAAADELRPNnDj//POPmifx3SMAAAAAWosrak5Dkq0lixNDuio5Se4aVdWoR1aLnRYAAABA3DJRcSJ6WcmGjgAAAABoLWfnafGP5LTLaZOtRedY/6C/ftC/JU8IAAAAIM6ZqDgBAAAAwEgu+9HbTgAAAABA62DPCQAAAAAAAAAAEFPxXZzw+XzFxcU1NTXHHwoAAAAAAAAAAMwhPooTe/bs2bRpU/QRj8czbdo0l8uVk5PjdDqvvPLKAwcOGBUPAAAAAAAAAAA0ndmLE263u6CgIC8v74EHHogcDAaDBQUFzz77bDAYDB9ZsGBBXl7e7t27DYoJAAAAAAAAAACayuzFicmTJ7/55puS1q1bFzm4fPnyNWvWhNujRo3q27evJJ/PN3LkSL/fb0hOAAAAAAAAAADQRKYuTmzcuHHJkiWSunXr9te//jVy/JFHHgk3li5dumbNms8//3z27NmS9u3bt3z5ckOiAgAAAAAAAACAJjJ1ceK1116T5HA4Nm/efOGFF4YPVlZWrl69WlJubu64cePCB6dMmTJ06FBJhYWFxmQFAAAAAAAAAABNY+riRHjtpmuuuSYzMzNy8L333gs3br75ZovFEjl+9dVXS1q5cmVsMwIAAAAAAAAAgBNj6uLExo0bJZ1zzjnRB8PTKSRFpk2Ede/eXdKePXtilQ4AAAAAAAAAAJwMUxcnampqJNlstsiRYDD48ssvh9sDBw6MHlxZWSkpJSUlhgEBAAAAAAAAAMAJM3VxIj8/X9K2bdsiR3bu3Ol2uyUVFBQ4nc7oweGNKE4//fSYRgQAAADQuKoalVbLFzA6BwAAAAATsRsdoDEXXXTRhg0bnn/++fvvvz88f+L5558Pf2natGnRI7/55pu5c+dKGjt2bOxzAgAAAAliwUZ9VSKPT16/+uTohjNb4JyLNuuZDyUpyaoMlxbe0ALnBAAAABDnTD1z4tprr5W0b9++iRMnbtq0afbs2Q888ED4S5EiRCgU2rBhw5ln1r5rmjx5siFRAQAAgETw791a+plWbte7X2nzwZY5p7umtuELMn8CAAAAQJipZ04MGjRowoQJhYWFS5YsWbJkSeT4fffdl56eHm4PHjx406ZN4fbEiRP79+9vQFAAAAAgMbii3iB4fC1zzqqo86Q4WuacAAAAAOKcqWdOSFqwYMFRkyGmTZv2v//7v5FuZJOJK6+88pVXXolpOAAAACDBRBcnvP6WOWdk5oSkVIoTAAAAACSTz5yQlJSU9NJLLz3yyCOffPKJxWIZOnRobm5u9IBRo0alpqbOmDEjsrITAAAAgJOUk6buWXLa5bIrr13LnHPiAJ3ZTe4aVdUo3dky5wQAAAAQ50xdnPB6vX6/PzU1tVu3bt26dTvmmFtuuSXGqQAAAICEdfPZuvnsFj5nv07q16mFzwkAAAAgzpl6WafnnnsuIyPjf/7nf0KhkNFZAAAAAAAAAABAyzB1ceKFF14IBoPFxcUWi8XoLAAAAAAAAAAAoGWYujixYcMGSRdccIHRQQAAAAAAAAAAQIsxdXFiyJAhkr744gujgwAAAAAAAAAAgBZj6uLE/fffL+kPf/jD7t27jc4CAAAAAAAAAABahqmLE6NHj164cKHP5+vdu/esWbPWr19/+PBhv98fapTRqQEAAAAAAAAAQGPsRgdozE9+8pNAIJCXl7d79+777rvvvvvua8p3UZ8AAAAAAAAAAMDMTF2ceO6553w+n9EpAAAAAAAAAABASzJ1cWLw4MF+v9/oFAAAAAAAIBZsNtuwYcMi3ZycHAPDIE4NGTLE6/WG2927dzc2DACgEaYuTvznP/8xOgIAAAAAAIgRp9M5efLkSDctLc3AMIhTP/zhDyMrfqekpBgbBgDQCFNviA0AAAAAAAAAABKPqWdOAAAAADBSMCSrpVlnKCrVziNKSVKqQykO9chq7gkBAAAAJASKEwAAAACizHpTu0pU4VWlVxf31f+MatbZ3t+tP/27rvuv6RLFCQAAAADxU5zwer3vvvtuYWHh+vXrt27d6vV6y8vLJc2bNy89PX38+PF2e9z8LAAAAIB5FZXpqyO17Upvc8/mIgbaMAAAIABJREFU9tW1XXbZWFcWAAAAgBQXxYlQKDR79uxbbrnF4/F896uLFi1auHBhjx493nrrrfz8/NjHAwAAABJKmqOuXdHs4kRVTV07xdHwOAAAAABti9kvXAoEApdffvnUqVOPWZmQtHHjRkl79uzp16/fZ599Ftt0AAAAQMJJd9a1m1+ccEcVJ1IpTgAAAACoZfaZE/fee29hYaGkHj16/O53vzvvvPNWrFgxderUyIBFixb95Cc/ef/99wOBwJgxY4qKiljfCQAAADh5Q7oqxaF0p9Ic6prZ3LP9dISuO1NVNXLXsNsEAAAAgAhTf45fVFT00EMPSRozZsyyZcuSkpIkdejQIXrMgAED1q5de+eddz722GMHDx5cvnz5pZdeakxcAAAAIAH8cGBLni3VwYQJAAAAAN9l6mWdZs+eLSkpKWnx4sXhysQxWSyWhx9+ODc3V9L8+fNjlw8AAAAAAAAAAJw4Uxcnli1bJmn69OlpaWmNj7TZbNOmTZO0du3aWCQDAAAAAAAAAAAny9TFiU2bNkkaOnRoUwYPGDBA0t69e1s3EwAAAAAAAAAAaB5T7zmRnJzsdrvLy8ubMri4uFhSRkZGK4cCAAAAAACtIhQK1dTURLqBQMDAMIhTNTU1oVAo3HY42PcIAMzL1MWJkSNHFhYWLliw4NZbbz3u4AULFkgaMWJE6+cCAAAAAAAtr7q6+le/+lWkO2XKlNGjRxsXB3Hp/vvvd7vd4fb48eOvuuoqY/MAABpi6mWdJkyYIGnNmjXr1q1rfOTGjRtXrVolafz48bFIBgAAAAAAAAAATpapixOTJk2y2WySRo8e3Uh9Ytu2bZErKSZPnhybbAAAAAAAAAAA4OSYelmntLS0F198cfLkyVVVVcOGDSsoKJgyZcr69evDXy0qKtqxY8ecOXPmzp0bPvL444+3b9++pW790KFDb7/99kcffbR3716bzXb66aefddZZo0aNSklJaambiKiurv7xj39cXV09fPjw6BmsAAAAAAAAAAAkHlMXJyRNmjRp69atM2fOlLRixYoVK1ZEvtSjR4/okVOmTGnK1hRNEQqFnn/++YULF0YfXLdu3bp1655++ulf//rXw4cPb5Ebinj00UcrKyvFZl8AAAAAAAAAgDbA1Ms6hf3mN7/56KOP+vTp09CAdu3aLV269O9//7vFYmn+zYVCoSeffDJSmUhOTh4+fHj//v3D3WAw+MADD6xevbr5NxTx3nvvffTRRy14QgAAAAAAAAAAzMzsMyfChg0btnXr1l27dq1atWrz5s07d+70+/2dO3cePHjwOeecM2jQIKu1xaosH3zwwcqVK8PtX/7ylyNGjAjXPLxe75w5c9544w1Jjz32WL9+/Tp27Nj8mysrK3v00Uebfx4AAAAAAAAAAOJFfBQnJFksll69evXq1atVbyUQCDzxxBPh9qxZs4YMGRL5ktPpvOmmmxwOx+LFiyU988wz99xzTzNvLhQKPfjggyzlBADA/2fv3gPkqOpE8Z+eZzKvJJDwSNYA4ZnEAIEQhUgiEEXERREvyo/rsrBqeAiKLihxV7M8vYgYRFweropwXZ8IqKBIuCJGAiSghrCaQIBAQiCPIcnMZHpmuvv3R2lnkpnpefRMdffk8/nrVPeprm9Xnalzar5dp4Diks6EprbQlAzbkqGiLBy45wA/59n1YdHzobYq1FaGmqpwymGhqnxQAwUAAEpVySQn4vHMM880NzeHECZNmtQ5M5F1zjnnPPDAA21tbU888cSWLVtGjRqVz+YeeOCBv/zlLyGEWbNmLV68OJ+PAgCAQfO5B8KTa/5WPmpC+NppA/yc5zeGe5bvWDz50HwDAwAAhosifebEpk2bFi1a9F//9V8/+MEP/vSnP8V2b8GiRYuiwhlnnNFthfLy8ve+971R+fHHH89nW6+//vptt90WQpg7d25PmwMAgAKor9pR3pYc+Oc0t+8olyVCtZ9GAQAAf1N0yYnGxsbTTjtt7Nixc+fO/djHPnbWWWcdeeSRY8aMueuuuzKZzJBuOpPJPPHEE1F58uTJPVU75phjokI+9zqkUqkFCxaEEBoaGs4///xBeZQ3AAAMjrrqHeWmtoF/TkundWurgjEvAADwd8WVnHj11VcPPPDAn//857u8vm3btn/6p3/60Ic+lE6nh27rTU1NHR0dUXmPPfboqdr48eOjwvLly3uq06sf/OAHa9euDSF88YtfrKqq6rU+AADEp75TciKfOydGVIS96kJddShLhBqDXgAAYIciurE6k8nMnTu3sbExWpw6dep73vOe5ubm++6777XXXgsh3HPPPd/97nfPO++8IQrgzTffjApjxowpK+sxbVNfXx8V0ul0R0dHRUW/9+GLL774wx/+MIRw2mmnHXLIIQMKFgAAhszxB4QJo0J9dair2ilR0V8fPTp89OgQQsiE0NYxWNEBAADDQBElJ5555pm//vWvIYQxY8b8/ve/nzJlSvT6N7/5zdtvv/38888PIVx00UXnnHNOeXn5UASwdevWqDBu3Lgc1SorK7Pl7du3Z3MVfdTe3h5N6DRu3Lh//ud/7m+Qnd16662vv/56jgrRszrS6XRTU1M+GypC7e075i8ell+wUFpaWkwylqfOz8jp6OjQOOmL1tbWtrY8Zk1huNvl4VvNzc3O1eQQ3QqcSqXy6oP+oSb8Q82OxcHqztp7r0JsOs+a29bWNtST6A570bk6k8kY/uWppaWl82JbW5td2pX2llvnE1qpXJSV1jHdpctobW3t/F+aYSB7IhrSGVyAUFTJiR/96EdR4Ze//GU2MxFCSCQS8+bNW7Zs2R133NHa2rpixYrDDz98KALYvn17VNhzzz1zVEskEmVlZdHpaQDJidtuuy26O+RLX/rSAO666OzRRx9dtWpVjgpHHHFECCGdTre2tuazoSKXyWSG9xeMUzKZx7wNdDHs//oYLDIT9ItzNX2RSqV2SWtBDhrMYDH8y98u3VwqlbJLe6K99UVpNaESPabt7e3DLDlRikcBSlQRPXPiD3/4Qwhh7Nixxx57bNd3P/3pT0eFZcuWDVEA2TFQrw+BqK7+273t/c2gLl++/KGHHgohnHXWWRMnTux/jAAAAAAAUPKKKDmxZs2aEMJb3/rWbt+dNGlSVHj++eeHKIC+z5CQrdmve5+3b99+9dVXhxAmTJhw5pln9jc8AAAAAAAYHopoWqeNGzeGEMaOHdvtuyNGjIgKr7766hAFkH2YRK/Ta2Tvsej8/IleffWrX41mjvrSl740KI/NeMtb3pL71o26uroQQiKRGKKndBRQOp3unBkafl8wftGN/GVlZeYxz1PnxhnNAlfYeChy/vToi0wm07nH1+uRW9QT6YPolUHL4Mqeq52l89R1B9qlXWlvfVdWVlYSe6m0jukuo9PhdzlTEkcBhociSk5EKYEcj2EoLy9PpVJDNzF3Q0NDVHjzzTdzVMtkMtn5WLPzO/Vq8eLFTz75ZAjhX/7lX/bZZ588wtzh+uuvz13hnnvuWbx4cXl5+ZgxYwZli8WjqakpOwPgsPyCMctkMps2bQohjBo1Sh+cpy1btmRn26ysrMyeWKBbmzZtymQydXV1vc4oyO4smUxu27Ytuzhq1Cj/QySHlpaWlpYWfRC92rx5czY5MWLEiNra2sLGU+paW1ubmppcm+Rvl0HRyJEj7dKutLfcOv+jvLKysiT2Umkd03Q6vXnz5uxibW1t3/8/VhKyJyKjbhhqpfQ3NtRnhFGjRkWFzmfYrjo/5KePJ98tW7bccMMNIYSDDjrotNNOyyNGAAAAAAAoeUV050TB1dfXR4U33ngjuhe+22rZny5WVFT08YeuTz31VHSzxfPPP//BD36wa4Xs3XBPPvnk6aefHpVvvfXWvffeuz/fAAAAAAAASkAp3Tkx1GpqampqakIImUxm69atPVVbt25dVDj88MMHsJVUdzo/PqHbFwEAAAAAYNhw58QOiUTiuOOOe/jhh0MIK1euPOaYY7qttmzZsqjQU4Wu9t577+OPPz5HhQ0bNvzlL38JIdTV1U2fPj16MfsMcAAAAAAAGE4kJ3aSTU7cc8893eYeUqnUL3/5y6jc9+TEtGnTpk2blqPCCy+8cOmll4YQpkyZctlll/UvaAAAAAAAKClFl5z4wx/+8O///u/dvhU9iTpHhchVV1014K1Pnz69uro6mUyuWLFi6dKlM2bM2KXC3XffnUwmQwhTp07da6+9BrwhAAAAAADYbRVdcmLNmjVXX311PhXySU6Ul5fPmzfv61//egjhyiuv/PSnP33CCSdET8Zub2+/66677r333qjmJz/5ya6r33LLLdGNFwcccMCNN9444DAAAKDAXm4Ma94MTcmwLRnKy8IZue4D7t4Ta8JtS0JNVaitDLVV4dPHhwbTlgIAAH9TdMmJgjvppJOWLFny5JNPhhAWLlx4++23T58+PZlMPv300+l0Oqozb968CRMmdF03epB1CCFbEwAAStL9z4Wf/Plv5T1rBpKc2NQSXti0Y/HTswcnMAAAYFgoouTEz372s0wmU+goQiKRmD9//ne/+93oJomWlpbFixd3rnDRRRedfPLJBYoOAABiUV+9o9zUNpBPaN55rZrKvOIBAACGlyJKTpx66qmFDuFvysrKzjvvvNNOO+3Xv/71smXLXnzxxYqKigMOOGDWrFknnnhifX19oQMEAIAhVle1o5zsCO2pUFnev09o6ZScqK4IFWWDExgAADAsFFFyotiMHTv27LPPPvvss/u+yiWXXHLJJZcMYFsHHnjg/fffP4AVAQBgSHS+c6KmMjS3hdEj+/cJB+wR3n1IaG4LzW0yEwAAwC4kJwAAgC5m7R/+++xQVxVqq0L5gFILsyeF2ZMGOywAAGCYkJwAAAC6qKsOddW9VwMYVCNHjrzqqquyi2PGjClgMJSo+fPnZ59p2tDQUNhgAMhBcgIAAAAoColEoqamJrtYWVlZwGAoUTU1NdnkRFVVVe7KABSQuV8BAAAAAIBYSU4AAAAAAACxkpwAAAAAAABiJTkBAAAAAADESnICAAAAAACIleQEAAAAAAAQK8kJAAAAAAAgVpITAAAAAABArCQnAAAAAACAWElOAAAAg609FZqSIZ0pdBwAAECRqih0AAAAQFFavj789oXQlAxNbaEpGb52WihL9HXdp14JVzwYQggjKkNtZfjG6WF8w9BFCgAAlBzJCQAAoDsvbQ4/+fOOxe3tobaqr+s2t/+t0NoeWttDVfkgxwYMU8lk8ic/+Ul2cfbs2VOmTClgPJSi++67r62tLSpPnz79bW97W2HjAaAnkhMAAEB36qp3WmxK9iM50dK202LfVwR2b6lU6vHHH88uHnbYYZIT9NdTTz3V0tISlffYYw/JCYCi5ZkTAABAd+p3Tk5sS/Zj3c7JiUQIIyoHJyQAAGC4cOcEAADQnYbqMLY21FeHuqpQXx0q+zM109smhvoRoaUtNLeF9lTo87MqAACA3YTkBAAA0J1DxoWf/tMA1520Z5i056BGAwAADCumdQIAAAAAAGIlOQEAAAAAAMRKcgIAAAAAAIiV5AQAAAAAABAryQkAAAAAACBWkhMAAAAAAECsJCcAAAAAAIBYSU4AAAAAAACxkpwAAAAAAABiJTkBAAAAAADESnICAAAAAACIVUWhAwAAAEpBOhMSiZDoQ803t4dn14faqlBTFWoqwz71obJ8yMMDAABKiuQEAADQg2fXh4WPhW3J0NQWmpPhe2eFiaN7X+v5TeELv9qx+F9nhoP2HLoYAQCAUiQ5AQAA9CCVDqs27lhsSvZprea2nRZrKgczJAAAYFjwzAkAAKAHddU7LTa19VBvZy07V6utGrR4AACA4UJyAgAA6EH9zsmJbX27c6KlfadFd04AAABdmNYJAADoQUN1OOmgUFcd6qtDXXVfHx1xymFh5ltCS3toaQvNbZ6GDQAAdCU5AQAA9GBEZfjiu/q9Vk1lqOnDc7MBAIDdmGmdAAAAAACAWElOAAAAAAAAsZKcAAAAAAAAYiU5AQAAAAAAxEpyAgAAAAAAiJXkBAAAAAAAECvJCQAAAAAAIFaSEwAAAAAAQKwqCh0AAAAAQAghVFRUnHDCCdnF8ePHFzAYStTs2bOTyWRUPvDAAwsbDAA5SE4AAAAARaGqqup973tfdrGurq6AwVCi3v3ud2cymahcU1NT2GAAyMG0TgAAAAAAQKzcOQEAAPQsE8L29tCUDNuSoSkZ9t8jjBqRq/7rTeEnfw41laG2KtRUhVn7hzEj44oVAAAoGZITAABAz159M/zv/96xeM17wjsOyFV//dbwoz/tWJz0QckJAACgK9M6AQAAPaur3mmxqa2X+i3tOy3WVg1yPAAAwLAgOQEAAPRsl+TEtmQv9Vt2zl7UVA5yPAAAwLAgOQEAAPSssiyM6DQZbFNvyYmQCHvWhBF/z0nUuHMCAADohmdOAAAAOV06O1SWh/rqUF8d9qnvpfJJB4WTDgohhFQ6bG+XnAAAALolOQEAAOT0nkMHslZ52a5TQgEAAPydaZ0AAAAAAIBYSU4AAAAAAACxkpwAAAAAAABi5ZkTAAAAQFFIp9ObN2/OLlZUVIwYMaKA8VCKNm/enMlkonImk6mpqSlsPAD0RHICAAAAKAqtra3XXHNNdvHcc8995zvfWbhwKEk33nhjS0tLVD711FPPPPPMwsYDQE9M6wQAAAAAAMRKcgIAAAAAAIiV5AQAAAAAABAryQkAAAAAACBWkhMAAAAAAECsJCcAAAAAAIBYVRQ6AAAAoLilM2HJmtCUDE1tYVsyzPiHMHXv7muu2xoWPBRqqkJtVaipDGcdGSbtGW+sAABAaZCcAAAAckokwhceDOnM3xYry3pMTmxpDX/dsGPx1MlDHhsAAFCaTOsEAADklAihrmrH4rZkjzVb2nZarK3qoR4AALC7k5wAAAB6U1e9o5wrOdG+06LkBAAA0APTOgEAAL2p/3tyorIsZDI9VtujJpx4UGhuCy1tobldcgIAAOiJ5AQAANCbq94TKspCXVWoznkFMXXvMPVdccUEAACUMMkJAACgN3vXFToCAABgWPHMCQAAAAAAIFaSEwAAAAAAQKwkJwAAAAAAgFhJTgAAAAAAALGSnAAAAAAAAGIlOQEAAAAAAMRKcgIAAAAAAIiV5AQAAAAAABAryQkAAAAAACBWkhMAAAAAAECsJCcAAIDBkM6E1o6QKXQYAABAKagodAAMoXQ6HULIZDKtra2FjmWQpVKpbHlYfsFCSSaTZWVylnmJ/u6yZY2T3DKZTAihra2tc8uBXXR0dHReTCaTiUSiUMFQ/KIGMxR9UMUP/pxYvy00tSWa2tIz/6Hjg1N3qZB4van6n34cyhKZkZWhtrL907PSR08Y3BgYRFEfFOno6DBoyVN7e3twbTIYkslk50WNs1vaW26dz2+pVKok9lJpHdPOeziE0N7evssrpS57FIbZ94IiJDkxnEX/wU+lUk1NTYWOZQil0+nh/QXj1NLSUugQhpWOjg6Nk74oiSsQikdzc3OhQ6AEDEUfNObhVeWvbI3K7aOrmpr226VCxcYt1SGEdCbR3Baa27Zv396uHywR7e3t0f/FyJNrk/xt376982J7e7td2hPtrS9K66KsRI/p8Lucyf5vRHIChprkxHAW/awykUhUVAy3A51Op7O/Mk4kEuXl5YWNZxiIfmU5/JpK/FKpVHb4onHSq+hPr7y83A/hyaFzrxecq+lN1GCGog/K1FZly2XN7V2bYkXbTjeBldePzGiuRcygZXBlz9XO0nnaZQcOy+vZ/GlvfVdWVlYSe6m0jmkmk+k8ocXwu5wpiaMAw4M/tuEsOpmWl5ePHj260LEMsqampmxmvqysbPh9wZhlMplNmzaFEOrr612X5mnLli3ZHx5WVlY2NDQUNh6K3KZNmzKZTG1tbVVVVe+12V0lk8lt27ZlFxsaGkzBRw4tLS0tLS1D0geNqQ1hY1SsTGa6GYAltnZeqttrTDBIK2KbN2/OJidGjBhRW1tb2HhKXWtra1NT07C8+IpZZWVl58URI0bYpV1pb7l1/kd5ZWVlSeyl0jqm6XR68+bN2cWamprq6uoCxjPosicio24YapITAABAH+xdH/5hVKirDnVV4eCx3VQ4YEz4zOzQ3Baa20JLe9ijJvYQAQCAkiE5AQAA9MGlx/dSYe/68P5dn5IN0F/DbH4Y4pdIJLQigJIgOQEAAAAUhZqamhtuuCG7WFdXV8BgKFFXXXVVdtq6mhq38QEUL1OnAQAAAAAAsZKcAAAAAAAAYiU5AQAAAAAAxEpyAgAAAAAAiJXkBAAAAAAAECvJCQAAAAAAIFaSEwAAAAAAQKwkJwAAAAAAgFhJTgAAAAAAALGSnAAAAAAAAGJVUegAAACAUpMJoSMdKjv91KkjHZa9GmqqQk1lqK0KY0aGatcaAABAj1wwAAAAffO1x8KyV8O2ZGhKhqMmhK+8b8dbW1vD5b/csfiFk8K7D4k/QAAAoFRITgAAAH2zuSW88ubfyk1tO73VvPNibVVMIQHDSzKZ/O53v5tdfNe73nXEEUcULhxK0ve///1kMhmVZ86cOXv27MLGA0BPJCcAAIC+qa/eUd6W3OmtlvadFiUngAFJpVLLly/PLs6YMaOAwVCinnvuuZaWlqg8ceLEwgYDQA4eiA0AAPRNXaeUQ9POyYld7pyoqYwjHgAAoGS5cwIAAOibqfuEU9tCfXWoqwqjR+701pS9w50fCS1tobktNLeFCaMKFCIAAFAaJCcAAIC+mTMpzJnU/VsjKsL+Y+KNBgAAKGGmdQIAAAAAAGIlOQEAAAAAAMRKcgIAAAAAAIiV5AQAAAAAABAryQkAAAAAACBWkhMAAAAAAECsJCcAAAAAAIBYSU4AAAAAAACxkpwAAAAAAABiJTkBAAAAAADESnICAAAAAACIVUWhAwAAAEpHeypsS4amtrAtGdLpMG3fEEJIZ8IdT4SaylBbFWqqwrR9woRRhQ4UAAAoapITAABAn93yh/CzZ/9W3rs+/Oh/hxBCS1v4/jM76lz+TskJAAAgN9M6AQAAfVZXvaPclPxbobl9pzo1VfHFAwAAlCbJCQAAoM/qOyUnmttCOhNCCC1tO9WprYw1JAAAoARJTgAAAH1Wt/NdEc1tIYTQlgoNI0LF3y8u3DkBAAD0xjMnAACAPjtyfPjCSaGuKtRXh7rqUFMZQgiHjgs/PzeEENpTobkt1Fbn/gwAAADJCQAAoM8mjMr1sOvK8jB6ZIzRAAAApcq0TgAAAAAAQKwkJwAAAAAAgFhJTgAAAAAAALGSnAAAAAAAAGIlOQEAAAAAAMRKcgIAAAAAAIiV5AQAAAAAABAryQkAAAAAACBWFYUOAAAAACCEECorK0877bTs4n777VfAYChRp5xySnt7e1Q+9NBDCxsMADlITgAAAABFobKycs6cOdnFurq6AgZDiZo1a1Ymk4nKNTU1hQ0GgBxM6wQAAAAAAMTKnRMAAEB/rNsa/vJGaGoL25KhpS187G3h4p+F6opQWxVqqsLcg8OMfyh0iAAAQLGTnAAAAPpjyZpw02M7Fj98ZFi+fsfioeMkJwAAgF6Z1gkAAOiPuqqdFl/fttNi7c7vAgAAdEdyAgAA6I/66p0Wd0lOjKyMMxYAAKBEmdYJAADoj7q/JyfKEqGuKqQzYfak0NwWWtpCS3sYPbKgwQEAAKVBcgIAAOiPQ8eFH3001FWFkZWhLBFCCLMnFTomAACgxEhOAAAA/VFVHvauK3QQAABAafPMCQAAAAAAIFaSEwAAAAAAQKwkJwAAAAAAgFh55gQAAABQFNLp9Msvv5xdnDhx4ogRIwoYD6VozZo16XQ6Ku+77741NTWFjQeAnkhOAAAAAEWhtbX161//enbx3HPPfec731m4cChJt99+e0tLS1Q+9dRTzzzzzMLGA0BPTOsEAAAAAADESnICAAAAAACIleQEAAAAAAAQK8kJAAAAAAAgVpITAAAAAABArCQnAACAPHSkCx0BAABQeioKHQAAAFBqXtwc7l0RtiVDUzI8sSaEEEaPDDWV4SNHhvdPLXRwAABACZCcAAAA+mlzS7j32Z1eeXN7eHN7aO0oUEAAAECJMa0TAADQT3XV3b9eWxlvHAAAQKmSnAAAAPqpvofkRE1VvHEAAAClyrROAABAP9VXh73rQ311SISwamM45i3hoD1Dc1uYOLrQkQEAAKVBcgIAAOin+urwo/9d6CAAAIASZlonAAAAAAAgVpITAAAAAABArCQnAAAAAACAWElOAAAAAAAAsZKcAAAAAAAAYiU5AQAAAAAAxEpyAgAAAAAAiJXkBAAAAAAAECvJCQAAAAAAIFaSEwAAAAAAQKwkJwAAAAAAgFhVFDoAAACgZC1/LZSXhaqKUF8VRo8M1a4vAACAPnHx0KMNGzYsWrToySeffPXVV8vLyydPnvy2t73t+OOPr6mpyfOTM5nM888//9hjjz333HOvvPJKOp2eMGHC1KlT58yZc/DBBycSiUGJHwAAhtBrW8MVD4YXN+945f+bHua9vXABAQAApURyohuZTObOO++85557Or+4dOnSpUuX/ud//uf8+fNnzpw54A9/4403rr322tWrV3d+cfXq1atXr/75z3++//77/9u//dtee+014M8HAIA4VJbvlJkIIdRWFSgUAACg9HjmxK4ymczNN9+czUyMHDly5syZU6dOjRbT6fTVV1/929/+dmAfvnbt2k984hPZzERDQ8OMGTNmzJhRV1cXvfLSSy/Nmzdv7dq1eX0HAAAYanXVu75SU1mIOAAAgJLkzoldLVmy5OGHH47Kn/vc54477rhonqVkMvmd73zngQceCCHceOONU6ZM6e/9De3t7fPnz0+n0yGE8ePHX3HFFfvtt1/0ViaTWbVq1XUOEHohAAAgAElEQVTXXbdp06ZUKjV//vxvfetblZWu7gAAKFZdHy9R484JAACgr9w5sZNUKvX1r389Ki9YsGDWrFnZJ0BUV1eff/75H/jAB6LFO+64o78f/thjjzU2NoYQ9txzz5tuuimbmQghJBKJQw455Bvf+MbIkSNDCI2NjY8++mie3wUAAIZQIoR/nBKOHB+OmhCO/odw5hHhiH0LHRMAAFAy3Dmxk2eeeaa5uTmEMGnSpKOOOqprhXPOOeeBBx5oa2t74okntmzZMmrUqL5/+I9//OOocPHFF1dXd7kLPoTa2toLLrjgxhtvDCH84he/mDt37kC+AwAAxONf5xQ6AmAYqq+vz5bNKMAA1NXVlZeXR+Vu//0CQJGQnNjJokWLosIZZ5zRbYXy8vL3vve99957bwjh8ccff8973tPHT25tbc0+SeKtb31rT9UOP/zwqLB69epMJpO9bwMAAACGvZqamgULFmQXsw9ohL77/Oc/n8lkonJNTU1hgwEgB9M67ZDJZJ544omoPHny5J6qHXPMMVFh8eLF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w5QpU+bMmXPUUUeVl5cP6aZDCBs2bFi0aNGTTz756quvlpeXT548+W1ve9vxxx9fU1PT301TEmJrnJlM5vnnn3/ssceee+65V155JZ1OT5gwYerUqXPmzDn44IMTiUSOdR9++OFbbrml1+9y/fXXH3zwwb1WA4ZabCeW/E8Oej0oIUN6bnnttdcuvPDCfsXz5S9/+dBDD93lRYOW3VB/L7jyHFHneamo4ysS+VwchfyOYz7rptPpP/3pT48++uhzzz23efPmUaNGzZgxY+bMmUceeeQA/lkRgwLu566R9OtEMbBVgBIlOcGQW7Ro0cqVK0MImUwmd83Gxsarrrrq+eefz76ycePG3/3ud7/73e/q6+s///nPT5s2bYg2nclk7rzzznvuuafzi0uXLl26dOl//ud/zp8/f+bMmf3aNCUhnsb5xhtvXHvttatXr+784urVq1evXv3zn/98//33/7d/+7e99tqrp9WXL1+eSqX6+pWAQout18vn5KDXg5IzpOeWTCbT3/NJt2EYtOyG+t4yQ34dX56dpo6veORzcZTPccyzDbzyyisLFizYsGFD9pUNGzY8+OCDDz74YH19/Re/+MWu+drCKtR+7la/ThQDXgUoUaZ1YmitXbv261//el9qrlu37uMf/3h2uFldXX3UUUcdddRRVVVVIYRt27Z94Qtf+PWvfz0Um85kMjfffHO26x05cuTMmTOnTp0aLabT6auvvvq3v/1t3zdNSYinca5du/YTn/hEdlDY0NAwY8aMGTNm1NXVRa+89NJL8+bNW7t2bU9bf/rpp/v+pYDCirPXG/DJQa8HJaeAI+qejBkzpuuLBi27m763zJBf48yzYev4ikc+F0f5HMc828DLL7980UUXZTMT48ePP/bYYw877LBocdu2bZdddtmyZcv6uBNiUKj93FMwfT9RDHgVoHS5c4IhtGnTps9+9rN9qdne3v65z32ura0thFBeXv6v//qvxx13XHSbYTqdfuSRR6Ke6ZZbbpk4ceLkyZMHcdMhhCVLljz88MNR+XOf+1x208lk8jvf+c4DDzwQQrjxxhunTJmS4+ftlJZ4Gmd7e/v8+fPT6XQIYfz48VdcccV+++0XvZXJZFatWnXddddt2rQplUrNnz//W9/6VmVl5S5bb21t3bJlSwihtrb2+9//fq/33gIFFGevl8/JQa8HpSWG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+9///tFHH12+fHk6nT7kkENmz549Z86c6H7JF198Mao5atSoQdli9nM2b96co1p7e3u2rPfdPQ1K43z55Zcvv/zy6DljNTU1CxcuzD7iLx8TJkxYu3ZtCKGpqSn/TwNiM9S9XteTg14PdgeDcm755S9/GRVOO+20QYzNoGU3l0/jHNi6Or5i1veLo3yOYwxtoLKy8rOf/exnP/vZEML//M//NDc3dztnb6HEs58BBkxyguJSVVV14oknnnjiiV3fSqVS0YObEonEYE3rFA1kQwhvvPFGJpPpaY7F7AOvKioqen02FMNVno1zyZIl1157bVTed999r7/++l7/25hKpdra2jo6OrINtVvZm2pHjBjR67cAisrATiwDPjno9WA3keegpbGx8fXXX4/K06dP78sWDVroo3wa5wDW1fEVrX5dHOVzHONpAwceeGC2vGHDhuJJTsS2nwEGzLROlIxXX301KkyfPr3vT2rKraamJhq8ZjKZ7I3AXUUj3RDC4YcfPijbZZjptXH+6le/yg4Kp02bdvPNN/eamfjjH/94+umnf/jDH77gggty13z++eejwr777tu/uIEi1tOJJZ+Tg14P6MuIesWKFVHhkEMO6ctPggxaGBT5XO71tK6Orzj19+Ion+MYTxsoKysrLy+Pyp1vLCisOPczwIBJTlAUbrnlliuuuOKcc87J8eSl3/zmN1Hh2GOPHaztJhKJ4447LipHMzB2a9myZVHhmGOOGaxNUyryb5w//elPv/nNb0blk08++aqrrurLD0ze8pa3RIWtW7fmmPSzsbExegxg51WAIpfPiSWfk4NeD4a3wRpRL126NCrMmTOnL9s1aKFX+TTOfNbV8RWhAVwc5XMc82wDb7zxxre+9a0vfOEL/+f//J8cESaTyexjGAbrOT15ink/AwyY5ARFYdOmTStWrGhsbOypC9y+ffsvfvGLqDyIyYkQQrb3veeee7qtkEqlsrPu6n13Q3k2zkceeeTOO++MymedddZFF11UVtanE+8ee+xRV1cXlR9++OGeqv3sZz+LCpMnTy6e24eB3PI5seR5ctDrwTA2WCPqJUuWRIWpU6f2ZbsGLfQqn8aZZ8PW8RWVAV8c5XMc82wD999///LlyxcvXpydzqirp556KipUV1fvscceOb5IPAqynwEGRnKCopCdOfS73/1uJpPZ5d10Ov3Vr341nU6HEE455ZSGhoZB3PT06dOjhzitWLEi+zOxzu6+++5oetypU6futddeg7hpSkI+jXP9+vULFy6MymedddZZZ53V9+0mEomzzz47Kt91110bN27sWuevf/3rvffeG5U/8YlP9P3DgcLK58SS58lBrwfD2KCMqFtbW1taWqJyTw9N3YVBC73Kp3Hm2bB1fMUjn4ujfI5jPuuOGzcu+8o3v/nNri0whNDY2HjTTTdF5Y985CN9TAMMnULtZ4CBkZygKLz97W+PJjdcuXLlN7/5zc537DY2Nn7pS1968sknQwi1tbX//M//PLibLi8vnzdvXlS+8sorH3nkkeyAo729/dvf/vZPf/rTaPGTn/zk4G6akjDgxpnJZG644YaoPH369I985CP93fTJJ588bty46KM+9alPdf6xWCqVeuihhy677LJo8cQTT+z8EDagyOXZ6+VzctDrwTA2KCPqTZs2RYWKioqRI0f2cdMGLeSWT+PMs2Hr+IpEnhdH+RzHfNZNJBKf+tSnovLixYsXLlzY1NTU+UstW7bsggsuiP5fv88++7z//e/v1/cadAXczwADk+g28QuD6Gtf+9r/+3//L4Rw3XXX5bg3/Lnnnvv85z8flcvKyo488siGhoa//vWvr732WvRiRUXFTTfd1K8Javu46Uwmc80110SD2hBCTU3N9OnTk8nk008/Hf0GJ4Qwb968U089te+bpiQMaeNcsWLFFVdcEZUTiURffkHzwx/+cJeZQNevX3/hhRd2dHREi2PHjp0yZUpTU9Of/xan8DYAAA/USURBVPzn7ItHHHHEggULsk9gAwornl4vn5ODXg9KUWwj6qVLl1555ZUhhKlTp1533XV9j9CgZffUx5YZ8muceTZsHV8xyP/iKJ/jmGcb+NGPfnT33XdnFydNmrTffvtt27bt2WefbW1tjV5saGi4+eabC/7AicLu5570/USRzypAiSpfsGBBoWNgmFuyZMlLL70UQpg7d26O+/7GjRt32GGHPf7446lUKpPJvPbaay+99FL2VwlvectbbrjhhvHjxw/FphOJxDve8Y7W1ta//OUvIYT29vZXXnll3bp12dTdRRdddMopp/Rr05SEIW2cP/jBD1avXp1dzPTBmWeeucvlel1d3dy5c1esWLF58+YQQktLy8svv/zaa69lx4Vnnnnmpz71qYLfOwxkxdPr5XNy0OtBKYptRP3UU08988wzIYS3v/3tRx99dN8jNGjZPfWxZYb8GmeeDVvHVwzyvzjK5zjm2QamTp06ceLEp59+Okq1NjY2vvTSS+vWrctmXmfPnn3llVcO7gTUA1PY/dyTvp8o8lkFKFEVhQ4Adpg+ffpdd931+9///tFHH121alVra+v48eOnTZt2wgknHHrooYlEYug2XVZWdt5555122mm//vWvly1b9uKLL1ZUVBxwwAGzZs068cQT6+vrh27TlIQBNM5Vq1YNyqb33HPPr371q6tWrVq0aNHy5cvXrVtXXV09efLko48++p3vfKfGCaUrz14vn5ODXg+GsTzPLdknvo4dO7a/mzZoIbd8GmeeDVvHV3CDcnGUz3HMsw3MmjVr5syZTz/99O9+97u//vWvGzZsGDly5MEHH3zEEUfMnj27eP57XvD9DNBfpnUCAAAAAABi5aZaAAAAAAAgVpITAAAAAABArCQnAAAAAACAWElOAAAAAAAAsZKcAAAAAAAAYiU5AQAAAAAAxEpyAgAAAAAAiJXkBAAAAAAAECvJCQAAAAAAIFaSEwAAAAAAQKwkJwAAAAAAgFhJTgAAAAAAALGSnAAAAPj/27v3IB3L/w/gj2XXsmEnEe2mzanUyLkI035rDCWnScM0ZpRpmkVMNGGGRkYMoqYZh2Rsmk3NyDCk7JioiMhUO4zDEDnsRjIOo9VmD8/vj6ff/XtmsdZ3ufnxev11fe7nuj/3tf57vJ/7ugAAgFAJJwAAAAAAgFAJJwAAAAAAgFAJJwAAAAAAgFAJJwAAAAAAgFAJJwAAuL3k5OQkxZkyZcp/12fatGnxffbt23dt1wkAAHALqxaNRm/0GgAAIDzRaLRHjx7r168PruTl5bVp0+aqmuzYsSP+lnfffXfMmDHXbIkAAAC3OuEEAAC3nVOnTqWlpRUVFcXKxo0bHzx4MDk5uZK3FxUVNW3a9NixY7Gya9euGzduTEjwUjIAAEBl+QYFAMBt584771y2bFlQHjt2bOTIkZW/ffjw4UEykZycvGrVKskEAADAVfElCgCA21GfPn2ef/75oMzOzv76668rc+O6deuWLFkSlCtWrKhfv/41Xx4AAMCtzbZOAADcpgoLC++9997Tp0/HypSUlIKCgnr16lVwy5kzZ9LS0s6fPx8rhw0btnjx4uu+UAAAgFuONycAALhNpaSkrF69OigLCwsHDx5cwW93otHowIEDg2QiPT19/vz5132VAAAAtyLhBAAAt69u3bqNGDEiKHNzc5cuXXq5ydnZ2evXrw/KdevW1axZ8/quDwAA4BZlWycAAG5rFy5caNasWX5+fqxMSEjIz89v3LhxuWlHjhy57777gnLOnDljx44Nb5UAAAC3Fm9OAABwW0tKSlq7dm1QlpWV9enTp6ysLH5OaWnpM888E5SPP/74a6+9VnHbAwcOzJ49u3///o0bN65Vq9bdd9/97LPPTp8+fc+ePVf186CioqINGzZMnDixV69e6enptWrVqlu3bosWLQYNGjRz5sy8vLyKu5WUlCT9r1WrVkUikeLi4oULF3bu3LlWrVrNmjUbPXr0li1byv29AAAA15s3JwAAIDJlypS33norKBcsWJCVlRWUM2fOnDBhQmycnJycn59fv379y7XavXv34MGDd+7cebkJzZs3X7ZsWbt27SpeUlFR0bRp06ZPn15xctC0adPPP/+8ffv2l/y0pKQkMTExNl65cmWPHj06duy4d+/ectO+//77rl27VrweAACAa0g4AQAAkdLS0kceeWT37t3BlYKCgnvuuScSiezfv79ly5bB9S+//DL+LYp40Wh0+vTpkyZNqswTJ0yYMH369GrVql3y04KCgo4dOx4/fryS61+xYsWAAQMuvh4fTixcuHDBggV5eXnl5jRp0uTQoUOXWwkAAMD1IJwAAIBIJBI5fPhwRkZGUGZmZm7YsCEajbZu3ToILV566aXs7OzLdRg3btw777wTlO3atRs1alTbtm1TU1MLCwt37do1b968TZs2BRNGjx79/vvvX9ynsLAwIyPj5MmTsbJ27dpvvPHGk08+2ahRo6SkpHPnzh08eHD58uWffPJJcEtiYuLZs2dr1apVrlV8OJGUlHThwoVIJPLCCy+MHDmyUaNG+/btW7x48XPPPTd48OBK/RsBAABcI8IJAAD41/z580eOHBmUa9asOXTo0Kuvvhor09LSDhw4ULNmzUve+91332VmZsbGtWvXXrNmzX/+85+Lp/3444+9evU6ffp0rNy4cWP37t3LzRk/fvysWbNi4y5duqxfv/7i1CESiRw/frxTp07BUd45OTlDhgwpNyc+nIhZtGjRyy+/fMk/AQAAIDTCCQAA+Fc0Gu3evfvmzZtjZZ06dQoLC4MjH3bt2vXQQw9d8sbi4uL09PQTJ05EIpGEhIS9e/e2aNHick8pKCi47777SktLI5FIw4YNf//99+rVqwefFhUVpaSkxB5avXr1kydPpqamXq5VfCIybNiwxYsXl5tQLpyIvQ5iBycAAOCGS7jRCwAAgJtFtWrVVq5cGfxv/rlz54JkYvbs2ZdLJiKRyDfffBNLJiKRyMyZMytIJiKRSFpa2rRp02LjEydObN++Pf7TTZs2BQ8dP358BclEJBJp27ZtMP7jjz8qmBkzbtw4yQQAAHAzEE4AAMD/adCgQfxZDjFdunQZM2ZMBXfNnTs3GA8dOvSKT4k/46HcIRYNGzacNGlSv3790tPTL96mqZykpKRgHGwVVYH27dtfcQ4AAEAIbOsEAADl9evXb/Xq1bFxUlJSQUHBXXfddbnJ0Wg0IeHfH/0kJCQcOXIkKC+nsLAweLuiRYsW+/btu6rlnT17dt++fVu3bs3Ozs7Ly4tdfPTRR7dt21ZuZrltnYqLi2vUqHFVzwIAALgefDMBAIDysrKygnAiMzOzgmQiEomcOXMmGJeVlaWnp1/Vs/bv319aWhp/7ES8srKyEydOHD58+Ndff92zZ09eXt7mzZvjn1h5DRs2lEwAAAA3CV9OAACgvPiDGa54SENlDnuoWOwQ7HIXDxw4MGvWrI8++qi4uLiK/WMaNGhwTfoAAABUnXACAACqpKioqIodghOwY4qLi7OyssqdRVHO/fff379//65duw4cOLCST4nf3wkAAODGEk4AAECVxO/INGDAgBUrVlSlW1lZWd++fXNzc+MvJicnZ2ZmdujQoXXr1q1atWrevHnt2rUjkchff/1VlWcBAADcKMIJAACokvr16wfj7du3V7HbvHnz4pOJSZMmDR8+vHHjxpfcXaqkpKSKjwMAALghhBMAAFAlDRs2DMb5+fmFhYUXHyBRSWVlZRMmTAjKzz77bPDgwRXMjz/uotzeUAAAADezhBu9AAAA+P+tRo0arVu3Dsp169Zd8ZYjR45kZGT07dt3/PjxOTk5wfWjR4+eP38+Nq5Tp86gQYMq7rNz585gXFpaenXrBgAAuHGEEwAAUFWvv/56/PiKuy1Nnjz58OHDX3zxxaxZs+J3gjp58mQwbtmy5SW3cgpEo9EZM2YE5d9//33V6wYAALhBhBMAAFBVAwYMSExMjI1/++23iRMnVjB5y5YtS5YsCcqxY8cG49TU1GCcl5f3zz//VNBn6tSpP/30U1CeO3fuKlcNAABwwwgnAACgqurWrfvBBx8E5axZs0aMGHHhwoWLZ27bti0zMzMos7KyMjIygrJJkyZByFFaWjp69OhoNHpxk/Pnz7/yyiuTJ0+Ov3jmzJkq/Q0AAAAhEk4AAMA18OKLL/bu3TsoFyxY0KBBgxkzZmzfvj0/P//AgQNr167t3bt3586di4uLY3MeeOCB9957L75JYmLim2++GZQffvhhmzZtli1btnfv3oKCgv3793/11VejRo1KTU1dtGhRJBJJSEioW7dubHJhYeElkwwAAICbUDVfYAAAoJzc3Nynn346Nu7Zs2dubm5l7iopKRk6dOinn35amckPPvjg1q1b69Wrd3GTTp065eXlXbHDww8/vGbNmjlz5sydOzd25ezZs0FWEXQLXsVo27btL7/8Upm1AQAAXG/enAAAgGujRo0aS5cu/fbbb9PS0iqYVr169WnTpu3YsePiZCLW5IcffhgyZEgFHWrXrv3xxx/v2LEjIyPjqaeeCq5v3rz5v148AABAmGrc6AUAAMAt5Yknnjh69OiePXtWrVq1bdu2bdu2/fnnn4mJia1aterQoUP//v0zMzNTUlIq6JCcnJyTk/P2228vX7583bp1P//886lTp+64444OHTo89thjPXv27Nq1a/A+RLdu3YIbp06dGrzwAQAAcDOzrRMAAAAAABAq2zoBAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAAChEk4AAAAAAACh+h8NEX6hxrXM6QAAAABJRU5ErkJggg==" /><!-- --></p>
<ul>
<li><p>The plot above illustrates that there has always been variation in popular girl names over time in the entirety of the US. Boy names tend to have larger persistence, as can be seen by the more stable line which often lies above the line representing the persistence of girl names.</p></li>
<li><p>When investigating the companies suspicion of a drop off in name persistence after the 1990s, its evident that there is still much variation in girl names, but that has been seen throughout time. However, we see several plunges in the persistence of boy names after 1990, with a large continuing drop occurring since 2003. This is specific to the modern era, as before the 1990s, boy name persistence was relatively large and stable.</p></li>
<li><p>In New York, boy names tend to have an even higher persistence compared to the whole country, while girl names have even more variation. In New York, we only see a large plunge in the persistence of boy names after 2003.</p></li>
<li><p>These findings indicate that in the modern era, name persistence for either gender is lowering, as naming trends become more transitory. Thus, it is perhaps an unwise strategy for the agency to target product creation around current popular names, as by the time those products are actually on shelves, naming conventions are likely to have already changed.</p></li>
</ul>
</div>
<div id="influence-of-popular-figures-on-naming-conventions" class="section level1 unnumbered">
<h1>Influence of Popular Figures on Naming Conventions</h1>
<ul>
<li><p>To analyse the influence of celebrities on pop culture, I created lists of the most famous: musicians, actors, and characters per decade.</p></li>
<li><p>I created a popularity score for musicians based on their songs’ peak rankings on the Billboard chart, as well as the total number of weeks in a decade they had a song on the chart. The table of the most popular musician/band per decade as well as their popularity score can be found below.</p></li>
</ul>
<p><img role="img" src="data:image/png;base64,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" width="225" height="250" style="display: block; margin: auto;" /></p>
<ul>
<li><p>To find find some of the most popular actors and characters per decade, I found the most popular movie of each decade via their tmdb scores, and extracted the main cast from these movies.</p></li>
<li><p>From these lists I hand selected a list of some of the most famous celebrities over time: Charlie Chaplin, the Dorothy character from The Wizard of Oz, Elvis Presley, John Lennon(The Beatles), Paul McCartney(The Beatles), and Mariah Carey.</p></li>
<li><p>The figure below plots the popularity of these names over time, and marks the decade in which the respective celebrity was most famous.</p></li>
</ul>
<p><img role="img" src="data:image/png;base64,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FRsbu2/fPhe7DuzghNcPl2Nwory8vG/fvu4UHhUVdebMGXeOW5N4sY0BFpwwm82PP/64+y2yUavV27dvd1Gs4wOpgoICd56WJiUl2Tuzm5ukpqbKHmM58nonF30fnDAajWPHjnW/zjqd7n//+587dXCH0+CEKIpvvPGGbL9ff/11o6U1KTjRRvqkKIoWi0X2WNy1nj17nj9/3nWZ/u02srG/rrvuOm+VLIpiamqqtPAPPvhA+quvby18cbJkwQmTyTRs2LCGCnz//ffdbJH7/BKcCMjrDgAABACGdQKAtmLgwIHSoX5ef/11Nx/BHzp0qKyszJ6cO3eu02znzp3r3Lnz1q1b3a9SUVHR4MGDV69e7f4mipl2QZ8+faTrr7rqqmkSer2+eeUrcLhqamr69et3+PBhdzKXlZX179/fu5OdereNKSkp9sM+cuRI6U9du3addjGtVutp7X3JYrHceOONsmFY3GG1WseMGeP4lnRDysrKLrnkkvT09EZz5ubmjh49WhTFsrKySy+91J1Nzp8/P23aNBcZWuP/E6xW6+TJkz///HP3NzGZTKNHj/766699VilBEIRZs2b169dPuuaWW27x4gBBbaRPCoJgNpvHjx//7LPPullhQRCOHz/etWvXI0eONJTB791m27Zt0mSTwiSNuuuuu6TJr776Spr06a2FL06WjMViefjhh3fv3u30V51ON3XqVPf33mIF5HUHAAAChJ+DIwAAURQV+XJCFMXFixdL97J37153tpo1a5Z0K9m3AjYlJSUxMTGyPzH9+/f/7LPP8vPzLRaL1Wqtqqo6cODA/fff7/jH6LPPPnO6a399OeGi8GPHjrko080vJ3x0uKRvSur1+uuvv96eDA0Nffrpp7/66qtTp06dPHlyx44dstNq8/jjj7tz6Nzhozba5OXlSTO/+uqr3qq2Ml9OOE54MGLEiO3bt+fl5dXX11utVqvVWltbe/bs2ffeey8pKckxc0Mly76ekc5V0KlTp//85z8HDhxIT08/ePDgv//979jYWFnJmzZtkj4BHzp06Jo1a3799dczZ858//33jz/+uFotf6+locvNdx3Ap9f7+++/L80WFBS0ZMmSEydOVFdX2+pcX1+fnp6+ePFi2VBpoaGh7oxJ1aiGvpwQRfHs2bOyo/TAAw+4Ls39LyfaQp8URdFqtcqOiSAIaWlp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yWSaP3++dM3s2bMbHVrH81sLv58seAunEgAANIrgBAC0XYMHD46KirInP/74Y0EQLBbLO++8Y1/55JNPun4SMWbMGGly+/bt7legqKhIOupLaGiotD7uk0266+ZTnn379jVjXx5qCYfL19pCG5tt9erV0uSbb77ZtWtXdzaUvQjf1M8RlOTrDuCj691sNu/fv//DDz+cM2fONddc89///rfRMkNCQlasWNGzZ0/pyqYGY7zCYDBs2rRJuub48ePSIXRcaAt9UhCEq666Sppct26d+9taLJYuXbqMHj169uzZy5cv37Fjhz0S03K6zX333SdNpqenr1q1ysMy33zzTVkIShZWccrzWwsfnSwoj1MJAAAaRXACANoutVo9e/Zse/Jf//qXIAg///yzdEJa6fgMTsnm4Vy0aJH7j6jee+89afLee+91c0OZyMhIaTIjI6PRTURRlO29IbIHKB7+27glHC5fawttbLYvv/xSmpQ9x3dBNriK8jOmuM/XHcBH13tNTc2gQYOmT5++ZMmSb7/91s0HuyqV6o477pCukU3orZihQ4fOmDFDuubJJ5/89ttvG92wLfRJQRCGDBkiTS5fvtzNb24EQfj000/T09O/+OKLZcuWzZw584knnrD/XWg53SY6Olr28cSMGTM8+WAoPT390Ucfla559NFHpYO2NcTzWwsfnSwoj1MJAAAaRXACANq0u+++276cmZmZn5//4Ycf2tdceeWVsmGsHXXv3j0tLc2ezMrK+uCDD9zZdVlZmWzKVndeyXRKNhL6ihUrGt1k586d7jzTFARBNnmjhw/gWsLh8rW20MZmq6mpkSb1er07W2VmZsqOYVVVlTer5VW+7gA+ut4jIiL69+8v3SQ/P7/RkgVBkGVLSEhwZytfeOONN2TPjmWvvTvVFvqkIAhhYWGTJk2yJ61Wq/QBugtGo1E2pceCBQvsyy2q2yxcuFD6yYLVah02bFh5eXkziiotLZVNfB0aGrpw4UI3N/fw1sJHJwvK41QCAIBGEZwAgDatQ4cO0nGft27dKh0Ves6cOY2WoFKpXnvtNemaGTNmNDqssNFoHDt2rPR96t69ew8YMMDdel+sffv20uTx48ddjyRz7ty5m2++2c3Cg4ODpcni4uKmVk+qJRwuX2sLbWy23r17S5M///xzo5tUV1ePGjVKtrKiosKb1fIqX3cA313vf/3rX6XJ++67r9Evpaqrq6WD1YSHhycnJ7uzL18IDg7euHFjU7dqC33S5vnnn5cm33777Y8++sj1JqIoPvTQQ7m5ufY14eHhN954ozRPy+k2ISEhtjGU7LKysvr27etmvMQuJyend+/e0plIBEHYuHFjeHi4myV4fmvho5MF5XEqAQCAawQnAKCte/rpp+3LjzzySGVlpW1ZrVa7Ob7H+PHjBw0aZE9arfB+Gi0AACAASURBVNa+ffvKHpFI5ebmDho06Mcff5Su/Pjjj5v9wb5Op7vtttuka8aNG/fDDz845hRFcdu2bd27d5e9LOxCM17Tds3vh0sBbaGNzTNhwgRp8v7773c9xkVGRka/fv2k0zDY2K/TlsmnHcB31/vUqVNDQ0Ptya1btz700ENms7mh/HV1dTfccIN0sJp58+bJ5utW2PDhwxsdi0+mjfRJQRB69uz54IMPStdMnjz5xRdfbOgUWyyW2bNnv/vuu9KVq1ev1ul00jUtqttce+21simss7KyOnTosGXLFnfGJBRF8eOPP+7YsaP0ubAgCDNnzrz++uubVBMPby18dLKgPE4lAABwjeAEALREO3bs+MQbfvnll0b3NW7cOPuy9JnU3XffHRQU5E5tVSrV9u3bpe9UWiyWSZMmXXHFFTt27CgpKbE9E6mrqzt69Ohjjz2Wmpr666+/Skt4++23e/To4c6+GjJ37lxp0mKxDBs2bNy4cdu2bUtPTz9//vzBgwdtE72OHTvW9lSoU6dOt9xyS6Mly4ITH3zwwQ033LBy5cpNmzZ98skn9fX1Ta1qSzhcvtYW2tg8M2fOlCazsrL69Omze/duq9UqXW+1Wo8dO/bQQw917txZNu2wTWFhoW8r6hlfdwAfXe9BQUHLly+XrnnrrbdSUlJWrlyZnZ1tH9LNaDRmZmYuX748OTn5u+++s2eOiYl55JFHXO9CAcuXL3f/DXehzfRJm9dff13Wr+bNm9epU6f33nsvOzvb9rTUarUWFhauXbs2LS3t1VdflWaeNGnSTTfdJCuzpXWbhQsXyia0MBqNEyZMuPzyy3ft2tXQyIRGo3HHjh0DBgyYNGmSLM/kyZP//e9/N7Uant9a+OJkwS84lQAAwBURANACyF519JYZM2a4s/dp06Y5brtv374mNeHMmTMRERHNqOTSpUsbKnPTpk3SnPv373dRgcmTJ7u/0/Dw8JycHOnYxwsWLHBarNls1mg0DZVz6NAhaeZDhw5Jf920aZOSh2vv3r3SnNu2bXNxuOxkjyBvuukmd7Zyhy/aaCMbb+TVV1/1Vp1lXW7mzJneKtlONq2CjV6vHzZs2J133nnbbbcNGTLEscs999xzsjfirVarY+HN6AO7du2SbvLtt982usl///tf6SZnz551ms13HUD02fUuimLzZjrR6XTHjx9vtNqNGj16tLTY4uLiZhTyv//9z2klCwsLneZvO31SFMWysrKuXbs2dj6duOqqq0wmU0PF+rfbyFgsFtnk2HYajWbMmDGLFi1atWrVRx99tHLlygULFowcObKhTzfuvfdes9ncvGp4fmvho5PVjA7mXbK56z/99NMmbe7OnUYbue4AAEAA4MsJAIDg+NpmTExMU4f779y5c0ZGxpVXXun+JuHh4d98881jjz3WpB01ZPXq1WPHjnUnZ0pKyrFjx5KSktzJrNFoFi1a1NCvjmObuMnvh0sBbaGNzbBw4ULpBKE2RqNx9+7dq1atWrNmzZ49e6RTL/To0ePQoUPPPvvsyJEjpZtkZ2crUV0P+LQD+Oh6FwTh3Xffvf/++93MbJOUlHTs2LGW863P9ddf79jHXGg7fVIQhMjIyCNHjshGBmvUvffe+9VXX2m12oYytKhuo1ar//nPf65evdox5GCxWLZv3z5v3rw777xz0qRJd99997PPPrtz505ZlNpmxYoVK1ascBGed83zWwsfnSwoj1MJAAAaQnACACBcfvnlshecn3jiiWYMgd2uXbvdu3d/+umnaWlprnOGh4e//PLLeXl5V199dVP30hCdTvfZZ5+tWbMmKirKRbbZs2efPn06JSXF/ZLnzJkza9Yspz8dOXKkabWU8O/hUkZbaGNTqdXq9evXN9pRBUFISkpas2bNb7/91rdvX0EQ/t//+3/SX5sx9bHyfNcBfHe9azSad95556effrr88ssbzRwSErJ06dLMzMwuXbq4vwsFvPfeeyEhIW5mblN9UhAEg8Hw4Ycf7t27153I2dChQ3/55ZcVK1a4fkLaArvN7bffnpOTM378+GZsO2HChJycnHvvvdeTCnjl1sIXJwt+wakEAABO8cceACBoNJrHH3/82Wefta+RjVjtPpVKNW7cuBtvvPHkyZM7duzYs2fPnj17cnJy6urqEhMT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AAAAAAAAAICpKE4AAAAAAAAAAABThVjdAdRfiqJMnTr18OHD8+fP7969+0U3PnDgwIYNG3766adz587FxMR079598ODBffr0cTgcdXdc1dmzZ9evX79169YTJ044HI5u3bpdeeWVAwcOjIyMrNGhg4Zp2SmKcujQoU2bNv38888ZGRlutzspKalHjx6DBw/u1KmTzWa7aFfJTq+m//iNZOd2u3/66ae0tLSff/45JyenWbNmV1xxRf/+/Xv16uXne5bs9MzMrqqioqIHH3ywqKiof//+M2bM8L0xwXkw7T/MdevWvfLKKxftz6JFizp16uT1IbLzYPKJitvt/s9//vP999/v2rUrOztbfYZhw4b16tXLbr/I7T5k56FOszt58uSkSZNq1J+FCxd26dLF60Nkp2fyh93hw4fT0tJ27dqVmZnpcDg6dOjQu3fvIUOGtGrVyp/ekp2emdkZzJ3grL3Csmrf4GAwuwC+gDV9y5MdAAvZFEWxug+op9atW7d8+XIRWbBgQY8ePXxs6XQ6n3766UOHDlV9qGnTpk8++WRqampdHFdEFEV56623/v73v1d9yG63z5w5s3///v4fOmiYk92ZM2eeffbZI0eOeH00JSVl9uzZPq4eya6qGv3jN5JdRkbG3Llzz54963Xfp556qrrvaFRkV5Vp2Xn1zDPPbN26VUT69+8/e/bs6jYjOK9M+7B74YUXvv7664v2Z8mSJVWLE2TnlZknKseOHZs9e3ZeXl7VhxISEp5++unqPu/Izqs6zS4rK2vChAk16s+iRYu6du3qsZLsqjLtwy4/P//ZZ5/du3ev10dHjBgxYcKEkJBqb7Mju6pMy87IvgQnll5hWbVv0DCSXcBfQP/f8mQHwHKOuXPnWt0H1EeZmZlPPfWU2h4+fLiPE6CsrKxJkyZp33KGh4f37NkzISEhOzvb5XKVlpZu2LChefPml156aWCPKyKKorz00ktr1qxRFyMiIvr06RMbG6t2RlGUjRs3JiQkpKSk+HPooGFOdpmZmRMnTszJyVEXY2JiUlNTExMT8/LySktLReT8+fNr1qwZOHBgTExM1d3Jrqoa/eM3kl16evojjzxSWFioLiYmJl522WXR0dHnzp0TkdLS0rVr13bu3DkxMdHrocmuKtOy8+rbb7/98MMP1XZSUtKgQYO8bkZwXpn5YbdixYqSkpKL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r2r37t1+PnPDZVp2TZs29WeKrdOnT6uNmJgY/d2mZOehFv/41Ybx951X2gves2dPj9uEyc6Dhdm9//776i1aTz31lI+rIO24BOfB5A+7kpKS7Oxs9Rnsdvv27ds3b968d+/enJycuLi41NTUYcOG9ejRo2qRieyqMjO7/Px8dRCDzp07e72/3vehyc6DVSeZert27dq5c6eIOByOBx54oLpDk52eyR92ycnJkZGRhYWF586d27JlS9Wbf//5z3+q5aWEhISWLVt6HJrs9MzMzuC+BGfhFZZV+wYNI9kF9gWs6ecs2QGoJyhO4FdDhw69//77Pe4/8k07udTfal2VfmSYvLw8j+vGWhxXRM6fP6824uLiPG7u1tOO5Xa7y8vL/T81b1isys63L7/8Um1cddVV+vVkp6ndP/46ze7cuXMvvfSS2h49erTHo2SnsTa7o0ePfvDBByJy8803e73t1wPB6VnyH+aZM2fURn5+/pgxY4qLi7WHTp8+ffr06XXr1rVv337u3Ln6OeqF7CozPzu1pCQil1xyibZm06ZN33333bFjxyIiIlJTU6+77rqePXtWTYfs9OrJiYrb7dYmMB83blxkZKTXzchOY8mHncPhmDVr1qxZs0RkwYIF995778iRI6Ojo0UkNzf3k08++eyzz0TEZrPNnj3bo6ZLdhrzszOyL8H5ry6usKzat7Hxml2gXsBavOXJDkD9wf8sEBFxOByPP/54TffSfnb9888/K4pS3bgiZ8+e1draUKRGjisieXl5asPjhikP+vsci4qKavTdekNhVXa+nTp1SptO+YYbbtA/RHaqWv/jr4vs3G53Tk7Ohg0b3n33XfUn9sOGDevdu7fHZmSnsja7srIydUCnli1b3nffff4cl+A0Vv2HefjwYbXhdDrVRps2bTp06FBQULBv3z71trXjx4+PGzdu+fLl7dq103YkO40l2eXk5KiNtm3bKoqyatUqbcZLESkuLt64cePGjRuTkpLmzZvnkRHZaerPicp3332nbh8VFaVNY14V2aks/LBLTU1dvnz5ggULTp48+fbbb7/99tse+6akpMycObPqKHlkp7IkOyP7Epyf6ugKy6p9G5XqsgvIC1i7tzzZAag/mHMCtaddEhQUFGjfvFS1du1ara2/XdSIoqIitREfH+9jM5vNpt0FoO0CqePstC9PRaR///7a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VCFWdwAAAAANybvvvnv//ff73iY0NDQ6Orpdu3Zt27bt0qXLgAEDBg0aFBsba04Pg0Z+fn58fLzaHj169AcffGBtfwAAAAAggChOAAAAoAbcbndZWZnvbcrKygoLC8+cObNjxw5t5S233LJ06dKOHTvWcQeDivZSl5eXW9sTAAAAAAgshnUCAACAGT777LNLLrlk3rx5iqJY3RcAAAAAgMX45QQAAABqqVWrVsOGDfNYqf60wul0Hjp06MSJEx6PzpkzZ9++fe+9957NZjOrmwAAAACAeofiBAAAAGrppptueuONN3xs4Ha7MzIy3njjjaefflpb+f7777dq1WrZsmV130EAAAAAQD3FsE4AAACoK3a7PTk5ed68eenp6UlJSdr65cuXr1+/3sKOAQAAAACsRXECAAAAda59+/Z79uyJj4/X1tx5551M8gwAAAAAjRbFCQAAAJghNjY2LS1NW8zOzv7b3/5mYX8AAAAAABaiOAEAAACT9OjRY+LEidriH//4Rws7AwAAAACwEBNiAwAAwDxTpkx59dVX1XZ6enpGRka7du1873L48OHVq1d/++23P/zww/nz52NiYvr163fNNdeMHj26a9euNpvNz0MrivLTTz+tWbNm3bp1e/bsycvLa9WqVd++fa+//vr/+Z//0U+J4UNxcfF33323fv36HTt27NmzJzs7OzQ0tHXr1n369OnTp8/IkSN79uzpf5eys7NXr179j3/8Y/v27U6ns0WLFgMHDhw+fPhtt90WGxvr55NoAvVCAQAAAIAJbIqiWN0HAAAANBjvvPPOvffeq7YfeOCBN954o6bP0LZt28zMTLX93nvvjRkzprotf/7557vuumv37t3VbXDppZd++OGHvXv3vuhBv/jii4ceekg7blV33333yy+/3KxZs+o2KC4unj9//rPPPut2u30cqGPHjh999FGfPn1896eoqEhfp6nqT3/607hx4xITE9XF22677ZNPPqlu4wC+UAAAAABgDoZ1AgAAgKluvvlmrb1x40av2yiKMn/+/B49evj4wl1EDh061KdPnxkzZvi44cblct1zzz2jRo3yUZkQkVWrVnXo0KG6bTIzMzt06PDMM8/4rkyIyJEjR/r27bt69Wof25w+fbpr164+KhMiMmfOnH79+vk+lgT0hQIAAAAAM1GcAAAAgKmuueYarb1582av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/PDDrFmzjAY4Gj58uErPnDnT+n5+/PFHlX7++edl4sqVK2phkyZNzA7lpBgMBm13i3b6a+WVV15R6ffff996SNZjdmJBAQAAAID70TkBAAAAl8vNzW3Xrl1eXp5asmLFCrNt/b179/b29pbpM2fOpKWlWdntzp07Fy9erH7+7//+r3ZtbGxsQECATP/www9WRlIqLCxMTU1VP/v27SsTQUFBamF6enpxcbGVYN56663ff/9d/bx9+7ZpnqFDh6r0rFmzjh49amlv27dv//bbb60czokFBQAAAADuR+cEAAAAXOXevXtZWVkvv/xyvXr1MjMz1fIZM2a0bNnS7CaBgYFqVCUhxKxZs1588cWSkhLTnHv27ImLi1M/R44cWb9+fW0GHx+fr776Sv2Mi4vTTm2t3L59Oz4+Xn0kMX78eDXddL169VQHgE6ne+mllwwGg+keCgsLR4wYMXXqVO1COd2FkerVq8+ePVv9bN269bZt20yzbdq0SXtqZjmxoAAAAADA/TzM/v8KAAAAMGvp0qWDBw+W6bCwsO7duxtlMBgMRUVFly9fPnTo0KVLl0z3MGHCBNPZJrT0en1iYuK6devUksDAwNdee61r166hoaHFxcUnTpyYP3/++vXrVYaIiIj09HRfX1/TYPr06aP9BKFjx47jxo2LjIz08/O7dOnSxo0b33rrraKiIrk2MjLy4MGDqkNCCPHWW29NmTJF/YyKipo0aVKLFi0CAgIKCwtPnjy5YcOGzz77rLS0VAjh6elZtWrVW7duqRMx/TpEr9d369btl19+UUvi4+PHjBkTERGh1+uzsrLmzp2rXSslJyevXr3adQUFAAAAAG5G5wQAAADKQds5YYd58+aNHj26zGz37t37n//5n+XLl9uyz6ZNm+7evbtatWqWdjV48OAVK1aUuZ9GjRrt27dPO5ST3Lxt27ZlzqcthIiMjPzxxx/nzp07f/58ueTmzZuBgYGmOYuLixMTE8ucxXrkyJGbN28+deqUsNA5IZxaUAAAAADgTgzrBAAAAJfz8vL63//93/Pnz9vSMyGEqFSp0rJly7Zu3RoWFmZ9t9OnTz906JCVBvdKlSotX75848aNwcHBVnY1adKkI0eOGPVMyM137dr13HPPWdnWz8/vq6++OnToUP369bt27aqW79ixw2z+ypUrb9iwYf78+dpPNIzMnz//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zODr62t2t0lJSTJDdna2aahLliw5duzYI488YjbUtLQ0031aOn0pNzc3Ojra0n8xkpKSCgsLjTZxJBhLfv/9d0sxnD592omHvnHjRkJCgqVjxcfHX79+3caYlUmTJsnNz58/ry6fcuHCBacE8P3333t7e1va8NVXX713757RJqq4cnNzMzIyfH19TTcMDQ3NzMy0cnaOlFi5apctdcC0Mut0uho1asiFR48etRTJ5cuXZR5/f3+jgnJFlbCvBBwMKTU1VWb44YcfzAZj327feOMNmWH58uX79+83W4vCw8O196li461helnLrAytW7eWP1euXGmp8O/duxcQECCzFRQUWMomuejRLbdduHCh9fkMUlNTTe9fg113fZnUY+Hy5ct79+5V56XVsmVLWWJnz54NCwszzdCwYUNL98WpU6es1Plu3bpdvXrVUmzlOl8b/2qYNWHCBEvb1qtXT5vT7svn6nK2u6jLfFAYDIaRI0fKPD///LPRKlfUSQAPDTonAAAAADPK7Jz44osvvLy8ZDo6Orpv376NGzfW/n/7008/tfFY6jVeb29v0/+iG73Ub9SGZTAYSkpK5KrQ0FCzocbFxanNIyIikpOTW7Rood3nRx99ZOPpGwyGo0ePalsZgoKCevTo0aNHD237Y3R0dElJibOCseSPP/4YMGBA37591bZJSUkDBgwYMGBAfn6+sw6dl5en7YKqUaNGjx49EhMTa9WqpRYGBwfn5eXZGLakWmB79OghEzExMd27d/fy8urZs6dTAtiyZYvK4OnpGRMTk5yc3KVLF1VvhRADBgww2koV1+LFi1XOqKio5ORkbUOYp6dnRkaG2VNzpMTKW7tsqQNmK/M777wjF06cONHSNfrss89knsmTJzvrBMtk3/1ld0jW2xzt3q3qnOjWrZs27OTk5Dp16mhr0eHDh422tfHWML2sZVYG9X1Du3btLJX/nj17ZJ5BgwaVcalc9ug2GAxDhgzRbtumTZvk5OSEhASjxujx48cbbWjfXV8m9VhYsGCB2k9sbGxiYqK2hgwYMODs2bN+fn5CCC8vr7i4uMTERG0Le9euXU13vn37du1JBQcH9+zZMz4+XrthQEDAH3/8Ybptec/Xxr8aZi1fvlzmlCcohIiLi5NLRo8erc1p9+VzaTk7UtSOdE64qE4CeGjQOQEAAACYUWbnhDR27Nhb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" /><!-- --></p>
<ul>
<li><p>The plot illustrates that it is not necessarily a case of celebrities massively influencing popular names for the time. This is especially true for characters, which can be seen from the line for Dorothy. John and Paul had already massively popular names, and so did not exert much influence over their popularitys. The exceptions to this rule would be Elvis Presley and Mariah Carey, who had notable influences on the popularity of their names in the decade they were most famous.</p></li>
<li><p>It can be seen for almost all celebrities, that even if they do have influence over the popularity of their names, this popularity always decreases by the next decade.</p></li>
<li><p>Thus, the toy agency can look at popular celebrities to attempt and predict naming trends. However, these trends will be temporary, and so toy production will have to be often changing if they do go with this strategy.</p></li>
</ul>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
