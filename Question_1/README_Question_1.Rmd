---
title: "Question_1"
author: "Matt Kruger"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
Baby_names <- readRDS("../data/PracData25/US_Baby_names/Baby_Names_By_US_State.rds")
music_charts <- readRDS("../data/PracData25/US_Baby_names/charts.rds")
HBO_credits <- readRDS("../data/PracData25/US_Baby_names/HBO_credits.rds")
HBO_titles <- readRDS("../data/PracData25/US_Baby_names/HBO_titles.rds")
```

Installing all necessary packages
```{r}
install.packages("pacman")
pacman::p_load("tidyverse")
pacman::p_load("lubdridate")
pacman::p_load("stringr")
```

Wrangling the data so that a dataframe is created which only contains the correlation between the top 25 male and top 25 female names in the US in the current year and three years later for each year 1900 - 2011. Note: The years 2012 - 2014 had to be dropped, as those years had no rankings in three years time which they could be compared to.
```{r}
spearman_rank_df <- Baby_names %>% 
    group_by(Year, Name, Gender) %>% 
    summarise(Count = sum(Count)) %>%  #Aggregating the count per names per state, so that count represents the number of babies given that name in that year in the entirety of the US. The state column is dropped by this function.
    group_by(Year, Gender) %>% 
    mutate(rank = rank(-Count)) %>%  #Ranking the baby names, with 1 being the most popular name in that year for its respective gender
    ungroup() %>% 
    filter(rank <= 25) %>%  #Only keeping the 25 most popular names per gender per year
  mutate(Year_plus_3 = Year + 3) 


  spearman_rank_df <- spearman_rank_df %>% 
    left_join( spearman_rank_df %>%
      select(Name, Gender, Year, future_rank = rank),    #Creating a column which is the rank of that name in three years time
    by = c("Name", "Gender", "Year_plus_3" = "Year")) %>% 
    filter(!is.na(future_rank)) %>% 
    group_by(Year, Gender) %>% 
    summarise(
    corr = cor(rank, future_rank, method = "spearman", use = "complete.obs"),
    .groups = "drop")      #Creating a column which is the correlation between the rankings of the top 25 boy names and top 25 girl names in that current year and 3 years later
```

Doing the same data wrangling process, but specifically  for New York
```{r}
spearman_rank_df_NY <- Baby_names %>% 
    filter(State == "NY") %>% 
    group_by(Year, Gender) %>% 
    mutate(rank = rank(-Count)) %>% 
    ungroup() %>% 
    filter(rank <= 25) 

spearman_rank_df_NY <- spearman_rank_df_NY %>% 
  mutate(Year_plus_3 = Year + 3) %>%
  left_join( spearman_rank_df_NY %>%
      select(Name, Gender, Year, future_rank = rank),
    by = c("Name", "Gender", "Year_plus_3" = "Year")) %>% 
    filter(!is.na(future_rank)) %>% 
    group_by(Year, Gender) %>% 
    summarise(
    corr_NY = cor(rank, future_rank, method = "spearman", use = "complete.obs"),
    .groups = "drop")
```

Joining on the correlation calculated for names in New York, to the dataframe of the entire US name correlations
```{r}
spearman_rank_df <- left_join(x = spearman_rank_df, y = spearman_rank_df_NY, join_by(Year, Gender)) %>% rename(US = corr, NY = corr_NY) %>% 
gather(Area, corr, c(US, NY))
```

A function which creates a line graph of a correlation coefficient over time using ggplot. It takes several labels as arguments, as well as user-defined vertical lines to create emphasis in changes between years, etc. Here, it plots the correlation between popular names in the current period and popular names in three years time. I input 1990 and 2003 as vertical lines. 
```{r}
persistance_graph <- correlation_over_time_graph(data = spearman_rank_df, x_label = "Year", y_label = "Persistence of Names Over Time", title = "Name Persistence In The US", x_breaks = c(1910, 1925, 1950, 1975, 1990, 2003, 2011), vlines = c(1990, 2003))

persistance_graph
```

Wrangling the data to identify the top music artists of each decade
```{r}
popular_artists <- music_charts %>% 
    
    #renaming the columns to fit R naming norms
    rename(weeks_on_board = `weeks-on-board`, peak_rank = `peak-rank`) %>% 
    mutate(date = as.Date(date)) %>% 
    
    #Using my decade function to create a column which takes on the value of the decade that date is in
    decade(., date) %>% 
    
    #Filtering for relevant dates given the baby name data
    filter(date >= lubridate::ymd(19100101) & date <= lubridate::ymd(20141231)) %>%
    
    #Removing features from artist names, and splitting up the observation if more than one main artist is credited
    mutate(artist = str_remove(artist, regex(" featuring .*", ignore_case = T))) %>%
    mutate(artist = str_remove(artist, regex( "With .*", ignore_case = T))) %>% 
    separate_rows(artist, sep = " & ") %>%
    separate_rows(artist, sep = ",") %>% 
     mutate(artist = str_trim(artist)) %>% 
    group_by(song) %>% 
    
    #Only keeping the last week which the song was on the charts, so that the "weeks_on_board" column represents the total number of weeks a song was ever on the charts for
    filter(weeks_on_board == max(weeks_on_board)) %>% 
    ungroup()  %>% 
    
    #Using my song ranking function to calculate an overall song ranking. It divides the total number of weeks a song was on the chart by the songs peak rank(so songs which got a high ranking(lower number) and a large number of weeks on the charts will have a high overall ranking)
    song_ranking(weeks_on_board, peak_rank) %>% 
    group_by(artist, decade) %>% 
    
    #Calculating an artists overall popularity by summing together the scores of all their songs on the charts
    summarise(artist_popularity = sum(overall_song_rank)) %>% 
    group_by(decade)%>% 
    
    #Selecting the most popular artist per decade
    slice_max(order_by = artist_popularity, n = 1, with_ties = FALSE) %>%
  ungroup()
```



